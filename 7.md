# 第 7 讲：贪心算法（I）（Greedy Algorithms (I)）

## 核心知识点

### 1. 概述（Overview）

#### 1.1 贪心算法的本质

- 无统一定义，核心是**短视选择（Myopic Choice）**：每步仅选当前局部最优解，逐步推导全局解。
- 优势：实现简单，常结合优先队列，运行速度快；劣势：需严格证明正确性（多数直观贪心策略非最优）。
- 关键判断：
    - 坏选择：存在反例证明策略失效；
    - 好选择：能通过数学证明策略必获最优解（**所有贪心算法都需正确性证明**）。

#### 1.2 经典示例：硬币找零的收银员算法（Casher’s Algorithm，Problem 15-1）

- 问题：给定面额（如 1,5,10,25,100 美分），用最少硬币凑指定金额。
- 贪心策略：每次选 “不超过剩余金额的最大面额硬币”。
    - 示例：$2.89（289 美分）→ 2×100 + 1×25 + 1×10 + 1×5 + 4×1（共 9 枚）；
    - 非最优情况：若面额为 1,5,10,20,25，凑 30 美分时，贪心选 25+5（2 枚），最优为 20+10（2 枚，同优）；但凑 40 美分时，贪心选 25+10+5（3 枚），最优为 20+20（2 枚，反例）。

### 2. 活动选择（Activity Selection，CLRS 15.1）

#### 2.1 问题定义

- 输入：n 个活动（任务），每个活动 j 有开始时间\(s_j\)、结束时间\(f_j\)；
- 兼容条件：两个活动无时间重叠（\(s_j ≥ f_k\)或\(s_k ≥ f_j\)）；
- 目标：找到**规模最大**的互斥活动子集。

#### 2.2 三种候选贪心策略（Ex 15-1.3）

|策略|逻辑|是否最优|反例 / 说明|
|---|---|---|---|
|最早开始时间优先|选当前开始最早的活动|否|长活动占据大量时间，排除更多短活动|
|最短区间优先|选当前持续时间最短的活动|否|短活动可能位于关键时间区间，排除更多活动|
|最早结束时间优先|选当前结束最早的活动|是|留给后续活动的时间最多，必获最优|

#### 2.3 最优策略：最早结束时间优先

##### （1）核心步骤

1. 按结束时间排序活动：\(f_1 ≤ f_2 ≤ \cdots ≤ f_n\)；
2. 初始化选中集合\(S = \{1\}\)，记录最后选中活动索引\(l=1\)；
3. 遍历剩余活动：若\(s_j ≥ f_l\)（与最后选中活动兼容），则加入S，更新\(l=j\)。

##### （2）正确性证明（三种方法）

1. **归纳法 + 首次选择合理性**：
    
    - 命题：存在最优解包含首次选中的活动 1（最早结束）；
    - 反证：若最优解O不含活动 1，设\(j>1\)是O中首个活动，因\(f_1 ≤ f_j\)，活动 1 与j重叠，替换O中的j为 1，得\(O'=(O\setminus\{j\})\cup\{1\}\)，仍为最优解；
    - 归纳推导：剩余子问题\(I'\)（排除活动 1 及冲突活动）的贪心解\(S\setminus\{1\}\)必为\(I'\)的最优解，故S是全局最优。
2. **扩展公共前缀（CP）**：
    
    - 反证：假设贪心解\(I_1,I_2,\cdots,I_k\)非最优，取与贪心解有最长 CP 的最优解\(J_1,J_2,\cdots,J_m\)（\(I_1=J_1,\cdots,I_r=J_r\)）；
    - 因\(f_{I_{r+1}} ≤ f_{J_{r+1}}\)，替换\(J_{r+1}\)为\(I_{r+1}\)，得更长 CP 的最优解，与假设矛盾。
3. **达到上界**：
    
    - 将活动划分为 “团（Clique）”：每个选中活动及冲突活动构成一个团，每个团最多贡献 1 个活动到解中；
    - 贪心策略选每个团的最早结束活动，恰好覆盖所有团，达到解的上界（团数），故为最优。

##### （3）拉取式实现（Pull-style Implementation）

plaintext

```plaintext
// 前提：活动按结束时间排序 f₁ ≤ f₂ ≤ ⋯ ≤ fₙ
S ← {1}, l ← 1;  // S：选中活动集，l：最后选中活动索引
for j from 2 to n do 
  if fₗ ≤ sⱼ then  // 兼容条件
    S ← S ∪ {j}; 
    l ← j; 
return S;
```

- 时间复杂度：排序\(O(n\log n)\) + 选择\(O(n)\)，总\(O(n\log n)\)。

### 3. 最长递增子序列（Longest Increasing Subsequence，LIS，Ex 14.4-6）

#### 3.1 问题定义

- 输入：整数数组（如 [6,3,5,10,5,9,7,8]）；
- 目标：找到最长的严格递增子序列（可不连续）。

#### 3.2 纸牌游戏类比与贪心策略

- 规则：将纸牌分最少堆，要求 “堆顶纸牌值 ≥ 下方纸牌值”；
- 贪心堆策略：
    1. 每张纸牌放入 “最左侧能容纳它的堆”（堆顶值 > 当前纸牌值）；
    2. 维护 “堆顶递增” 不变性：所有堆的堆顶值呈严格递增。
- 关键性质（弱对偶性）：**最长递增子序列长度 = 最少堆数**，且沿最后一堆堆顶回溯可还原 LIS。

#### 3.3 实现细节

- 核心数组：
    - \(c[1:n]\)：纸牌（数组）序列；
    - \(p[1:n]\)：每张纸牌所属堆索引；
    - \(b[1:n]\)：回溯指针（指向前一堆堆顶纸牌索引）；
    - \(t[1:n]\)：每堆堆顶纸牌的索引。
- 伪代码：

plaintext

```plaintext
k ← 1;  // 初始堆数
p[1] ← 1; b[1] ← 0; t[1] ← 1;  // 第一张纸牌入第1堆
for i from 2 to n do 
  if c[i] > c[t[k]] then  // 新建堆
    k ← k+1; 
    p[i] ← k; 
    b[i] ← t[k-1]; 
    t[k] ← i; 
  else  // 二分查找最左侧可容纳堆
    j ← 二分查找最小j ≤ k，满足c[t[j]] < c[i]; 
    p[i] ← j; 
    b[i] ← t[j-1]; 
    t[j] ← i; 
```

- 时间复杂度：\(O(n\log k)\)（k 为堆数，≤n）；还原 LIS：\(O(n)\)（沿\(t[k]\)和b回溯）。

### 4. 最小化最大延迟（Minimizing Maximum Lateness，KT 4.2）

#### 4.1 问题定义

- 输入：n 个项目，每个项目 j 有处理时间\(t_j\)、截止时间\(d_j\)；
- 延迟定义：项目 j 的延迟为\(\max\left\{\sum_{i=1}^j t_{\sigma(i)} - d_{\sigma(j)}, 0\right\}\)（\(\sigma\)为处理顺序）；
- 目标：找到处理顺序，使**最大延迟最小**。

#### 4.2 候选策略与最优解

|策略|逻辑|是否最优|反例 / 说明|
|---|---|---|---|
|最短处理时间优先（SPT）|按\(t_j\)递增排序|否|短任务截止晚，抢占早截止长任务的时间|
|最小松弛时间优先|按\(d_j - t_j\)递增排序|否|松弛时间小但截止晚，仍可能导致早截止任务延迟|
|最早截止时间优先（EDF）|按\(d_j\)递增排序|是|优先处理早截止任务，必最小化最大延迟|

#### 4.3 EDF 策略的正确性证明

1. **相邻交换论证**：
    
    - 反证：假设 EDF 非最优，取与 EDF 逆序最少的最优顺序\(\sigma\)，必存在相邻逆序\((i,j)\)（\(d_i < d_j\)但\(\sigma(i)=j,\sigma(j)=i\)）；
    - 交换\(i,j\)：新顺序的最大延迟不增（因\(f_i ≤ d_i < d_j\)，交换后j的延迟可能减少，i的延迟不变），与\(\sigma\)的逆序最少矛盾。
2. **达到下界**：
    
    - 下界：对任意项目子集S，最优最大延迟≥\(\max\left\{\sum_{i\in S}t_i - \max_{i\in S}d_i, 0\right\}\)；
    - EDF 策略可达下界：按\(d_j\)排序后，最大延迟恰为\(\max\left\{\sum_{i=1}^j t_i - d_j, 0\right\}\)，等于某子集\(S=[1..j]\)的下界，故为最优。

#### 4.4 Jackson EDF 规则

- 命题：项目集可无延迟完成，当且仅当按 EDF 顺序处理时所有项目均满足截止时间。

### 5. 最多提前完成的任务（Maximum Early Jobs）

#### 5.1 问题定义

- 输入：n 个任务，每个任务 j 有处理时间\(t_j\)、截止时间\(d_j ≥ t_j\)（单机器，一次处理一个）；
- 目标：选择**最多数量**的可提前完成任务（总处理时间≤截止时间）。

#### 5.2 贪心策略：Moore-Hodgson 算法（贪心拒绝）

- 核心逻辑：
    
    1. 按截止时间排序任务（\(d_1 ≤ d_2 ≤ \cdots ≤ d_n\)）；
    2. 逐步加入任务，若当前集合S的总处理时间 > 截止时间（不可行），则**删除S中处理时间最长的任务**（贪心拒绝）。
- 伪代码：
    

plaintext

```plaintext
S ← ∅; 
for j from 1 to n do 
  S ← S ∪ {j}; 
  if sum(t_i for i in S) > d_j then  // S不可行
    i ← S中t_i最大的任务索引; 
    S ← S \ {i}; 
return S;
```

#### 5.3 最大堆优化实现

- 用最大堆维护当前集合S的任务处理时间，快速获取并删除最长任务：

plaintext

```plaintext
max_heap ← ∅; total_time ← 0; 
for j from 1 to n do 
  Insert(t_j, max_heap);  // 加入当前任务
  total_time ← total_time + t_j; 
  if total_time > d_j then  // 不可行
    longest_t ← ExtractMax(max_heap);  // 删除最长任务
    total_time ← total_time - longest_t; 
return 堆大小;  // 最多提前完成的任务数
```

- 时间复杂度：\(O(n\log n)\)（堆操作 + 排序）。

### 6. 贪心算法正确性证明核心方法

1. **达到上界**：证明贪心解的规模 / 价值等于问题的理论上界；
2. **替换论证**：证明最优解可通过替换操作转化为贪心解，且解的质量不变；
3. **交换论证**：证明非贪心顺序可通过相邻交换优化，最终变为贪心顺序。

## 练习题及答案

## 一、Practice: Fractional Knapsack（分数背包问题）

### 问题描述

给定n个物品，物品i的重量为\(w_i\)磅，价值为\(v_i\)美元；背包容量为W磅。物品可分割（允许装入部分），目标是填充背包，使总价值最大化（定义回报率\(r_i = v_i / w_i\)）。

数学建模：\(\max \sum_{i=1}^n r_i x_i \\ \text{s.t. } 0 ≤ x_i ≤ w_i \ (\forall 1≤i≤n), \quad \sum_{i=1}^n x_i ≤ W\)

### 详细答案

#### （1）核心贪心思路

分数背包的最优解依赖 “**回报率优先**”—— 按回报率\(r_i = v_i / w_i\)从高到低选择物品，优先将高回报率物品装满背包，剩余容量装入下一个高回报率物品的部分（若有剩余）。

→ 直觉：高回报率物品单位重量价值最高，优先选择能最大化总价值，符合贪心 “局部最优→全局最优”。

#### （2）实现步骤

1. **预处理：计算回报率并排序**
    
    遍历所有物品，计算每个物品的回报率\(r_i = v_i / w_i\)，按\(r_i\)降序排序物品（若回报率相同，优先选重量小的，不影响结果）。
    
2. **贪心选择与填充背包**
    
    初始化总价值\(total\_value = 0\)，剩余容量\(remaining\_W = W\)：
    
    plaintext
    
    ```plaintext
    for 物品 in 按r_i降序排序后的列表:
        if remaining_W ≤ 0:
            break
        # 能装下完整物品：全部装入
        if 物品.w_i ≤ remaining_W:
            total_value += 物品.v_i
            remaining_W -= 物品.w_i
        # 只能装部分：装入剩余容量对应的比例
        else:
            ratio = remaining_W / 物品.w_i
            total_value += 物品.v_i * ratio
            remaining_W = 0
    return total_value
    ```
    
3. **正确性证明（达到上界）**
    
    假设存在更优解X，与贪心解G的选择不同：设i是贪心解中第一个选择的物品，而X中该物品未被优先选择（或选择比例更低）。用X中低回报率物品的部分替换为物品i的同等重量，总价值会增加，与X是最优解矛盾。故贪心解达到价值上界，是最优解。
    

#### （3）时间复杂度

- 排序：\(O(n\log n)\)（主导时间）；
- 填充背包：\(O(n)\)；
- 总复杂度：\(O(n\log n)\)。

#### （4）示例

物品：A（w=2, v=10，r=5）、B（w=3, v=12，r=4）、C（w=5, v=15，r=3），背包容量\(W=6\)：

1. 排序后：A → B → C；
2. 装入 A（w=2，v=10），剩余\(W=4\)；
3. 装入 B（w=3，v=12），剩余\(W=1\)；
4. 装入 C 的 1/5（w=1，v=3）；
5. 总价值：10+12+3=25。

## 二、Practice: Refueling stops（Ex 15.2-4，CLRS）

### 问题描述

从武汉自驾到北京，沿固定路线有加油站\(0 = s_1 < s_2 < \cdots < s_n = L\)（L为总路程）；油箱容量C（大于任意相邻加油站距离）。目标：使加油停靠次数最少。

### 详细答案

#### （1）核心贪心思路：卡车司机算法（Truck Driver's Algorithm）

“**尽量开到最远的可到达加油站再停靠加油**”—— 每次加满油后，选择 “当前位置出发能到达的最远加油站” 作为下一个停靠点，避免不必要的停靠。

#### （2）实现步骤（双指针 / 贪心选择）

1. 初始化：当前位置\(curr\_pos = s_1 = 0\)，当前油量\(fuel = C\)，停靠次数\(count = 0\)，加油站索引\(i = 1\)；
    
2. 迭代直至到达北京（\(curr\_pos = L\)）：
    
    plaintext
    
    ```plaintext
    while curr_pos < L:
        # 找到当前能到达的最远加油站
        next_pos = curr_pos
        while i ≤ n and s_{i+1} - curr_pos ≤ fuel:
            next_pos = s_{i+1}
            i += 1
        if next_pos == curr_pos:
            # 无法到达下一个加油站（但题目说C>最大相邻距离，此情况不会发生）
            return -1
        if next_pos == L:
            break  # 到达终点，无需再加油
        # 停靠加油
        count += 1
        curr_pos = next_pos
        fuel = C  # 加满油
    return count
    ```
    
3. 正确性证明（归纳法）
    
    - 基础步：若只有 1 个加油站（\(n=1\)），无需停靠，正确；
    - 归纳步：假设前k个加油站的停靠次数最优，对于第\(k+1\)个加油站，贪心选择最远可到达的站点，减少后续停靠次数，故全局最优。

#### （3）时间复杂度

- 线性遍历加油站：\(O(n)\)（每个加油站仅访问一次）；
- 总复杂度：\(O(n)\)。

#### （4）示例

加油站：0→20→50→70→100（L=100），油箱容量\(C=40\)：

1. 从 0 出发，油量 40，能到达 50（20→50 距离 30≤40，50→70 距离 20≤40，但 70-0=70>40，故最远到 50）；
2. 停靠 50，加油（count=1），油量 40；
3. 从 50 出发，能到达 100（50→70→100 距离 50≤40？不，50→100 距离 50>40，最远到 70）；
4. 停靠 70，加油（count=2），油量 40；
5. 从 70 出发，到达 100（距离 30≤40）；
6. 总停靠次数：2。

## 三、Practice: Longest alternating subsequence (LAS)

### 问题描述

序列\(B[1..m]\)为交替序列，若对\(i=2,3,\cdots,m\)，\(B[i]-B[i-1]\)的符号交替变化（如 π 序列\(3,1,4,1,5,9,2,6\)的 LAS 为\(3,1,4,1,5,2,6\)）。给定整数数组\(A[1..n]\)，在\(O(n)\)时间内找到 LAS。

### 详细答案

#### （1）核心贪心思路

维护两个状态变量，记录 “以当前元素结尾的交替子序列长度”：

- \(up[i]\)：以\(A[i]\)结尾，最后一步为 “上升”（\(A[i] > A[i-1]\)）的 LAS 长度；
- \(down[i]\)：以\(A[i]\)结尾，最后一步为 “下降”（\(A[i] < A[i-1]\)）的 LAS 长度。
    
    → 贪心递推：利用前一个元素的状态快速更新当前状态，无需回溯，达到\(O(n)\)时间。

#### （2）实现步骤

1. 初始化：\(up[0] = 1\)，\(down[0] = 1\)（单个元素的 LAS 长度为 1）；
    
2. 遍历数组\(i=1\)到\(n-1\)：
    
    plaintext
    
    ```plaintext
    for i from 1 to n-1:
        if A[i] > A[i-1]:
            # 当前上升，承接前一个下降的状态
            up[i] = down[i-1] + 1
            down[i] = down[i-1]  # 下降状态不变
        elif A[i] < A[i-1]:
            # 当前下降，承接前一个上升的状态
            down[i] = up[i-1] + 1
            up[i] = up[i-1]  # 上升状态不变
        else:
            # 相等，状态不变
            up[i] = up[i-1]
            down[i] = down[i-1]
    return max(up[n-1], down[n-1])
    ```
    
3. 空间优化
    
    无需存储数组，仅用两个变量up和down滚动更新：
    
    plaintext
    
    ```plaintext
    up = down = 1
    for i from 1 to n-1:
        if A[i] > A[i-1]:
            up = down + 1
        elif A[i] < A[i-1]:
            down = up + 1
    return max(up, down)
    ```
    

#### （3）正确性证明

- 状态定义保证：\(up[i]\)和\(down[i]\)记录了以\(A[i]\)结尾的最长交替子序列长度；
- 递推关系正确：上升时只能由前一个下降状态扩展，下降时只能由前一个上升状态扩展，符合交替定义。

#### （4）时间复杂度

- 线性遍历数组：\(O(n)\)；
- 空间复杂度：\(O(1)\)（优化后）。

#### （5）示例

数组\(A = [3,1,4,1,5,9,2,6]\)：

- \(i=1\)（1<3）：down=2，up=1；
- \(i=2\)（4>1）：up=3，down=2；
- \(i=3\)（1<4）：down=4，up=3；
- \(i=4\)（5>1）：up=5，down=4；
- \(i=5\)（9>5）：up=5（不变），down=4；
- \(i=6\)（2<9）：down=6，up=5；
- \(i=7\)（6>2）：up=7，down=6；
- 结果：LAS 长度 = 7（\([3,1,4,1,5,2,6]\)）。

## 四、Practice: Interval coloring（Ex 15.1-4，CLRS）

### 问题描述

给定n个讲座，讲座j的开始时间为\(s_j\)，结束时间为\(f_j\)。目标：找到最少的教室数量，使所有讲座可安排（同一教室无同时进行的讲座）。

### 详细答案

#### （1）核心贪心思路

“**按开始时间排序 + 优先分配最早空闲的教室**”：

1. 按讲座开始时间\(s_j\)升序排序（若\(s_j\)相同，\(f_j\)小的在前）；
2. 用最小堆（优先队列）维护 “当前所有教室的最早结束时间”；
3. 对每个讲座，若最早结束的教室空闲（结束时间≤当前讲座开始时间），则复用该教室；否则新建教室。

#### （2）实现步骤

1. 排序：将讲座按\(s_j\)升序排序；
    
2. 初始化最小堆heap（存储教室的结束时间）；
    
3. 遍历每个讲座\((s, f)\)：
    
    plaintext
    
    ```plaintext
    for each (s, f) in sorted intervals:
        if heap is not empty and heap[0] ≤ s:
            # 复用最早空闲的教室
            heappop(heap)
        heappush(heap, f)  # 更新教室的结束时间（复用或新建）
    return len(heap)  # 堆的大小=最少教室数
    ```
    
4. 正确性证明（达到下界）
    

- 下界：讲座的 “最大重叠数”（同一时间进行的最多讲座数）是最少教室数的下界；
- 贪心解达到下界：按开始时间排序后，堆中始终存储当前所有进行中的讲座的结束时间，堆的大小即为当前重叠数，最终堆大小 = 最大重叠数，故为最优。

#### （3）时间复杂度

- 排序：\(O(n\log n)\)；
- 堆操作：每个讲座入堆 / 出堆各一次，共\(O(n\log n)\)；
- 总复杂度：\(O(n\log n)\)。

#### （4）示例

讲座：(9,10), (9:30,11), (10,12), (11:30,13), (12,14)：

1. 排序后：(9,10), (9:30,11), (10,12), (11:30,13), (12,14)；
2. 第一个讲座 (9,10)：堆空，入堆 [10]，教室数 = 1；
3. 第二个讲座 (9:30,11)：堆顶 10>9:30，入堆 [10,11]，教室数 = 2；
4. 第三个讲座 (10,12)：堆顶 10≤10，出堆，入堆 [11,12]，教室数 = 2；
5. 第四个讲座 (11:30,13)：堆顶 11≤11:30，出堆，入堆 [12,13]，教室数 = 2；
6. 第五个讲座 (12,14)：堆顶 12≤12，出堆，入堆 [13,14]，教室数 = 2；

- 结果：最少教室数 = 2。

## 五、Practice: School bus driver assignment

### 问题描述

公交公司有n个早班路线（时长\(a[1..n]\)）和n个晚班路线（时长\(b[1..n]\)），规定时间D。司机加班时间 = \(\max(a_i + b_{\sigma(i)} - D, 0)\)（\(\sigma\)为晚班分配顺序）。目标：找到排列\(\sigma\)，使总加班时间最小。

### 详细答案

#### （1）核心贪心思路：排序匹配（早升晚降）

“**早班路线按时长升序排序，晚班路线按时长降序排序**”—— 将最短的早班与最长的晚班配对，次短的早班与次长的晚班配对，最小化单个司机的加班时间总和。

#### （2）正确性证明（交换论证）

假设存在最优配对\(\sigma\)，其中存在两对司机\((a_i, b_j)\)和\((a_k, b_l)\)，满足\(a_i ≤ a_k\)且\(b_j ≤ b_l\)（未按早升晚降配对）。交换后配对为\((a_i, b_l)\)和\((a_k, b_j)\)，比较总加班时间：

- 原加班时间：\(\max(a_i+b_j-D,0) + \max(a_k+b_l-D,0)\)；
- 新加班时间：\(\max(a_i+b_l-D,0) + \max(a_k+b_j-D,0)\)；
    
    → 由于\(a_i ≤ a_k\)且\(b_j ≤ b_l\)，新配对的总加班时间≤原配对，故排序匹配是最优。

#### （3）实现步骤

1. 排序：早班数组a按升序排序，晚班数组b按降序排序；
2. 配对：司机i分配早班\(a[i]\)和晚班\(b[i]\)；
3. 计算总加班时间：\(\sum_{i=1}^n \max(a[i] + b[i] - D, 0)\)。

#### （4）时间复杂度

- 排序：\(O(n\log n)\)；
- 配对与计算：\(O(n)\)；
- 总复杂度：\(O(n\log n)\)。

#### （5）示例

\(a = [2,3,5]\)（早班），\(b = [4,3,2]\)（晚班），\(D=7\)：

1. 排序后：\(a=[2,3,5]\)，\(b=[4,3,2]\)；
2. 配对：(2+4=6≤7，加班 0)、(3+3=6≤7，加班 0)、(5+2=7≤7，加班 0)；
3. 总加班时间 = 0（最优）。

## 六、Practice: Weighted variants of early jobs

### 问题描述

每个任务i按时完成（≤\(d[i]\)）可获利润\(p[i]\)，目标是最大化总利润。两种变体：

1. 变体 1：所有任务处理时间为 1（单位处理时间）；
2. 变体 2：任务满足\(t_i ≤ t_j \Rightarrow p_i ≥ p_j\)（短任务利润不低于长任务）。

### 详细答案

#### 变体 1：单位处理时间（\(t_i=1\)）

##### （1）核心贪心思路：按截止时间降序排序，优先选择利润高的任务

- 截止时间\(d[i]\)表示任务最晚可在第\(d[i]\)个时间槽完成；
- 用数组\(slot[1..max_d]\)记录时间槽是否被占用，优先将高利润任务分配到其截止时间前的最晚空闲槽。

##### （2）实现步骤

1. 排序：任务按利润\(p[i]\)降序排序（利润相同按\(d[i]\)降序）；
2. 初始化：\(max_d = \max(d[i])\)，\(slot[1..max_d] = false\)（未占用）；
3. 遍历每个任务\((p, d)\)：
    
    plaintext
    
    ```plaintext
    total_profit = 0
    for each (p, d) in sorted tasks:
        # 找到d之前的最晚空闲槽
        for t from d down to 1:
            if not slot[t]:
                slot[t] = true
                total_profit += p
                break
    return total_profit
    ```
    

##### （3）时间复杂度

- 排序：\(O(n\log n)\)；
- 分配时间槽：\(O(n \cdot max_d)\)（可优化为\(O(n\log n)\)，用并查集快速找空闲槽）；
- 优化后总复杂度：\(O(n\log n)\)。

#### 变体 2：\(t_i ≤ t_j \Rightarrow p_i ≥ p_j\)

##### （1）核心贪心思路：按截止时间升序排序（EDF），用最大堆维护已选任务

- 按\(d[i]\)升序选择任务，若总处理时间超过\(d[i]\)，移除堆中处理时间最长的任务（因\(t_i ≤ t_j \Rightarrow p_i ≥ p_j\)，长任务利润更低，移除更优）。

##### （2）实现步骤

1. 排序：任务按\(d[i]\)升序排序；
2. 初始化：最大堆heap（存储已选任务的\(t_i\)），\(total_t = 0\)，\(total_p = 0\)；
3. 遍历每个任务\((t, d, p)\)：
    
    plaintext
    
    ```plaintext
    heappush(heap, t)
    total_t += t
    total_p += p
    if total_t > d:
        # 移除最长任务（利润最低）
        longest_t = heappop(heap)
        total_t -= longest_t
        total_p -= p_longest（对应longest_t的利润）
    return total_p
    ```
    

##### （3）正确性证明

- 因\(t_i ≤ t_j \Rightarrow p_i ≥ p_j\)，堆中最长任务的利润最低，移除后总利润损失最小，且总处理时间恢复可行，故贪心选择最优。

##### （4）时间复杂度

- 排序：\(O(n\log n)\)；
- 堆操作：\(O(n\log n)\)；
- 总复杂度：\(O(n\log n)\)。

## 七、Practice: Transshipping packages by train

### 问题描述

火车从车站 1 到n，停靠中间站 2~n-1，容量为C；有\(p_{ij}\)个单位包裹需从站i运到站j（\(1≤i<j≤n\)）。目标：最大化运输的包裹总数。

### 详细答案

#### （1）核心贪心思路：按包裹终点j升序排序，优先运输终点早的包裹

- 终点早的包裹占用火车容量的区间（i到j）更短，可给后续包裹留出更多空间；
- 对每个车站i，装载所有终点\(j>i\)的包裹，不超过火车当前剩余容量。

#### （2）实现步骤

1. 预处理：收集所有包裹需求\((i, j, cnt=p_{ij})\)，按终点j升序排序（j相同按i降序）；
2. 初始化：火车当前容量\(curr_cap = C\)，运输总量\(total = 0\)，记录每个包裹的运输状态；
3. 按车站顺序遍历（从 1 到 n）：
    
    plaintext
    
    ```plaintext
    for station from 1 to n:
        # 卸载本站为终点的包裹，恢复容量
        curr_cap += 卸载的包裹数
        # 装载本站为起点、终点>station的包裹（按j升序）
        for each (i=station, j, cnt) in sorted packages:
            if cnt == 0:
                continue
            load = min(cnt, curr_cap)
            total += load
            curr_cap -= load
            cnt -= load  # 更新剩余未运输包裹数
    return total
    ```
    

#### （3）正确性证明

- 假设存在更优解，其中某终点晚的包裹优先于终点早的包裹运输，替换两者后，终点早的包裹仍能运输，终点晚的包裹可能仍能运输，总运输量不变或增加，故贪心解最优。

#### （4）时间复杂度

- 排序包裹：\(O(m\log m)\)（m为包裹需求数）；
- 遍历车站与包裹：\(O(n + m)\)；
- 总复杂度：\(O(m\log m)\)。

#### （5）示例

车站 1→2→3→4，火车容量\(C=2\)，包裹：(1,2,2)、(1,3,1)、(2,4,2)：

1. 排序包裹：(1,2,2)→(1,3,1)→(2,4,2)；
2. 车站 1：
    - 无包裹卸载，curr_cap=2；
    - 装载 (1,2,2)：load=2，total=2，curr_cap=0；
3. 车站 2：
    - 卸载 (1,2,2)，curr_cap=2；
    - 装载 (2,4,2)：load=2，total=4，curr_cap=0；
4. 车站 3：
    - 无包裹卸载，curr_cap=0；
    - 无法装载 (1,3,1)；
5. 车站 4：
    - 卸载 (2,4,2)，curr_cap=2；

- 总运输量 = 4（最优）。