
**第 1 页：第 10 讲：最短路径**

1

**提纲**

- 概述
- 有向无环图（DAG）中的最短路径树（SPT）
- 非负权有向图中的最短路径树
- 无负环有向图中的最短路径树
- 所有节点对之间的最短路径

（参考《算法导论》第 22-23 章）

**第 2 页：概述**

单源最短路径（SSSP）

\(D=(V, A ; \ell)\)：带边长度（代价）函数的有向图，其中\(d(v)\)表示图D中从源点s到顶点v的最短路径长度，且\(d(s)=0\)

**第 3 页：补充说明**

全源最短路径（APSP）

单源最短路径（SSSP）

最短回路

单对节点最短路径（SPSP）

**第 4 页：最优子路径**

最优子路径：最短路径的任意子路径，也是其端点之间的最短路径

**第 5 页：贝尔曼原理：无负环（NC）**

若图中无负环，则最优子路径性质成立。

替换与提取

提取：任意从s到t的路径（允许重复节点），都包含一条长度不大于该路径的从s到t的简单路径（无重复节点）。

松弛操作：从s到t的最短路径（允许重复节点）长度等于从s到t的最短简单路径长度。

**第 6 页：贝尔曼方程：无负环**

对所有非源点节点v（\(v≠s\)），有\(d(v)=\min _{(u, v) \in A}\{d(u)+\ell(u, v)\}\)

**第 7 页：最短路径树（SPT）：无负环**

以s为根的生成树，其中每条树路径都是对应端点间的最短路径。

由距离函数d可在线性时间内恢复最短路径树：

紧边集\(A_{0}=\{(u, v) \in A: d(v)=d(u)+\ell(u, v)\}\)

- 所有从s到t的最短路径都包含在\(A_{0}\)中
- 树T是最短路径树，当且仅当\(T \subseteq A_{0}\)

**第 8 页：三种场景下的最短路径树算法**

- 无环图（DAG）：利用拓扑排序，时间复杂度为\(O(m)\)（m为边数）
- 非负权边图：迪杰斯特拉（Dijkstra）算法，近线性时间复杂度
- 无负环图：贝尔曼 - 福特（Bellman–Ford）算法，时间复杂度为\(O(mn)\)（n为节点数）

・负环检测的时间复杂度为\(O(mn)\)

**第 9 页：有向无环图（DAG）中的最短路径树**

（参考《算法导论》第 22.2 节）

有向无环图中最短路径树的动态规划（DP）解法：

对所有非源点节点v（\(v≠s\)），有\(d(v)=\min _{(u, v) \in A}\{d(u)+\ell(u, v)\}\)

按拓扑顺序计算

**第 10 页：补充说明**

将节点按拓扑顺序排序并重新编号为\(s=1,2,\cdots,n\)

**第 11 页：拉取（Pull）与推送（Push）**

拉取（惰性更新）：

plaintext

初始化操作；

对节点按拓扑顺序执行：

    对每个关联边执行操作；

返回结果；

推送（主动更新）：

plaintext

初始化操作；

对节点按拓扑顺序执行初始化；

对每个节点执行操作并处理关联边；

返回结果；

时间复杂度与空间复杂度均为\(O(m+n)\)。

**第 12 页：推送算法演示**

（此处为算法执行过程中的数值变化演示，对应节点的距离值动态更新，如从初始的\(0,2,\infty,7,\infty,\infty\)逐步更新为\(0,2,6,5,3\)等，具体数值需结合原图边权重理解）

**第 13 页：有向无环图中的最长路径树：翻转边权重**

\(E=(V, A ; \ell)\)：带边权重的有向无环图，源点s可到达所有其他节点。

路径长度定义为路径中所有边权重的总和。

\(d(v)\)表示从s到v的所有路径中的最长路径长度。

对所有非源点节点v（\(v≠s\)），有\(d(v)=\max _{(u, v) \in A}\{d(u)+\ell(u, v)\}\)

最长路径树：对每个非源点节点v，选择一个使\(d(u)+\ell(u, v)\)最大的节点u作为其父节点。

**第 14 页：应用场景**

可通过动态规划求解的最优子序列（选择）问题：

・带权区间调度

・序列比对

・分段最小二乘

・背包问题

……

合理构建有向无环图，使（最长 / 最短）路径长度对应（最优）子序列的值。

避免重复造轮子：该方法更直观，概念上更简洁。

**第 15 页：带权区间选择**

n个任务：每个任务由一个时间区间和一个正权重定义。

目标：找到权重总和最大的非重叠任务子集。

（时间轴标注：0 1 2 3 4 5 6 7 8 9 10 11，对应任务\(a,d,b,c,e\)的时间区间）

**第 16 页：最长路径建模：“沉默” 任务的作用（权重为 0）**

蓝色边对应正权重任务，红色边对应权重为 0 的 “填充” 边，节点对应任务的起始和结束端点。

（时间轴标注：0 1 2 3 4 5 6 8 9 10 11，对应任务相关节点与边的连接关系）

**第 17 页：非负权有向图中的最短路径树**

（参考《算法导论》第 22.3 节）

迪杰斯特拉（Dijkstra）方法：

按与源点s的距离递增顺序生成最短路径树。

Q：优先队列；T：已扫描（确定最短距离）的节点集合；Q也表示T的出邻节点集合。

下一步加入T的节点：优先队列Q中\(p(u)\)最小的节点u（\(p(u)\)表示通过T中节点到达s到u的最短距离），类似选择排序的逻辑。

**第 18 页：迪杰斯特拉算法演示**

（此处为算法执行过程中的节点距离更新演示，初始距离包含\(0,5,10,12,\infty,8\)等，逐步更新为\(0,4,3,8\)等，具体数值需结合原图边权重理解）

**第 19 页：正确性证明**

不变式：对集合T中的节点u，有\(p(u)=d(u)\)（\(p(u)\)为计算值，\(d(u)\)为真实最短距离）。

证明采用数学归纳法，基于\(|T|\)（集合T的节点数）：

- 基础情形：若\(|T|=1\)（仅含源点s），结论显然成立。
- 归纳假设：假设当\(|T|<k\)时结论成立。
- 归纳步骤：考虑加入T的节点\(u=v\)，通过归纳假设及最短路径的性质，可证明\(p(v)=d(v)\)。

（图中包含源点s、节点\(x,y\)及最短路径P的示意）

**第 20 页：基于优先队列的实现**

用优先队列表示Q，队列元素按\(p(v)\)（节点v的当前最短距离估计）排序。

plaintext

对每个节点初始化：距离估计、前驱节点；

将源点$s$的距离设为0并加入优先队列；

while 优先队列非空：

    提取队列中$p(u)$最小的节点$u$；

    对$u$的每个出邻节点$v$：

        若通过$u$到达$v$的距离更短：

            更新$v$的距离估计$p(v)$；

            若$v$未在优先队列中：

                将$v$插入优先队列；

            否则：

                更新$v$在优先队列中的优先级（减小键值）；

返回所有节点的最短距离；

在节点u离开优先队列的整个迭代过程中，队列Q中节点的优先级满足\(p(u) \in [0, \ell_{max}]\)（\(\ell_{max}\)为最大边权重）。

提取节点的序列按优先级（距离）单调递增。

**第 21 页：时间复杂度**

|**数据结构**|**斐波那契堆（Fib heap）†**|**二叉堆（Binary heap）**|**数组（Array）**|
|---|---|---|---|
|优先队列操作||||
|插入（Insert）|1（均摊时间）|\(O(\log n)\)|\(O(n)\)|
|提取最小（ExtractMin）|1（均摊时间）|\(O(\log n)\)|\(O(n)\)|
|减小键（DecreaseKey）|1（均摊时间）|\(O(\log n)\)|\(O(1)\)|
|判空（IsEmpty）|1|1|1|
|总时间复杂度|\(O(m + n\log n)\)|\(O(m\log n)\)|\(O(n^2)\)|

† 注：斐波那契堆的时间复杂度为均摊边界。

适用场景：

・数组：适用于极稠密图

・二叉堆：适用于极稀疏图

**第 22 页：迪杰斯特拉算法在含负权边时可能失效（即使是有向无环图）**

（此处为示例图，包含边权重\(0,2,1,-1\)等，演示含负权边时算法得出错误最短距离的情况）

**第 23 页：应用场景：单班机组调度**

在上午 9 点到下午 5 点（9am-5pm）的每个小时，至少需要一名司机值班。

|**值班时段**|**9-10 点**|**9-11 点**|**12-14 点（12-2pm）**|**12-17 点（12-5pm）**|**14-17 点（2-5pm）**|**13-16 点（1-4pm）**|**16-17 点（4-5pm）**|
|---|---|---|---|---|---|---|---|
|成本（cost）|30|18|21|38|20|22|9|

（图中包含成本数值\(30,9,21,22,20,18,38\)及对应时段的连接关系）

**第 24 页：实践：近等权重边（参考《算法导论》习题 22.3-9、22.3-12）**

若所有边权重满足以下条件，可实现线性时间复杂度：

・仅为 1 或 2

・在\([1,2]\)区间内

（提示：使用桶排序队列作为优先队列）

**第 25 页：无负环有向图中的最短路径树**

（参考《算法导论》第 22.1 节）

贝尔曼 - 福特（BF）算法的子问题：限制边数的最短路径

\(d_k(v)\)表示从源点s到顶点v、使用不超过k条边的最短路径长度。

性质：\(d_{k-1}(v) \geq d_k(v)\)（增加边数限制不会使最短路径变长）。

若\(d_{k-1}(v) = d_k(v)\)，则\(d_{k-1}(v) = d_k(v) = d_{k+1}(v) = \cdots\)（后续边数增加不改变最短路径长度）。

**第 26 页：负环检测**

\(k^* = \max_{v \in V} \{\text{从}s\text{到}v\text{的最短路径所需的最小边数}\}\)

（图中包含源点s、节点w、负环C及边权重\(-6,-4,7,8\)，演示负环可无限增加路径长度的特性）

对任意\(\bar{k} > k^*\)，图中无负环，当且仅当\(d_{\bar{k}-1}(v) = d_{\bar{k}}(v)\)对所有节点v成立。

**第 27 页：寻找负环**

・选择满足\(d_{n-1}(v) < d_n(v)\)的节点v（n为节点总数）。

・从s到v、使用不超过n条边的最短路径恰好包含n条边，因此该路径中存在回路。

・该回路C为负环，可通过回溯路径找到。

**第 28 页：贝尔曼 - 福特算法：线性空间实现**

plaintext

初始化所有节点的距离估计；

将源点$s$的距离$p(s)$设为0；

for 迭代次数从1到$n-1$：

    保存当前距离估计为$p'$；

    for 每条边$(u, v)$：

        if $p(v) > p'(u) + \ell(u, v)$：

            更新$p(v) = p'(u) + \ell(u, v)$；

for 每条边$(u, v)$：

    if $p(v) > p(u) + \ell(u, v)$：

        返回存在负环；

返回所有节点的最短距离；

分析：时间复杂度为\(\Theta(mn)\)，空间复杂度为\(\Theta(n)\)。

**第 29 页：贝尔曼 - 福特算法：原地实现**

plaintext

初始化所有节点的距离估计；

将源点$s$的距离$p(s)$设为0；

for 迭代次数从1到$n-1$：

    标记是否有更新；

    for 每条边$(u, v)$：

        if $p(v) > p(u) + \ell(u, v)$：

            更新$p(v) = p(u) + \ell(u, v)$；

            标记有更新；

    if 无更新：

        提前退出循环；

for 每条边$(u, v)$：

    if $p(v) > p(u) + \ell(u, v)$：

        返回存在负环；

返回所有节点的最短距离；

说明：每个有限的\(p(v)\)都对应某条从s到v的路径长度（可通过简单归纳证明），该路径的边数可能超过当前迭代次数。

主动性：经过k次迭代后，\(p(v) \leq d_k(v)\)（\(d_k(v)\)为使用不超过k条边的最短路径长度）。

分析：时间复杂度为\(\Theta(mn)\)，空间复杂度为\(\Theta(n)\)。

**第 30 页：主动性证明**

命题：经过k次迭代后，对所有节点v，有\(p(v) \leq d_k(v)\)。

证明采用数学归纳法，基于迭代次数k，其中\(p_k\)表示经过k次迭代后的距离估计：

- 基础情形（IB）：\(k=0\)时，\(p_0 = d_0\)（初始距离估计与初始最短路径长度一致）。
- 归纳假设（IH）：假设对所有\(i < k\)，有\(p_i \leq d_i\)。
- 归纳步骤（IS）：证明对所有节点v，有\(p_k(v) \leq d_k(v)\)。

情形 1：\(d_k(v) = d_{k-1}(v)\)，由归纳假设可得\(p_k(v) \leq p_{k-1}(v) \leq d_{k-1}(v) = d_k(v)\)。

情形 2：\(d_k(v) = d_{k-1}(u) + \ell(u, v)\)（存在边\((u, v)\)），结合迭代中对边\((u, v)\)的更新操作及归纳假设，可证\(p_k(v) \leq d_k(v)\)。

（图中包含源点s、节点u及迭代k前对\(p(u)\)的最新更新时间i的示意）

**第 31 页：应用场景：互联网路由**

- 迪杰斯特拉算法：（优点）速度快；（缺点）高度 “集中式”（需跟踪所有节点以确定更新对象）。
- 贝尔曼 - 福特算法：（缺点）速度慢；（优点）“分布式” 且更新更灵活，即 “基于传闻的路由”。

（示例：UUNET 北美互联网网络拓扑）

**第 32 页：应用场景：套利机会**

给定n种货币及货币对之间的汇率，判断是否存在套利机会（即通过货币兑换实现本金增值）。

注：高效的套利检测算法具有极高的实用价值！

（图中包含货币\(美元（\)）、英镑（£）、德国马克（DM）、日元（¥）$及汇率$1/7, 800, 2/3, 2, 3/10, 3/50, 1/10000, 170, 56$ 的兑换关系）

**第 33 页：全源最短路径（参考《算法导论》第 23.2-23.3 节）**

弗洛伊德 - 沃肖尔（Floyd-Warshall）算法：子问题划分

\(D=(V, A ; \ell)\)为强连通且无负环的有向图，节点集\(V=\{1,2,\cdots,n\}\)，求解所有节点对之间的最短路径。

・朴素方法：执行n次贝尔曼 - 福特算法，时间复杂度为\(O(n^2m)\)。

・弗洛伊德 - 沃肖尔算法：时间复杂度为\(O(n^3)\)。

子集动态规划：通过限制中间节点的可选集合定义子问题。

\(d_k(i,j)\)表示仅使用节点\(1,\cdots,k\)作为中间节点时，从节点i到节点j的最短路径长度。

**第 34 页：弗洛伊德 - 沃肖尔算法的递推关系**

- 基础情形（\(k=0\)）：不使用任何中间节点，\(d_0(i,j)\)为边\((i,j)\)的权重（若无边则为无穷大，\(d_0(i,i)=0\)）。
- 递推关系（\(k>0\)）：\(d_k(i,j) = \min\{d_{k-1}(i,j), d_{k-1}(i,k) + d_{k-1}(k,j)\}\)（即判断是否通过节点k作为中间节点可获得更短路径）。

标准动态规划实现：时间复杂度\(O(n^3)\)，空间复杂度\(O(n^3)\)。

**第 35 页：弗洛伊德 - 沃肖尔算法的原地实现**

plaintext

初始化距离矩阵$d$：$d(i,j)$为边$(i,j)$的权重，$d(i,i)=0$，无边则为无穷大；

for $k$从1到$n$：  // $k$为当前允许的最大中间节点编号

    for $i$从1到$n$：  // 起点$i$

        for $j$从1到$n$：  // 终点$j$

            if $d(i,j) > d(i,k) + d(k,j)$：

                更新$d(i,j) = d(i,k) + d(k,j)$；

主动性：在算法执行过程中，每个有限的\(d(i,j)\)都对应某条从i到j的路径长度；经过k轮更新后，\(d(i,j) \leq d_k(i,j)\)。

时间复杂度为\(O(n^3)\)，空间复杂度为\(O(n^2)\)。

**第 36 页：突破立方时间复杂度的挑战**

开放问题：是否存在时间复杂度为\(O(n^{3-\varepsilon})\)（\(\varepsilon>0\)）的全源最短路径算法？

・相关研究：[Abboud, Vassilevska-Williams, “Popular conjectures imply strong lower bounds for dynamic problems”, FOCS 2014]（基于常见猜想，证明动态问题存在强下界）。

・目前最快算法：时间复杂度为\(O(n^3 / \log^{100}(n))\)，参考 [Williams, Faster APSP via Circuit Complexity, STOC 2014]。

**第 37 页：核心要点**

・贪心算法与动态规划方法的应用场景

・利用距离函数构建最短路径树及其他应用

・需通过图转化求解的应用问题

**第 38 页：关键边（Vital Edge）**

图G中的关键边是指：移除该边后，从源点s到终点t的最短路径长度会增加的边。

求解步骤：

1. 先计算所有紧边（满足\(d(v)=d(u)+\ell(u,v)\)的边\((u,v)\)）；
2. 计算所有可到达终点t的节点；
3. 仅保留这些节点之间的权值为 0 的边；
4. 通过两次增广路径计算最大流，判断最大流是否为 1（时间复杂度\(O(m)\)）：

- 若最大流\(>1\)，则不存在关键边；
- 若最大流\(=1\)，则每个最小割仅含一条边，进一步找出所有最小割对应的边。

**第 39 页：最关键边（Most Vital Edge）**

最关键边是指：移除后会导致从s到t的最短路径长度增加最多的关键边。

问题：设计一个算法，确定图G中的最关键边，并分析其时间复杂度。

**第 40 页：最关键边的性质判断**

假设网络为有向图，边权重为正，且存在关键边。判断以下命题是否正确，若错误请通过反例说明：

(a) 最关键边是权重\(c_{ij}\)最大的边。

(b) 最关键边是某条从s到t的最短路径中权重\(c_{ij}\)最大的边。

(c) 不属于任何从s到t的最短路径的边，不可能是最关键边。

(d) 一个网络中可能存在多条最关键边。