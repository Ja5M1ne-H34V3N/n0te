# 第 8 讲：贪心算法（II）（Greedy Algorithms (II)）

## 核心知识点

### 1. 赛马问题（Horse Racing）

#### 1.1 问题定义

- 输入：两个**非递减排序**的整数数组 \(a[1..n]\)（\(a[1] \leq a[2] \leq \cdots \leq a[n]\)）和 \(b[1..n]\)（\(b[1] \leq b[2] \leq \cdots \leq b[n]\)）；
- 目标：找到排列 \(\sigma\)（\(\{1,2,\cdots,n\}\) 的重排），最大化得分 \(\sum_{i=1}^n \text{sign}(a[\sigma(i)] - b[i])\)（符号函数：\(x>0\) 得 1，\(x=0\) 得 0，\(x<0\) 得 - 1）。

#### 1.2 核心贪心策略（三种配对情况）

核心逻辑：通过局部最优配对（最大化单组得分或最小化失分），递归推导全局最优，无反例且可通过数学证明正确性。

|情况|条件|配对策略|得分逻辑|
|---|---|---|---|
|情况 1|\(a[1] > b[1]\)|\(a[1] \leftrightarrow b[1]\)（最小对最小）|必得分 1，剩余子数组递归处理，总得分不低于其他配对方式|
|情况 2|\(a[n] > b[n]\)|\(a[n] \leftrightarrow b[n]\)（最大对最大）|必得分 1，剩余子数组递归处理，总得分不低于其他配对方式|
|情况 3|\(a[1] \leq b[1]\) 且 \(a[n] \leq b[n]\)|\(a[1] \leftrightarrow b[n]\)（最小对最大）|最小化失分（最多失 1 分），剩余子数组递归处理，总失分不高于其他配对方式|

#### 1.3 算法实现（线性时间）

- 双指针法：用 \(l/r\) 指向 a 的左右端点，\(s/t\) 指向 b 的左右端点，迭代配对直至所有元素处理完毕。
- 伪代码：

plaintext

```plaintext
l ← 1, r ← n;  // a数组指针（左/右）
s ← 1, t ← n;  // b数组指针（左/右）
σ ← 空数组;
while l < r do
  if a[l] > b[s] then  // 情况1：最小对最小
    σ[l] ← s;
    l ← l+1;
    s ← s+1;
  elif a[r] > b[t] then  // 情况2：最大对最大
    σ[r] ← t;
    r ← r-1;
    t ← t-1;
  else  // 情况3：最小对最大
    σ[l] ← t;
    l ← l+1;
    t ← t-1;
σ[l] ← s;  // 处理最后一个元素
return σ;
```

- 时间复杂度：\(O(n)\)（仅一次线性遍历，无额外嵌套）。

### 2. 霍夫曼编码与霍夫曼树（Huffman Codes and Trees，CLRS 15.3、KT 4.8）

#### 2.1 问题背景

- ASCII 编码的缺陷：固定长度（如 8 位），高频字符（如英语中 "e"）与低频字符（如 "z"）编码长度相同，造成空间浪费；
- 解决方案：**变长前缀无码（Prefix-free Codes）**：任一字符的编码不是其他字符编码的前缀（避免解码歧义），高频字符用短编码，低频字符用长编码，最小化总编码长度。

#### 2.2 核心概念

1. **前缀无码的二叉树表示**：
    
    - 叶子节点：对应字符，编码为 “根→叶子的路径”（0 = 左子树，1 = 右子树）；
    - 编码长度：字符的编码长度 = 其在二叉树中的深度；
    - 总编码成本：\(\sum_{l \in [n]} f(l) \cdot \text{depth}_T(l)\)（\(f(l)\) 为字符 l 的频率，\(\text{depth}_T(l)\) 为深度）。
2. **霍夫曼树定义**：
    
    - 给定 n 个叶子节点（字符）和频率 \(f(l)\)，霍夫曼树是 “总编码成本最小” 的二叉树；
    - 关键性质：
        - 树为**满二叉树**（每个非叶子节点有两个子节点）；
        - 频率单调性：\(f(i) \leq f(j) \Rightarrow \text{depth}_T(i) \geq \text{depth}_T(j)\)（低频节点深度不小于高频节点）；
        - 核心定理（Huffman 1952）：**频率最小的两个字符必为兄弟节点**（贪心构造的核心依据）。

#### 2.3 霍夫曼树的贪心构造算法

##### （1）递归构造

1. 选择频率最小的两个字符 y 和 z，创建 “元字符” \(y\#z\)，频率为 \(f(y) + f(z)\)；
2. 递归在 “元字符 + 其他字符” 的集合上构造霍夫曼树；
3. 将 y 和 z 作为 \(y\#z\) 的左右子节点，完成树的构造。

##### （2）迭代实现（双队列优化，避免重复排序）

- 核心逻辑：用两个队列分别维护 “未合并的叶子节点” 和 “已合并的内部节点”，利用内部节点频率的单调性（递增），快速获取最小频率节点。
- 步骤：
    1. 预处理：将 n 个字符按频率**升序排序**，加入 “叶子队列”；
    2. 初始化 “内部节点队列”（存储合并后的元字符，频率递增）；
    3. 迭代合并：
        
        plaintext
        
        ```plaintext
        for k from n+1 to 2n-1 do  // 内部节点共n-1个（满二叉树性质）
          // 取出两个频率最小的节点（叶子队列和内部队列的队首比较）
          i ← 叶子队列队首与内部队列队首的频率较小者，出队；
          j ← 剩余队列中频率最小的节点，出队；
          // 构建内部节点k
          left(k) ← i;  // 左子节点
          right(k) ← j;  // 右子节点
          f(k) ← f(i) + f(j);  // 合并频率
          enqueue(内部队列, k);  // 内部节点入队（保持递增）
        ```
        
    4. 最终：内部节点队列的最后一个节点（索引 \(2n-1\)）为霍夫曼树的根。

#### 2.4 时间复杂度

- 排序：\(O(n\log n)\)（仅预处理一次，主导时间）；
- 合并：\(O(n)\)（双队列遍历，无嵌套操作）；
- 总时间复杂度：\(O(n\log n)\)（适用于 n 较大的字符集）。

### 3. 贪心算法正确性证明核心方法（Takeaway Points）

1. **达到上界**：证明贪心解的得分 / 成本等于问题的理论极值（如霍夫曼树的最小加权路径长度）；
2. **替换论证**：证明最优解可通过替换操作转化为贪心解，且解的质量不变（如赛马问题的配对替换）；
3. **交换论证**：证明非贪心顺序可通过局部交换优化，最终变为贪心顺序（延续第 7 讲的核心逻辑）。

- 关键前提：**所有贪心算法都必须严格证明正确性**，直观策略可能存在反例（如第 7 讲的硬币找零）。

## 练习题及答案

### 1. 赛马问题实例练习

#### 问题描述

给定排序数组 \(a = [2,5,7,9]\)（\(n=4\)），\(b = [1,3,6,8]\)，找到最优排列 \(\sigma\)，最大化得分 \(\sum_{i=1}^4 \text{sign}(a[\sigma(i)] - b[i])\)。

#### 答案

- 步骤 1：初始化指针 \(l=1, r=4\)（a），\(s=1, t=4\)（b）；
- 步骤 2：\(a[l]=2 > b[s]=1\)（情况 1），配对 \(a[1] \leftrightarrow b[1]\)，\(\sigma(1)=1\)，更新 \(l=2, s=2\)；
- 步骤 3：\(a[r]=9 > b[t]=8\)（情况 2），配对 \(a[4] \leftrightarrow b[4]\)，\(\sigma(4)=4\)，更新 \(r=3, t=3\)；
- 步骤 4：\(l=r=3\)，配对 \(a[3] \leftrightarrow b[2]=3\)，\(\sigma(3)=2\)，剩余 \(a[2] \leftrightarrow b[3]=6\)，\(\sigma(2)=3\)；
- 最终排列：\(\sigma = [1,3,2,4]\)；
- 得分计算：
    - \(a[1]-b[1] = 2-1=1\)（+1），\(a[3]-b[2]=7-3=4\)（+1），\(a[2]-b[3]=5-6=-1\)（-1），\(a[4]-b[4]=9-8=1\)（+1）；
    - 总得分：1+1-1+1=2（全局最优，无更高得分可能）。

### 2. 霍夫曼树构造练习

#### 问题描述

给定字符频率表：\(A(27)\)、\(B(31)\)、\(C(40)\)、\(D(41)\)、\(E(55)\)，构造霍夫曼树并生成各字符的霍夫曼编码。

#### 答案

- 步骤 1：排序字符频率（升序）：\(A(27)\)、\(B(31)\)、\(C(40)\)、\(D(41)\)、\(E(55)\)；
- 步骤 2：初始化队列：
    - 叶子队列：\([A(27), B(31), C(40), D(41), E(55)]\)；
    - 内部队列：\([]\)；
- 步骤 3：迭代合并：
    1. 合并 \(A(27)\) 和 \(B(31)\) → 内部节点 \(N1(58)\)，内部队列：\([N1(58)]\)；
    2. 合并 \(C(40)\) 和 \(D(41)\) → 内部节点 \(N2(81)\)，内部队列：\([N1(58), N2(81)]\)；
    3. 合并 \(N1(58)\) 和 \(E(55)\) → 内部节点 \(N3(113)\)，内部队列：\([N2(81), N3(113)]\)；
    4. 合并 \(N2(81)\) 和 \(N3(113)\) → 根节点 \(N4(194)\)；
- 霍夫曼树结构（根→叶子）：
    - \(N4 \to N2 \to C\)（编码：00）；
    - \(N4 \to N2 \to D\)（编码：01）；
    - \(N4 \to N3 \to N1 \to A\)（编码：100）；
    - \(N4 \to N3 \to N1 \to B\)（编码：101）；
    - \(N4 \to N3 \to E\)（编码：11）；
- 验证：总编码成本 = \(27×3 + 31×3 + 40×2 + 41×2 + 55×2 = 81+93+80+82+110=446\)（最小成本）。

### 3. 课前练习：狼 - 羊 - 白菜问题（Wolf-goat-cabbage Puzzle）

#### 问题描述

- 场景：农夫带狼、羊、白菜过河，船仅能容纳农夫和一件物品；
- 约束：狼和羊不能单独共处，羊和白菜不能单独共处；
- 目标：找到安全过河的步骤。

#### 答案

（用 “左岸状态 / 右岸状态” 表示，农夫的位置随船移动，→表示过河，←表示返回）

1. 初始状态：左岸 [农夫，狼，羊，白菜] / 右岸 []；
2. 农夫带羊过河 → 左岸 [狼，白菜] / 右岸 [农夫，羊]；
3. 农夫单独返回 ← 左岸 [农夫，狼，白菜] / 右岸 [羊]；
4. 农夫带狼过河 → 左岸 [白菜] / 右岸 [农夫，狼，羊]；
5. 农夫带羊返回 ← 左岸 [农夫，羊，白菜] / 右岸 [狼]；
6. 农夫带白菜过河 → 左岸 [羊] / 右岸 [农夫，狼，白菜]；
7. 农夫单独返回 ← 左岸 [农夫，羊] / 右岸 [狼，白菜]；
8. 农夫带羊过河 → 左岸 [] / 右岸 [农夫，狼，羊，白菜]（完成）。

### 4. 霍夫曼编码应用练习

#### 问题描述

给定英语句子 “everyday english”，已知字符频率（e:0.12, v:0.02, r:0.06, y:0.02, d:0.04, a:0.08, n:0.07, g:0.03, l:0.04, i:0.07, s:0.06, 空格：0.10），用霍夫曼编码压缩该句子，计算压缩后的编码长度（对比 ASCII 编码）。

#### 答案

- 步骤 1：按频率排序字符（升序）：v (0.02)、y (0.02)、g (0.03)、d (0.04)、l (0.04)、r (0.06)、s (0.06)、n (0.07)、i (0.07)、a (0.08)、空格 (0.10)、e (0.12)；
- 步骤 2：构造霍夫曼树，生成编码（高频字符短编码）：
    - e (0.12)→00，空格 (0.10)→01，a (0.08)→100，n (0.07)→101，i (0.07)→110，r (0.06)→1110，s (0.06)→1111，d (0.04)→1000，l (0.04)→1001，g (0.03)→1010，v (0.02)→10110，y (0.02)→10111；
- 步骤 3：统计句子字符数（不含标点）：everyday (7) + 空格 (1) + english (7) = 15 个字符；
- 步骤 4：计算压缩后编码长度：
    - 字符统计：e (4)、v (1)、r (1)、y (1)、d (1)、a (1)、n (1)、g (1)、l (1)、i (1)、s (1)、空格 (1)；
    - 总编码长度 = 4×2 + 1×5 + 1×4 + 1×5 + 1×4 + 1×3 + 1×3 + 1×4 + 1×4 + 1×3 + 1×4 + 1×2 = 8+5+4+5+4+3+3+4+4+3+4+2=49 位；
- ASCII 编码对比：每个字符 8 位，15 个字符共 120 位，压缩率约 59%（(120-49)/120≈0.59）。


## 一、Practice: Horse Racing（赛马问题）

### 问题描述

给定两个非递减排序的整数数组 \(a[1..n]\)（\(a[1] \leq a[2] \leq \cdots \leq a[n]\)）和 \(b[1..n]\)（\(b[1] \leq b[2] \leq \cdots \leq b[n]\)），找到排列 \(\sigma\)（\(\{1,2,\cdots,n\}\) 的重排），最大化得分 \(\sum_{i=1}^n \text{sign}(a[\sigma(i)] - b[i])\)。其中符号函数 \(\text{sign}(x)\) 定义为：\(x>0\) 得 1，\(x=0\) 得 0，\(x<0\) 得 - 1。

### 详细答案

#### （1）核心贪心策略（双指针法）

通过 “局部最优配对” 最大化单组得分或最小化失分，分三种情况迭代处理，本质是 “优势最大化、劣势最小化”：

|情况|条件|配对策略|核心逻辑|
|---|---|---|---|
|情况 1|\(a[1] > b[1]\)|\(a[1] \leftrightarrow b[1]\)（最小对最小）|必得分 1，剩余子数组递归处理，总得分不低于其他配对|
|情况 2|\(a[n] > b[n]\)|\(a[n] \leftrightarrow b[n]\)（最大对最大）|必得分 1，剩余子数组递归处理，总得分不低于其他配对|
|情况 3|\(a[1] \leq b[1]\) 且 \(a[n] \leq b[n]\)|\(a[1] \leftrightarrow b[n]\)（最小对最大）|最小化失分（最多失 1 分），剩余子数组递归处理，总失分不高于其他配对|

#### （2）伪代码实现（线性时间 \(O(n)\)）

plaintext

```plaintext
l ← 1, r ← n;  // a数组左右指针
s ← 1, t ← n;  // b数组左右指针
σ ← 空数组;  // 存储排列结果

while l < r do
  if a[l] > b[s] then
    // 情况1：a最小 > b最小，配对
    σ[l] ← s;
    l ← l + 1;
    s ← s + 1;
  elif a[r] > b[t] then
    // 情况2：a最大 > b最大，配对
    σ[r] ← t;
    r ← r - 1;
    t ← t - 1;
  else
    // 情况3：a无优势，最小对b最大，减少失分
    σ[l] ← t;
    l ← l + 1;
    t ← t - 1;

// 处理最后一个元素
σ[l] ← s;
return σ;
```

#### （3）正确性证明（替换论证）

- 情况 1：假设不配对 \(a[1]\) 和 \(b[1]\)，而配对 \(a[1]\) 和 \(b[j]\)（\(j>1\)）、\(a[i]\) 和 \(b[1]\)（\(i>1\)）。由于 \(a[1] > b[1]\)，原配对得分 1+sign (\(a[i]-b[j]\))，新配对得分 sign (\(a[1]-b[j]\))+sign(\(a[i]-b[1]\))。因 \(b[j] \geq b[1]\)，sign(\(a[1]-b[j]\)) ≤ 1，sign(\(a[i]-b[1]\)) ≥ sign(\(a[i]-b[j]\))，总得分不变或降低，故原配对最优。
- 情况 2、3 同理，可通过替换论证证明贪心选择不劣于任何其他选择，最终全局最优。

#### （4）示例计算

输入：\(a = [2,5,7,9]\)，\(b = [1,3,6,8]\)

1. 初始：\(l=1,a[l]=2 > b[s]=1\)（情况 1），\(\sigma[1]=1\)，\(l=2,s=2\)；
2. 后续：\(r=4,a[r]=9 > b[t]=8\)（情况 2），\(\sigma[4]=4\)，\(r=3,t=3\)；
3. 最终：\(l=r=3\)，\(\sigma[3]=2\)，\(\sigma[2]=3\)；
4. 排列 \(\sigma = [1,3,2,4]\)，得分：(2-1)+(5-6)+(7-3)+(9-8)=1-1+4+1=5（全局最优）。

## 二、Practice: Huffman Tree Construction & Coding（霍夫曼树构造与编码）

### 问题描述

1. 给定 n 个字符及其频率（如文档示例：字符 1-13，频率 27、31、40、41、55、61、65、71、73、76、80、93、125），构造霍夫曼树（加权路径长度最小的前缀无码树）；
2. 基于构造的霍夫曼树，生成每个字符的霍夫曼编码；
3. 给定霍夫曼编码字符串，解码为原字符序列；
4. 计算编码的压缩率（对比 ASCII 固定长度编码）。

### 详细答案

#### （1）核心贪心思路

霍夫曼树的核心性质：**频率最小的两个字符必为兄弟节点**。通过 “迭代合并最小频率节点” 构造树，确保加权路径长度最小（\(\sum f(l) \cdot depth(l)\)）。

#### （2）霍夫曼树构造步骤（双队列迭代实现）

1. **预处理：排序与初始化队列**
    - 按字符频率升序排序，将字符加入 “叶子队列”（Leaf Queue）；
    - 初始化 “内部节点队列”（Internal Queue），存储合并后的元字符（内部节点），频率为子节点频率之和。
2. **迭代合并（生成内部节点）**
    
    plaintext
    
    ```plaintext
    // 输入：排序后的叶子节点列表leaves（含频率f）
    n ← 叶子节点数;
    leaf_queue ← leaves;  // 按频率升序
    internal_queue ← 空队列;
    root ← null;
    
    for k from n+1 to 2n-1 do
      // 取出两个频率最小的节点（叶子队列/内部队列队首比较）
      if leaf_queue非空 and (internal_queue空 or leaf_queue[0].f ≤ internal_queue[0].f) then
        i ← leaf_queue.pop(0);
      else
        i ← internal_queue.pop(0);
      
      if leaf_queue非空 and (internal_queue空 or leaf_queue[0].f ≤ internal_queue[0].f) then
        j ← leaf_queue.pop(0);
      else
        j ← internal_queue.pop(0);
      
      // 构造内部节点k
      create node k with left=i, right=j, f=k.f + j.f;
      internal_queue.append(k);
      root ← k;  // 最后一个节点为根
    
    return root;
    ```
    
3. **关键性质**：内部节点频率单调递增（\(f(k)\) 在 \(n+1\) 到 \(2n-1\) 上递增），确保每次取最小频率节点正确。

#### （3）霍夫曼编码生成（根到叶子路径）

- 规则：左子树路径记为 “0”，右子树路径记为 “1”，字符的编码为根到该叶子的路径字符串。
- 实现：递归或迭代遍历霍夫曼树，记录每个叶子节点的路径：
    
    plaintext
    
    ```plaintext
    code ← 空字典;  // key:字符，value:编码
    function traverse(node, path):
      if node是叶子节点:
        code[node.char] = path;
        return;
      traverse(node.left, path + "0");
      traverse(node.right, path + "1");
    
    traverse(root, "");
    return code;
    ```
    

#### （4）霍夫曼解码（编码字符串→原字符）

- 规则：从根节点出发，按编码位遍历树，遇到叶子节点输出字符，重置指针回根，继续处理剩余编码。
- 实现：
    
    plaintext
    
    ```plaintext
    function decode(encoded_str, root):
      current ← root;
      result ← "";
      for bit in encoded_str:
        if bit == "0":
          current ← current.left;
        else:
          current ← current.right;
        if current是叶子节点:
          result += current.char;
          current ← root;  // 重置
      return result;
    ```
    

#### （5）示例（文档演示案例）

- 叶子节点（字符 - 频率）：1 (27)、2 (31)、3 (40)、4 (41)、5 (55)、6 (61)、7 (65)、8 (71)、9 (73)、10 (76)、11 (80)、12 (93)、13 (125)
- 构造过程关键步骤：
    1. 合并 1 (27) 和 2 (31)→内部节点 14 (58)；
    2. 合并 3 (40) 和 4 (41)→内部节点 15 (81)；
    3. 合并 14 (58) 和 5 (55)→内部节点 16 (113)；
    4. 合并 6 (61) 和 7 (65)→内部节点 17 (126)；
    5. 依次合并剩余节点，最终根节点 25 (838)；
- 编码示例（部分）：
    - 字符 1 (27)：100（路径：根→14→1→左左）；
    - 字符 2 (31)：101（根→14→2→左右）；
    - 字符 13 (125)：111（根→24→13→右右）；

#### （6）时间复杂度

- 排序：\(O(n\log n)\)；
- 树构造：\(O(n)\)（双队列遍历，无嵌套）；
- 编码 / 解码：\(O(n)\)（遍历树 / 编码串）；
- 总复杂度：\(O(n\log n)\)。

#### （7）压缩率计算（对比 ASCII）

- ASCII 编码：每个字符固定 8 位；
- 霍夫曼编码：字符编码长度 = 树中深度，总编码长度 =\(\sum f(l) \cdot depth(l)\)；
- 压缩率 = (1 - 霍夫曼总编码长度 / ASCII 总编码长度) × 100%；
- 示例：文档字符总频率 = 838，ASCII 总长度 = 838×8=6704 位；霍夫曼总长度 = 838（加权路径长度），压缩率 =(1-838/6704)×100%≈87.5%。

## 三、Pre-lecture Exercise: Wolf-goat-cabbage Puzzle（狼 - 羊 - 白菜问题）

### 问题描述

农夫需带狼、羊、白菜过河，船仅能容纳农夫和一件物品。约束：狼和羊不能单独共处，羊和白菜不能单独共处。目标：找到安全过河的所有步骤。

### 详细答案

#### （1）问题建模（状态表示）

- 状态定义：用二元组 \((L, R)\) 表示两岸物品分布，L 为左岸物品集合，R 为右岸物品集合；
- 初始状态：\(L=\{农夫,狼,羊,白菜\}\)，\(R=\emptyset\)；
- 目标状态：\(L=\emptyset\)，\(R=\{农夫,狼,羊,白菜\}\)；
- 合法转移：每次农夫带一件物品（或单独）过河，转移后两岸无禁忌组合（狼 & 羊、羊 & 白菜单独共处）。

#### （2）详细过河步骤（共 7 步）

|步骤|左岸状态|右岸状态|农夫操作|
|---|---|---|---|
|1|狼、白菜|农夫、羊|农夫带羊过河|
|2|农夫、狼、白菜|羊|农夫单独返回|
|3|白菜|农夫、狼、羊|农夫带狼过河|
|4|农夫、羊、白菜|狼|农夫带羊返回|
|5|羊|农夫、狼、白菜|农夫带白菜过河|
|6|农夫、羊|狼、白菜|农夫单独返回|
|7|∅|农夫、狼、羊、白菜|农夫带羊过河|

#### （3）核心贪心思路

- 关键约束：羊是唯一与两种物品冲突的角色，优先处理羊的转移，避免单独共处；
- 避免无效循环：每次转移后不回到之前的状态（如带羊过河后不立即带回，除非必要）。

#### （4）验证合法性

- 步骤 1 后：左岸狼 & 白菜（无冲突），右岸农夫 & 羊（无冲突）；
- 步骤 3 后：左岸白菜（无冲突），右岸农夫 & 狼 & 羊（农夫在场，无冲突）；
- 步骤 5 后：左岸羊（无冲突），右岸农夫 & 狼 & 白菜（无冲突）；
- 所有步骤均满足约束，最终达成目标。

## 四、Practice: Huffman Coding Application（霍夫曼编码应用 —— 文本压缩）

### 问题描述

给定英语句子 “everyday english”，已知字符频率（e:0.12, v:0.02, r:0.06, y:0.02, d:0.04, a:0.08, n:0.07, g:0.03, l:0.04, i:0.07, s:0.06, 空格：0.10），用霍夫曼编码压缩该句子，计算压缩率。

### 详细答案

#### （1）步骤 1：构造霍夫曼树

1. 频率排序（升序）：v (0.02)、y (0.02)、g (0.03)、d (0.04)、l (0.04)、r (0.06)、s (0.06)、n (0.07)、i (0.07)、a (0.08)、空格 (0.10)、e (0.12)；
2. 合并最小频率节点：
    - 合并 v (0.02) 和 y (0.02)→元节点 (0.04)；
    - 合并元节点 (0.04) 和 g (0.03)→元节点 (0.07)；
    - 合并 d (0.04) 和 l (0.04)→元节点 (0.08)；
    - 依次合并剩余节点，最终生成霍夫曼树；

#### （2）步骤 2：生成霍夫曼编码

|字符|频率|编码（根→叶子路径）|编码长度|
|---|---|---|---|
|e|0.12|00|2|
|空格|0.10|01|2|
|a|0.08|100|3|
|n|0.07|101|3|
|i|0.07|110|3|
|r|0.06|1110|4|
|s|0.06|1111|4|
|d|0.04|1000|4|
|l|0.04|1001|4|
|g|0.03|1010|4|
|v|0.02|10110|5|
|y|0.02|10111|5|

#### （3）步骤 3：压缩句子 “everyday english”

- 句子字符分解（含空格）：e、v、e、r、y、d、a、y、 、e、n、g、l、i、s、h；
- 编码序列：00 10110 00 1110 10111 1000 100 10111 01 00 101 1010 1001 110 1111 1001（简化拼接）；
- 总编码长度：2+5+2+4+5+4+3+5+2+2+3+4+4+3+4+4=55 位；

#### （4）步骤 4：计算压缩率

- ASCII 编码总长度：16 个字符 ×8 位 = 128 位；
- 压缩率 =(1 - 55/128)×100%≈57.03%；

#### （5）结论

霍夫曼编码通过 “高频短码、低频长码” 显著降低编码长度，压缩效果明显，符合贪心优化思想。