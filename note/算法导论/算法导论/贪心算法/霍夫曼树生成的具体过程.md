假设初始给你的 字母数列排好序是这样的
![Pasted image 20251124191810](霍夫曼树生成的具体过程/Pasted%20image%2020251124191810.png)

既然都说生成树了，那么我们还要预先处理一个节点的数据结构，用这个数据结构保存现在和未来生成的字母
我们拿出前两个字母，合成元字母，对应下来，就是节点14，其频率是27 + 31 = 58
我们将节点1 2 踢出队列1，然后将新生成的节点（前面被踢出的两个节点作为其子节点，未来的新建节点操作都有这一步）加入队列2
那么两个节点的情况和树对应的情况如下
![Pasted image 20251124191859](霍夫曼树生成的具体过程/Pasted%20image%2020251124191859.png)
此时，由于两个队列都是从小到大的，频率最小的两个节点一定在leaf 和 internal两个队列的前两个节点——共四个节点中产生，我们只要比较这四个节点得到的结果，就是全局频率最小的两个节点
根据当前情况，我们移除第一个队列的34，往第二个队列添加节点15
![Pasted image 20251124192654](霍夫曼树生成的具体过程/Pasted%20image%2020251124192654.png)

按照上面的思路，此时最小的两个节点为；leaf队列中的节点5和internal队列中的节点14
那么我们将这两个节点分别从各自的队列中移除，同时在队列2添加节点16 其频率为 58+55 = 113
（别担心，节点14并没有消失，而是在节点16中）
![Pasted image 20251124192933](霍夫曼树生成的具体过程/Pasted%20image%2020251124192933.png)


接下来，按照相同的规则不断递归求得新的节点
根据前面的思路，我们知道，在给整个树生成后，n个字母会生成共2n-1 个节点（原始的字母加上运算过程中新增的元字母）
当新的节点的序号为25（即2 * 13 - 1）时，25就是整个树的根节点
![Pasted image 20251124193032](霍夫曼树生成的具体过程/Pasted%20image%2020251124193032.png)

时间复杂度
排序：O（nlogn）
线性遍历生成树：O（n）
所以是O（nlogn）
