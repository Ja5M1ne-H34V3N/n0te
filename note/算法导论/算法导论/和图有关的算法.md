[图这个数据据结构不多说了 在这里](数据结构/数据结构/图.md)

# 有向无环图的拓扑排序
对于下面一种图：其边是有向的边，而且这个图不成环，比如

![Pasted image 20251126110906](和图有关的算法/Pasted%20image%2020251126110906.png)
对于这种图，我们定义两种特殊的节点：
- 原点：没有指向其的边，所有和它相连的边都是指向别的节点的
- 汇点：没有从自己出发的边，所有和自己相连的边都是指向自己的
我们就可以将其按照箭头指向的顺序来排成一条线的序，就像这样

![Pasted image 20251126111027](和图有关的算法/Pasted%20image%2020251126111027.png)

## 策略——Kahn拓扑排序法

对于下面的一个图：
![Pasted image 20251126111430](和图有关的算法/Pasted%20image%2020251126111430.png)
我们先找到一个原点，那么这个原点就是排序后的第一个点，我们将其移除这个群（以及和其相连的边），将其加入结果列表中

![Pasted image 20251126111528](和图有关的算法/Pasted%20image%2020251126111528.png)
接下来，我们在这个删减过后的图里，继续寻找原点（包括删掉边后新出现的原点）
我们重复上述操作，删掉这个点并加入结果集合
![Pasted image 20251126111644](和图有关的算法/Pasted%20image%2020251126111644.png)

重复这个操作，最后就得到结果了，然后根据每个点的边的信息在排序的基础上增加指向边就好了
![Pasted image 20251126111711](和图有关的算法/Pasted%20image%2020251126111711.png)

### 算法
我们在原本节点数组的基础上，再维护两个数组
其中一个数组A保存已经删除出来的节点
另一个数组B保存当前阶段的原节点

首先，我们遍历每个节点，计算器入度和出度，如果遇到了入度为0的节点，就将其加入数组B
接着，我们在数组B中找到一个源节点执行删除操作，将删除的边对应的其他节点的入/出度 - 1

## 练习 ：无环竞赛图
竞赛图，一种图，任意两个节点之间有且仅有一个边相连，这个边的方向可以表示谁赢过了谁

在图论中，一个 **锦标赛图** 是一个 **有向图**，其中：
- 每一对不同的节点 v_i和 v_j​ 之间都有一条有向边，表示两者之间的比赛结果。即节点 v_i​ 和 v_j之间的边表示 v_i 赢了 v_j​ 或 v_j​ 赢了 v_i​。
**锦标赛图的特性：**
- 锦标赛图的特点是 **每两个节点之间都有一条有向边**，但不一定形成环（这就是无环的意思）。
- 如果存在一个环，那么图就不再是无环的，违反了无环的定义。因此，**无环竞赛图**要求图中的所有节点之间的有向边并不形成任何回路。

也就是说 最开始，这个竞赛图是没有任何边的，接下来所有节点都会两两进行比赛，保证都会分出胜负，而胜者产生边指向输者，接下来，为了找到比赛后这些点的排名，我们可以对这个图采用拓扑排序
（需要对比赛设定一定规则 才能实现无环竞赛图）

## 练习：寿命一致性
![Pasted image 20251221140124](和图有关的算法/Pasted%20image%2020251221140124.png)
我们知道，对于相同的两个人来说，这两个事实不能同时发生
那么，我们可以这样构造图：对于一个人，我们分出两个点：出生时间点和死亡时间点，而对于时间前后关系，我们用有向边表示
那么对于这两种情况：
情况一：i出生-》i死亡-》j出生-》j死亡
情况二：i出生-》j出生-》i死亡-》j死亡（出生，死亡的顺序可以互换，但两个出生必须在两个死亡后面）
在按这个规则构建图后，我们对图进行拓扑排序，如果能正常输出结果，则成立，如果不能，即中途出现了没有出度为0的点的情况，则不成立
## 练习：有向无环图的割点
题目背景：
设 $G = (V, E)$ 是一个有向无环图 (DAG)，它具有唯一的源点 $s$（入度为 0 的点）和唯一的汇点 $t$（出度为 0 的点）。
割点定义：
对于节点 $v \in V \setminus \{s, t\}$（即除了源点和汇点以外的点），如果删除节点 $v$ 后会导致从 $s$ 无法到达 $t$，那么 $v$ 就被称为一个割点 (cut vertex)。
任务：
请描述一个线性时间复杂度的算法，用于找出图 $G$ 中的所有割点。

我们对这个图进行拓扑排序
得到排序结果后，我们从正反两个方向遍历排序结果
正向遍历；对于遍历到的每个节点v，统计从起点到达自己的路径数i，计算公式为：所有和自己相邻的，指向自己的节点的i（对于原点来说，其i为1）
按同样的方法反向遍历：得到从当前节点到终点有几条路径
计算完成后再遍历这些点，判断任意一个点v，其到达自己的路径数 * 自己到终点的路径数是否等于正向遍历得到的，到达终点的路径数，如果相等则是割点

## 练习：标号树的 Prüfer 序列
这是一种将带标号的树用一个唯一的整数序列表示的方法。
Prüfer 序列可以将一个带标号 𝑛! 个结点的树用 [1,𝑛] 中的 𝑛 −2![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "n-2") 个整数表示。你也可以把它理解为完全图的生成树与数列之间的双射。常用组合计数问题中。

假设我们拥有一个带标号的树
![Pasted image 20251221154405](和图有关的算法/Pasted%20image%2020251221154405.png)
我们将采用下面的思路 将这个树变成一个数组（编码）
每次选择一个编号最小的叶节点vi将其删除，并加入一个序列，这个序列记录每个删掉的点和其连接的那个父节点pi
重复这个过程，直到树只剩下两个节点，我们最后就得到了：
![Pasted image 20251221154605](Pasted%20image%2020251221154605.png)

而解码的过程，是将数组变成树的过程
我们的任务是实现这个构造的算法：
### 使用优先队列 nlogn时间 编码
[我们要使用优先队列这个数据结构实现](note/数据结构/数据结构/优先级队列与堆.md)
将每个节点都加入优先队列，依次取出出度为0而且编号最小的节点
#### **第一阶段：初始化数据结构**

- **度数数组 `degree`**：统计并存储树中每个节点的度数（连接边的数量）。
    
- **邻接表 `adj`**：存储树的拓扑结构，方便查找邻居。
    
- **最小堆 `heap`**：遍历所有节点，将所有度数为 1 的节点放入最小堆中。
#### **第二阶段：迭代生成序列 (进行 $n-2$ 次)**

1. **取出最小叶子**：从 `heap` 中弹出当前的最小值 $v_i$。
    
2. **记录邻居**：在邻接表 `adj` 中找到 $v_i$ 唯一的邻居 $p_i$，并将其加入到 Prüfer 序列中。
    
3. **更新邻居状态**：
    
    - 将邻居 $p_i$ 的度数减 1（等同于在树中删除了 $v_i$ 及其连边）。
        
    - **判断新叶子**：如果减 1 后 $p_i$ 的度数变为 1，说明 $p_i$ 变成了新的叶节点，此时将其插入 `heap` 中。
#### **第三阶段：结束**

- 当循环执行 $n-2$ 次后，堆中还会剩下两个节点（它们是最后剩下的那条边的两个端点），直接忽略即可
### 使用指针 线性时间 编码
#### **1. 算法步骤**

1. **初始化**：计算所有节点的度数 $degree$。
    
2. **设置指针 `p`**：初始化 `p` 为当前图中最小的叶节点标号。
    
3. **循环迭代 ($n-2$ 次)**：
    
    - 将 `p` 对应的邻居 $neighbor$ 加入 Prüfer 序列。
        
    - 将 $neighbor$ 的度数减 1。
        
    - **关键判断**：
        
        - 如果 $neighbor$ 变成了新叶子（$degree == 1$）且 $neighbor < p$：
            
            为了保持“最小”原则，我们需要立即处理这个 $neighbor$。顺着这个新产生的叶子继续往下删，直到产生的新叶子标号比 p 大。
            
        - 否则（如果 $neighbor > p$ 或没有产生新叶子）：
            
            自增指针 p，找到下一个尚未被删除且度数为 1 的节点。
### 解码
### 1. $O(n \log n)$ 时间复杂度算法

这个算法使用**最小堆（优先队列）**来动态维护“当前可用的最小叶子节点”。
#### **算法步骤：**

1. **统计度数**：计算序列 $P$ 中每个数字出现的次数，每个节点的初始度数为 `出现次数 + 1`。
    
2. **初始化堆**：将所有度数为 $1$ 的节点（即当前的叶子节点）放入最小堆中。
    
3. **迭代连接（遍历序列）**：对于序列中的每一个值 $p_i$：
    
    - 从堆中弹出最小的节点 $v$。
        
    - 添加一条边连接 $(v, p_i)$。
        
    - 将 $p_i$ 的度数减 $1$。
        
    - 如果 $p_i$ 的度数变为 $1$，则将其插入堆中。
        
4. **最后连接**：序列处理完后，堆中还剩下两个度数为 $1$ 的节点，连接它们即可。
    
#### **复杂度分析：**

- 建立堆需要 $O(n \log n)$。
    
- 序列长度为 $n-2$，每次操作包含堆的弹出和可能的压入，总耗时为 $O(n \log n)$。
    

---

### 2. $O(n)$ 时间复杂度算法（线性扫描）

与编码的线性算法类似，通过维护一个**单调递增的指针 `ptr`** 来规避堆的开销。

#### **算法步骤：**

1. **统计度数**：同样先计算出所有节点的初始度数。
    
2. **初始化指针**：设置指针 `ptr` 指向标号最小的度数为 $1$ 的节点。
    
3. **线性扫描序列**：遍历序列中的元素 $p_i$：
    
    - 确定当前的叶子节点为 `leaf = ptr`。
        
    - 连接边 $(leaf, p_i)$。
        
    - 将 $p_i$ 的度数减 $1$。
        
    - **关键优化逻辑**：
        
        - 如果 $p_i$ 减 $1$ 后度数变为 $1$ **且** $p_i < ptr$：
            
            - 说明 $p_i$ 成为了当前全局最小的新叶子。为了保持线性，我们**立即**以 $p_i$ 为下一个处理的叶子，继续这个逻辑（类似于一个局部递归或 `while` 循环）。
                
        - 否则（$p_i > ptr$ 或度数仍 $> 1$）：
            
            - 移动指针 `ptr`，寻找下一个度数为 $1$ 的节点。
                
4. **最后连接**：连接最后剩余的两个度数为 $1$ 的点。
    

#### **复杂度分析：**

- 指针 `ptr` 只会从 $1$ 扫到 $n$，且不回退。
    
- 每个节点和序列中的每个元素都只被访问常数次。
    
- 因此总时间复杂度为严格的 **$O(n)$**。

# BFS

[BFS](note/算法/算法/基于图的算法/广度优先搜索 BFS.md)
## 应用：测试连通性：
我们可以是同BFS测试给出的图中所有点的连通性
我们随机选择图中一个点为起点，利用BFS测试从起点开始，是否所有点都能被到达

强连通性测试
这里指的是，针对有向图，任何两个顶点之间都有互相到达的路径，则成为强连通
- **算法复杂度：** $O(m + n)$ 时间，仅需 2 次 BFS。
- **步骤：**
    1. 从随机选择的节点 $s$ 开始，在原图 $G$ 中运行一次 BFS。
        
    2. 在**反向图** $G^{rev}$（将原图所有边反向）中，再次从节点 $s$ 开始运行一次 BFS。
        
- **判定：** 当且仅当在这两次 BFS 执行中，所有节点都能被 $s$ 访问到时，返回 `true`。


## 应用：测试二分性
二分性：如果一个无向图的节点可以被染成**红色**或**蓝色**，使得每条边的两个端点颜色不同（一红一蓝），则该图是二分图。

我们直接进行BFS搜索，只不过在每次搜索的时候进行颜色的处理：
对于下一个点：
如果未被染色，则染成和自己相反的颜色
如果已被染色，则检查和自己的颜色是否相反，如果相同，则图无二分性

# 应用：油漆桶工具
就是一下直接填满整个区域的那个
也可以使用BFS实现，
**标题：应用：种
- **场景描述**：给定图像中的一个石灰绿（lime green）像素，将其邻接的所有石灰绿区域变为蓝色。
    
- **图论转化**：
    
    - **节点 (Node)**：单个像素。
        
    - **边 (Edge)**：两个相邻的同色（石灰绿）像素。
        
    - **色块 (Blob)**：由同色像素组成的**连通分量**。

## 羊狼白菜过河问题——状态空间搜索
**一位农夫带着一只狼、一只羊和一颗白菜，必须乘船穿过一条河。**
- **船上只能容纳农夫和一件物品。**
- **如果无人看管，狼会吃掉羊，或者羊会吃掉白菜。**
**他们怎样才能在没有任何东西被吃掉的情况下全部过河？**

我们可以用图来表示运行的过程对于每个节点来说，其保存的信息是：（左岸物品，右岸物品）
所以初始状态是：（WVSF，0）（W狼V菜S狼F农夫）
那么，对于这个节点能到达的节点是：农夫带着任意一个和自己在同一条岸上的物品过去 或自己过去
那么，我们就可以用广度优先搜索来解决：
判断下一步能实现的所有情况：
农夫自己过去了：（WVS，F）
农夫带着羊过去了：（WV，FS）
农夫带着狼过去了：（VS，FW）
农夫带着菜过去了：（WS，FV）
同时，我们设立不能的条件：一个岸上仅羊狼 羊菜，筛选当前情况的节点的可达节点加入队列
接着进行BFS，直到到达终点：（0，WVSF）

## 最短奇偶步长路径
假设 $G$ 是一个有向图 (digraph)，具有两个不同的节点 $s$ 和 $t$。在 $G$ 中寻找一条从 $s$ 到 $t$ 且长度为偶数（或奇数）的最短路径（如果存在的话）。

直接BFS就好
对于这个算法来说，DFS下一次迭代会输入当前步数，然后到终点后判断步数是奇偶就好，因为BFS可以实现找到所有可能的路径，所以每找到一个路径，就更新下奇偶的最小值就行



## 进阶：法国国旗路径
- **问题描述**：考虑一个有向图 $G$，其中每条边都被染成了**蓝色**、**白色**或**红色**。
- **定义**：如果在 $G$ 中的一条路径其颜色序列遵循“**蓝、白、红、蓝、白、红...**”循环，则该路径被称为“**法国国旗路径**”。
- **任务目标**：找出 $G$ 中所有可以从给定节点 $s$ 通过法国国旗路径到达的节点。
![Pasted image 20251221184610](和图有关的算法/Pasted%20image%2020251221184610.png)

就是一般的BFS，做到往前走的时候 根据到来的边的颜色判断一下边的颜色就好


## 最短环问题
- 有向图情况：
    设 $G = (V, E)$ 为一个有向图。请找出 $G$ 中的一个最短环。
- 无向图情况：
    设 $G = (V, E)$ 为一个无向图。请找出 $G$ 中的一个最短环。

对于每个顶点来说，以其为原点构建BFS，终点设置为原点（注意，无向图要确定自己不会返回刚来过的点，而导致形成两个点构成的环）


## 统计最短路径的数量
设 $G = (V, E)$ 为一个**无向连通图**，且 $s$ 是 $G$ 中的一个节点。 对于每个顶点 $v \in V$，$f(v)$ 表示 $G$ 中从 $s$ 到 $v$ 的**最短路径**的数量。 请描述一个**线性时间复杂度**（Linear-time）的算法，用于计算所有 $v \in V$ 的 $f(v)$。
那就使用BFS，一直进行迭代扩展，直到所有的点都被找到最小路径？（一般这个计算次数不会超过n（V + E） - 1 次）

## 统计最短路径上的点
设 $G = (V, E)$ 是一个**有向图**，$s$ 和 $t$ 是 $G$ 中的两个节点。 请描述一个**线性时间复杂度**的算法，用于找出所有位于**某条从 $s$ 到 $t$ 的最短路径**上的边和节点。

我们可以直接 进行bfs 但是在移动过程中记住其prev节点，在找到最短路径后回溯吗


更好的方法：
如果你觉得回溯逻辑太复杂，图论中还有一个更常用的“线性时间”标准解法（我在上一次回答中提到的）：
1. **正向 BFS**：从 $s$ 开始，计算所有点 $v$ 到 $s$ 的距离 $d_s(v)$。
2. **反向 BFS**：从 $t$ 开始，在**反向图**（所有边掉头）上计算所有点 $v$ 到 $t$ 的距离 $d_t(v)$。
3. **判定条件**：
    - 对于任何边 $(u, v)$，如果满足：$d_s(u) + 1 + d_t(v) = d_s(t)$，那么这条边**一定**在某条最短路径上。
    - 这个判定的直观理解是：从 $s$ 走到 $u$，经过边 $(u,v)$，再从 $v$ 走到 $t$ 的总长度，刚好等于 $s$ 到 $t$ 的最短距离。
# DFS
[DFS](note/算法/算法/基于图的算法/深度优先搜索 DFS 1fa05a2041d2804dabfbf31a8c76d735.md)


## 联通分量
### 1. 无向图的连通分量 (Undirected Components)

在无向图中，如果两个节点之间存在路径，它们就是连通的。

- **定义**：一个极大连通子图。通俗点说，就是图中几个“抱团”的部分。
    
- **特点**：同一个分量里的任意两点都能互相到达；不同分量之间完全没有边连接。
    
- **寻找方法**：随便找一个点开始做 BFS 或 DFS，一次遍历能抓到的所有点就属于同一个连通分量
### 2. 有向图的强连通分量 (Strongly Connected Components, SCC)

在有向图中，因为边有方向，情况变得复杂一些。

- **定义**：在这个节点群体中，任意两个节点 $u$ 和 $v$ 都能**互相到达**（既能从 $u$ 走到 $v$，也能从 $v$ 走到 $u$）。
    
- **形象理解**：这是一个“闭环”群体。如果你在这个群体里，你可以顺着箭头在里面兜圈子，去到任何一个点并回到原点。
    
- **缩点特性**：如果你把每个强连通分量看作一个整体（一个超级节点），那么这些整体之间形成的新图是**无环**的（即 DAG，有向无环图）
![Pasted image 20251221193645](和图有关的算法/Pasted%20image%2020251221193645.png)
每个颜色对应一个连通分量
### 寻找联通分量
#### 连通分量
对于无向图来说，可以直接使用BFS搜索，因为无向图是双向的，所以只要连接到，那就加入了这个连通分量，所以，直接用bfs求是比较高效的：起点能访问到哪里 哪里就是连通分量的一部分


### 寻找强联通分量
#### 强联通分量
对于有向图来说，双向可达的要求更深刻一些，必须实现双向可达，此时我们可以选择对每个节点每个边使用BFS，但时间复杂度是mn，如果DFS的话 就是M + N
这种方法是Kosaraju-Sharir算法
##### **第一阶段：正向探索（确定“战略地位”）**

在原图 $G$ 上运行一遍完整的 DFS 森林。

1. **记录完成时间**：每当一个节点完成探索（即它的所有邻居都已被访问，准备回溯时），给它标记一个 **`off` 时间戳**。
    
2. **生成逆后序序列**：将节点按照 `off` 时间从大到小排序。
    
    - **直觉理解**：`off` 时间越晚的点，在图的拓扑结构中越接近“源头（Source）”；而 `off` 时间越早的点，越接近“汇点（Sink）”。
        
    - **例子**：在图中，节点 $b$ 的完成时间（16）比 $c$（10）晚，说明在缩点图视角下，包含 $b$ 的分量在包含 $c$ 的分量“上游”。
        
---

##### **第二阶段：反向剥离（锁定强连通成员）**
这是算法最神奇的一步。首先将图中所有的边反向，得到 **$G^{rev}$**。
1. **按序出发**：按照第一阶段得到的**逆后序序列**（从 `off` 时间最大的点开始），在 $G^{rev}$ 中启动 DFS。
2. **隔离分量**：在反向图中，由于边全部反转，原本的“源头”分量变成了“汇点”分量。
    - 这意味着，当你从一个高 `off` 时间的点开始搜时，DFS 的路径被**限制**在它所属的强连通分量内部。
    - 它无法通过边“流向”其他分量，因为通往其他分量的边在原图中是“指向”它的，反向后就变成了“离开”它的，但那些分量在之前的遍历中已经由于顺序关系无法被触达，或者尚未被访问。
3. **输出结果**：每一次 DFS 启动所能触达的所有点，就是一个完整的 **SCC**。


## 练习：核心顶点
给定一个有向图 $G$，如果 $G$ 中的**每一个顶点**都可以从顶点 $v$ 到达，那么顶点 $v$ 就被称为一个**核心顶点 (Core Vertex)**。

思路：我们先使用前面的方法找到所有强连通分量
- **缩点 (Condensation)**：
    - 将图 $G$ 中所有的强连通分量找出来，并将每个 SCC 缩成一个“超级节点”。
        
    - 缩点后得到的图是一个**有向无环图 (DAG)**。
- **寻找源点 (Source Nodes)**
    - 在缩点后的 DAG 中，寻找所有**入度为 0** 的超级节点（即没有任何边指向它们的节点）。
    - 如果一个顶点 $v$ 是核心顶点，那么它必须能够到达图中所有的点。这意味着它所在的超级节点在缩点图中必须能到达所有的超级节点。
- **判定核心顶点**
    - **关键结论**：在 DAG 中，只有当**有且仅有一个**入度为 0 的超级节点时，该超级节点内的点才可能到达所有其他节点。
    - 如果有多个入度为 0 的节点，那么它们之间无法互相到达，也就不存在能到达全图的核心顶点。
    - 因此，算法步骤为：
        1. 找到所有 SCC 并缩点。
        2. 统计缩点图中入度为 0 的超级节点数量。
        3. 如果数量不等于 1，则核心顶点不存在（数量为 0）。
        4. 如果数量等于 1，则从这个唯一的超级节点中的任意一点出发运行一次 DFS/BFS。如果它能遍历所有点，那么该超级节点中的**所有点**都是核心顶点；否则没有核心顶点。


## 练习不相交最短 $s-t$ 路径的极大集合
给定一个有向图 $G$，包含两个不同的顶点 $s$ 和 $t$。请在**线性时间**（Linear time）内完成以下任务：
- 找出 $G$ 中一个**包含性极大**（Inclusion-wise maximal，但不一定是最大 Maximum）的**边不相交**（Edge-disjoint）最短 $s-t$ 路径集合。
- 找出 $G$ 中一个**包含性极大**（但不一定是最大）的**内部节点不相交**（Internally node-disjoint）最短 $s-t$ 路径集合。
- **包含性极大 (Maximal) vs. 最大 (Maximum)**：
    - **极大 (Maximal)**：意味着你无法再向当前的集合中添加任何一条新的最短路径，因为所有剩下的候选路径都至少与已有路径共享了某条边或某个节点。
    - **最大 (Maximum)**：指在所有可能的组合中，路径数量最多的那个集合。
    - **题目要求**：只需要找出一个“加不进去了”的集合即可，这比寻找全局最大值要简单，通常可以使用**贪心算法**结合 **DFS** 解决。
- **不相交 (Disjoint)**：
    - **边不相交**：路径之间可以经过同一个点，但不能经过同一条边。
    - **节点不相交**：路径之间除了起点 $s$ 和终点 $t$ 以外，不能共享任何中间节点。

思路：
- **分层图构建 (Level Graph)**：
    - 首先运行一次 **BFS**，计算从 $s$ 出发到所有点的最短距离 $dist(v)$。
    - 再遍历所有的边，将有向边的起点设为u
    - 保留所有满足 $dist(v) = dist(u) + 1$ 的边 $(u, v)$。这些边构成了“分层图”，任何在该图中的 $s-t$ 路径都必定是原图中的最短路径。（保证留下的所有边都是通往终点的高效边）
- **贪心 DFS 提取**：
    - 在分层图中运行 **DFS**。
    - 每当你找到一条从 $s$ 到 $t$ 的路径，就将其记录下来，并从图中**删除**该路径所经过的边（若是节点不相交，则删除经过的节点）。
    - 重复此过程，直到无法再从 $s$ 到达 $t$。