# 动态规划

指的是将一个大问题分解成多个子问题，逐步解决每个字为，再返回到大问题上，[和前面学到的分治不同](obsidian://open?vault=ExportBlock-dc6c8b8b-ffcf-4f65-a9c2-55dd222bcc0d-Part-1&file=算法导论%2F分治法%20Divide%20and%20conquer%2027c05a2041d28024a526f978e58190a1)，分治得到的子问题时相互独立互不干涉的，但是动态规划的子问题是可以重叠的，即不同的大问题可能来自相同的小问题
而动态规划的核心思想是：既然一个子问题可能构成多个大问题，我们为何不从下到上计算问题，同时将当前小规模的问题的结果保存起来，等到计算更大的规模的问题时，这些结果可以直接拿来用


# 重叠子问题
由下面的几个例子就可以看到，我们在解决我们的终极目标前，会解决多个问题中的小问题，逐渐将问题扩大。
## 前缀最值
以前缀最小值为例：
![Pasted image 20251112093908](动态规划/Pasted%20image%2020251112093908.png)
假如，我们想得到整个数组的最小值，那么我们 不难想到，可以用前缀最小值的思想解决这个问题：先看前2个数的最小值，然后再看前三个数（也就是第三个数和前两个数的最小值比较），直到比较完数组里面的所有数。我们发现，我们并没有直接采用什么方式直接寻找最小值，而是先解决这个数组一部分的最小值问题，在这个问题的答案的基础上逐步扩大得到的

## 矩阵的前缀和
所谓矩阵的前缀和，就是前n行，前m列的元素的和，不难想到，对于一个矩阵的前缀和，我们可以从（1，1）开始算
（1，1）之前没有其他元素了 所以它本身就是前缀和。那么 我们逐渐扩大范围，先思考[1,2]或[2,1]这两个和其直接相连的，那么他们的前缀和就知晓了：（1，1）的前缀和和自己对应的值
实际上，对应这个矩阵上任何一个点对应的前缀和，符合下面的计算公式：
![Pasted image 20251220150537](Pasted%20image%2020251220150537.png)
对于这种问题来说，我们需要先从上到下，找到一个最小最好的问题结构：这个问题结构符合大问题的特征，也是规模最小，在其基础上能够扩展出整个大问题的结构
而具体的实现方式，我们可以通过先计算出第一行 第一列的前缀和，再按正常每行每列的顺序计算所有前缀和
之后，我们再从下到上地一步步扩充规模并计算结果
可以说，分治是将一个大问题分解成多个小问题，解决小问题后，逐步合成为大问题地结果，而动态规划是找到一个和大问题结构相似地小问题，一步步计算结果，“生长”为大问题



# 带前缀划分的子问题

## 带权区间选择
下面是一些工作，其起始时间和结束时间都标注好了，完整完成一个工作的薪水也在上面标注着
已知：我们无法在相同时间进行多个工作，请问，我该怎么挑选工作，让我在这11时间内收入最高
![Pasted image 20251112100722](动态规划/Pasted%20image%2020251112100722.png)
也就是说，尽可能不浪费这些时间，同时选择更划算的工作

我们先将这些工作按照结束的时间排列出来（从上到下看）
![Pasted image 20251112100919](动态规划/Pasted%20image%2020251112100919.png)
我们先计算前2个工作的最划算方案：可知，选择那个4￥的工作是最好的（我们可以将每次生长的结果存入到一个新的数组中便于后续使用）
接下来，我们在当前问题的基础上，添加工作3。那么现在问题有两种情形，我们要比较这两个情形的结果：
- 新加入的一个工作对新问题的结果没有影响，则结果（最好的选择）还是前两个工作的最大值
- 新加入的一个工作对新问题的结果有影响，也就是现在最合适的选择是工作3加上前面何其时间不冲突的工作，我们先找到离工作三最近的时间不冲突的工作a，也就是结束时间小于工作3起始时间的工作，由于我们是按照结束时间小到大排序的，所以其之前的任何工作都不会冲突，所以此时最合适的选择是：工作3 + 工作a机器之前的工作的最好选择（a前缀的子问题的解）
那么 对于3来说，如果没有影响：则加入3之前的子问题的结果是4￥；如果有影响：3前面没有和他时间不冲突的工作了，结果就是工作3自己一个工作，薪水10￥
经过比较，当前问题的最好选择是选择工作3
以此类推，直到加上最后一个工作——工作8，此时计算的结果就是整个大问题的结果

### 时间复杂度：O（nlogn）
按结束时间排序：O（nlogn）
计算每个工作之前和他最近的不冲突工作a：O（nlogn）
计算并填写每个工作及其之前工作的最好选择：O（n）
恢复：O（n）


## 找零问题
给你n种面额的邮票，和一个规定的价值，要求：找到最小的邮票数，让其面额之和等于规定价值
![Pasted image 20251112103823](动态规划/Pasted%20image%2020251112103823.png)

假设给的面额就是1 10 21 34 70 100 350 1225 1500（这只是面值，每个面值的数量不限）
首先我们将这些邮票的面额按从小到大排列出来
此时，我们设置的最小问题是：总面额1该怎么找，这不废话，一个价值1的邮票就够了
所以我们接下来看总价值为2：
在原来问题的基础上，总价值添加了1，但是单单添加一个1就可能让符合要求的组合产生巨大的变化，所以我们采用下面的思路：
- 首先，我们确定这些邮票中的一个的面值s，这个面值只要是小于当前要求的总价值，就都有可能，我们需要对每种可能的面值s作下面的计算
	- 让总价格T减去s，得到了一个更小的面额T - s，根据动态规划，这个更小的面额T -s所需的最少邮票数已经计算出来了，假设是a，那么如果确定了一个s面额的邮票的基础上，得到的最小有票数就是s + 1
- 计算出所有可能s对应的最小结果后，比较这些结果的最小值，就是当前规模问题的答案

所以对于2来说，小于2的面值只有1，2 - 1 = 1，对于总价值1来说，前面已经计算出来了，只用1个邮票就够了，所以总价值2需要的最小邮票数是 1 + 1 = 2

### 时间复杂度
假设总价值是T，共n种邮票，则时间复杂度是O（nT）

# 按一对前缀划分的子问题

比如前面提到的矩阵前缀和

## 字符串相似度
下面两个字符串有多相似？
ocurrance
occurrence



# 按区间划分的子问题
## 最优二叉搜索树
给定一个从一开始，连续的整数数组[1，2，……，n]，数组里每个数代表了自己在BST中对应的节点的搜索频率是,构造一个合适的BST，要求每个节点的搜索代价之和最小
搜索代价的定义：对于任意一个节点，其到根节点的距离是a，则代价 = （a + 1）* f[n]

我们可以这样分解这个问题：一个树的总代价：总的搜索频率 + 左子树的代价 + 右子树的代价
所以，我们假设数r是整个树的根节点，那么其左子树包含的节点有[1，……r - 1]，右子树包含的节点有[r + 1……n]，接下来，我们再运算各个子树的代价，这是一个递归的过程
其公式是这样的：
![Pasted image 20251113220010](动态规划/Pasted%20image%2020251113220010.png)

所以，按理说，我们只要比较所有数作为根节点时，整个数的代价之和就好了
如果我们确定一个点是根节点，计算代价之和，那递归分治肯定是最好的选择了，但是如果计算出每个节点作为根节点时，树的代价之和，我们就有一个更加经济的思路
我们看到，如果要计算出所有节点作为根节点下的代价之和，就要知道：所有节点作为子树时，当前代价之和，也就是公式中的c[i,r - 1]和c[r,j]，如果使用一般的递归算法来算，我们就发现了一个问题：很可能，一个节点作为根节点的父节点时，其子树的代价可能用到多次，而每次递归计算都要重新计算一次
所以我们不妨使用动态规划，让问题从小到大，同时一路保存当前问题规模下的计算结果。那我们找这个问题的最小值：当子树只有一个叶节点时，其代价就是最小规模的
但是我们通常不这么做，我们从区间为0开始计算，因为如果节点为1还要根据公式再分，就会得到公式中i = j的情况，所以我们通常象征性的计算一下0个节点构成树的情况，其实记一个0就行了
![Pasted image 20251113223357](贪心算法/Pasted%20image%2020251113223357.png)
*当前保存的结果集：0个节点：0*
那么接下来，我们扩展这个问题，当树的节点数量是1时，其代价是多少？
本着任何情况下的节数量为1的树都会在未来被用到，我们一定要把情况计算得完整：对于节点数量规模为1的树来说，那无非就节点为1，2，3，4，5，6……这些情况了，那么我们计算其规模，由于其左右子树都是0，所以直接计算其频率就行了
![Pasted image 20251113223404](贪心算法/Pasted%20image%2020251113223404.png)
*当前保存的结果：0个节点：0*
			   *1个节点：1，2，3，4……*
接下来，我们再扩大规模，当树的节点数量为2时，每种情况的代价是多少？
我们先解决第一个问题：这个节点数量为2的树，拿哪两个树作为节点？
	首先，对于BST的性质，其直接相连的节点一定是在排列好的数组里是相邻的，对于本题目就是12，34，56，67这样的，所以，我们还是让i从1开始往后遍历，i 和 i-1 作为构成树的两个节点，这就可以了，但是，因为i = 1时，i - 1 = 0，没有这种组合，我们就把这种组合的结果视为0
	接下来，我们来思考第二个问题：节点确定了，但是，这些节点里，谁来做根节点呢？当然是让每个节点都来做一次根节点啦，毕竟我们不能拉下每一个情况，这时，我们已6，7为例（也就是说，取值范围为[6,7]），如果6作为根节点，则总代价的计算公式为：13 + c[6,6] + c[6，7] = 13 + 0 + ==7== = 20 而如果让7作为根节点，则结果为：13 + c[6,7] + c[7,7] = 13 + ==6== + 0 = 19，此时不难发现，标高亮的6 和 7的代价的计算其实是长度为1的子树的代价的计算，而计算机结果我们已经保存下来了，直接用就行
而对于树的节点数量是3，4，5……n，计算思路都和2一样，在逻辑上就是按下面的思路解决的
这两个问题放在一起，在逻辑上解决是这样的：
![Pasted image 20251113224553](贪心算法/Pasted%20image%2020251113224553.png)

当前保存的结果：   0个节点：0
				1个节点：1，2，3……
				2个节点：…………
				3个节点：…………
				…………
此时，回到我们最初的诉求：计算所有节点作为当前树的根节点的情况，此时所有子问题的计算结果都已经计算出来保存上了，我们在需要的时候直接调用就好

下面的问题都是同理：
### 按区间划分的子问题

- 矩阵链乘法（CLRS 第 14.2 节）
- 凸多边形的最短三角剖分
- RNA 二级结构（KT 第 6.5 节）
- 最长平衡子序列
    
    （示例：`([()][()])(()())()`）
- 最长回文子序列（习题 14-2）
    
    （示例序列：`3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,7`）
- 上下文无关文法的 CKY 解析算法