# 算法设计和分析基础

算法是指令的有限序列，为了解决一类特定问题而进行计算，其指标如下

输入规模，输入的二进制编码的长度

时间复杂度：基本操作（加减乘除 比较）的次数

空间复杂度：运行代码使用的空间大小

正确性：是否能解决问题

### **展示你的算法的流程**

1：将问题转化成算法表示的问题

2：对算法进行简单的描述，每个变量的含义必须从上下文中清晰可知，或者被明确指定。但不要照搬我们已经见过的算法

3：简要证明算法的正确性：完整的正确性证明会过于冗长、繁琐且缺乏启发性。除非我们明确说明，否则通常只需要对证明中的主要步骤进行高层次的概述。

4：分析算法的运行时间（默认是最坏情况）。除非我们特别要求，否则不必分析空间复杂度

# 暴力法

![image.png](算法设计和分析基础/image.png)

在一片区域里有这么些点，该怎么找到距离最近的点？

用暴力破解的方法，直接两个点两个点比较就好

此时的时间复杂度是O(n方)

## 矩阵乘法

对于矩阵来说

![image.png](算法设计和分析基础/image%201.png)

矩阵的某一行和当前矩阵的某一列的积，就是这个矩阵当前行当前列的数据。

这个时候，时间复杂度是n的三次方

## 亚线性查询

通常，问题的输入是结构化的话，我们就可以用亚线性查询的思路在结构化中找到规律，筛选掉一定不是查询目标的选项

这个筛选掉的选项的比例通常是对数级别的，也就是说这种时间复杂度通常是logn

### 二叉搜索

在数据结构说过了，自己看吧

![image.png](算法设计和分析基础/image%202.png)

**给你九个硬币和一个天平，只称两次找到其中一个较轻的假硬币**

第一次称重：把 9 枚硬币平均分成 3 组，每组 3 枚。将其中两组放在天平两端。
如果天平平衡，说明假币在没称的那一组；
如果天平不平衡，假币在较轻的那一组。
第二次称重：从有假币的那一组中，任选两枚放在天平两端。
如果天平平衡，没称的那一枚就是假币；
如果天平不平衡，较轻的那一枚就是假币。

**如果一个鸡蛋从最低F层掉落就会碎掉，现有一个n（大于F）的楼和一堆鸡蛋，怎样用最少的鸡蛋测出F？**

标准的二分查找，不说了

在杨氏矩阵中寻找数据

**如图是一个杨氏矩阵，他的特征是每一行的数据从左到右，每一列的数据从上到下都是从小到大排列的**

![image.png](算法设计和分析基础/image%203.png)

**现在我们要在上面的矩阵搜索，有没有数字7**

我们直接和当前得到矩阵的右上角开始比较，如果这个数字大于目标数字，我们就比较这个数字左边的数字，如果小于目标数字，就比较这个数字下面的数字，如果不是当前数字，就一直重复上述过程

## 线性扫描

前缀最小值，最大值，以及和

前缀最大最小值：给定一个数组，规定在第n个数之前的所有数的最小值称为前缀最小值，最大值和和同理

所以对于这个数列来说，n个数就意味着前缀最大最小值都有n个，我们该怎么求这n个呢？

我们从一个数开始，那么这个数就是当前前缀的最大值和最小值，接着加入第二个数，如果这个数小于前面所有数的前缀最小值，那么这个数就是当前这些数的前缀最小值，最大值同理，以此类推。

其实求整个数组最值得过程就求出了每一个前缀最值

## 双指针——处理两组数据的排列

假设给你两个数组

[1,3,5,7,8,12]

[2,3,4,5,6,7,8]

可见，这两个数组都是从小到大排序的，接下来请将这两个数组合并成同一个数组，仍然是从小到大排序

处理这种分析两组数据的问题，我们可以用双指针法

我们在这两个数组里都维护一个指针，从最小的数开始，分别指向的是1，2.我们比较这两个数，其中较小的那个数就是所有数里面最小的（这个问题里是第一个数组的1），将较小的数添加到一个新的数组里。接下来，将第一个数组的指针右移，再比较两个指针指向的数谁大谁小。以此类推，直到所有数都被放到新的数组里

```python
a = [1,3,5,7,8,12]

b = [2,3,4,5,6,7,8]

c = []
while True:
    if a != [] and b != [] :
        if a[0] <= b[0]:
            c.append(a.pop(0))
        else:
            c.append(b.pop(0)) 
    else:
        c += a + b   
        break
print(c)   
```