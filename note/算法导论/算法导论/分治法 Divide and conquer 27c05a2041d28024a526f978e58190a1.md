# 分治法 Divide and conquer

所有者: H34V3N

我们将一整个问题分解成许多个子问题//现在思路上分解

然后利用递归操作解决每个子问题//在算法上实现分解

将子问题的解合并成所有解//将小问题合并

# 归并排序和递归问题 Merge Sort and Recurrence

回到熟悉的问题，将下面的数组排序：

[1，2，5，6，9，10，6，7，8，4，3]

就像之前提到的，我们可以将其对半分开，给各自的排好序，然后再排序成整体

[1,2,5,6,9,10] → [1,2,5,6,9,10]

[6,7,8,4,3] → [3,4,6,7,8]

再合并就是了，此时的时间复杂度是O（n）、

如果是再合并，直到合并到两个一组，那么要合并logn次，也就是说，时间复杂度是o（nlogn）
我们可以将这个过程以二叉树的形式展开

![image.png](分治法%20Divide%20and%20conquer/image.png)

## 推导

### 推导时间复杂度

对于分到某一阶段的问题来说，其时间复杂度就是：

![image.png](分治法%20Divide%20and%20conquer/image%201.png)

如果当前分组被分成了只有一个元素，好家伙，那没必要排序了，直接就是0

如果当前分组有多个元素，则可以将其再分成两组，根据数学归纳法，分出来的两组所用时间应该也是T（n），所以当前分组排序的时间由下面三部分组成：

分开的两组排序使用的时间 T（2/n）+ 将这两组合并起来消耗的时间n

## 延伸：如果再分治过程中子问题增多对时间复杂度的影响

此时，分成了三个子问题，但子问题的元素有重合，所以每个子命题都是1/2

![image.png](分治法%20Divide%20and%20conquer/image%202.png)

根据原来的计算思路，只是变成了3倍的T（n/2）

![image.png](分治法%20Divide%20and%20conquer/image%203.png)

这是根据主定理算出的时间复杂度

## 平衡子问题的主定理master theorem

### 平衡子问题 balanced subproblems

对于分治或其他递归算法来说，如果子问题规模大致相等，就称其为平衡子问题

如果差距比较大，就成为不平衡子问题

对于一种递归的算法来说，如果其某一层自命题的时间计算方式是：

![image.png](分治法%20Divide%20and%20conquer/image%204.png)

a是某次一个节点递归分出子问题的数量

1/b 是子问题对于整个命题规模的占比

O（n ** d）是合并子问题使用的时间复杂度

那么根据a和b的关系得出下面三个公式算出时间复杂度

![image.png](分治法%20Divide%20and%20conquer/image%205.png)

### 不平衡子问题Unbalanced subproblems

还是套公式，只是每个子问题规模不一样，导致时间不一样

![image.png](分治法%20Divide%20and%20conquer/image%206.png)

## 练习

[计算逆序对](分治法%20Divide%20and%20conquer/计算逆序对%2027c05a2041d280bdbf1cfba1d0c5de25.md)

# 最近点对问题

给你平面上的n个点，找到一对点，这两点的距离最小

利用分治算法解决：

![image.png](分治法%20Divide%20and%20conquer/image%207.png)

对于一个父问题，我们将点分成左右两份，两份的数量相等或相近

其中，对每个子范围的点里，搜索距离最近的两个点

接着找两个子范围里各自一个点（也就是跨分割线的点），让这两个点的距离最小

接着，我们在这三个点对里找到距离最小的，就是这个父问题的最近点

具体的分法呢，是将这些点按横坐标的一定顺序排好队，再根上一种题型那样分就行了

<aside>
💡

我们在寻找跨分割线的最近点时，采用下面的寻找方式

我们将两个子范围里各自的最小距离进行比较 得到更小的那个距离记为a，取分割线两侧各长度a的距离，将范围内的点按纵坐标排序，对每个点，和其后最多七个按y排序的点比较距离就行

但是为什么这个数字是 7 呢？

![image.png](分治法%20Divide%20and%20conquer/image%208.png)

我们将刚才选中的区域按1/2 * a的边长分成这样的小方格，已知当前找到的最短距离是a，也就是说，左右区域每个点的距离不会小于a，对于这个对角线二分之根号二a（比a小）的正方形，不会有任意两个点在一个格子里，所以需要寻找的最极限的情况，就是按照y坐标排序 在当前点下方的这七个格子里

【图片】

┌─────┬─────┐
│  1            │  2           │  
├─────┼─────┤
│        3      │    4        │
├─────┼─────┤
│         5     │   6         │   
├─────┼─────┤
│      7       │               │
└─────┴─────┘

所以，接着往下比较的范围不会大于7，着就将这个界限控制在了线性级

</aside>

# 快速矩阵乘法

利用分治算法计算矩阵的乘法

对于一个这样的矩阵乘法：

![image.png](分治法%20Divide%20and%20conquer/image%209.png)

通过对线性代数的学习 我们知道，大的矩阵的乘法，可以分成结构相同的四个小矩阵相乘，再将结果矩阵放到对应的位置，这样我们就得到了分治的思路

我们不断将矩阵切分成四个结构相同的小矩阵，进行对应的矩阵乘法计算，最后直到分成每个数字相乘的时候，就成功了

当然，具体计算这矩阵相乘还有一定讲究

对于一个部分的结果，我们要计算两次小矩阵相乘，总共四个部分就是要计算八次

但是我们可以通过计算运算过程的中间值，最后利用这些中间值计算这些结果，就可以把计算次数缩小到七次

![image.png](分治法%20Divide%20and%20conquer/image%2010.png)

# 顺序统计量Order Statistics

给定一些样本 按从小到大排序得，第几个样本就叫第几个顺序统计量

我们将第一个顺序统计量称作最小值，最后一个称作最大值，中间的称作中间值

## 寻找冠军

我们已知一群运动员的水平不一，我们要找到冠军，那么我们怎么进行淘汰制的选拔出最强者呢

![image.png](分治法%20Divide%20and%20conquer/image%2011.png)

这是一个类似擂台赛的淘汰机制，其核心是所有非冠军的选手都会被打败一次，这样比较，n个选手会比较n - 1 次

![image.png](分治法%20Divide%20and%20conquer/image%2012.png)

像这样的选拔方式也是同理，不过更能体现出分治的特点

# MOM：中位数的中位数median of the medians

一种找主元的方法

简单来说，就是将一堆数组分成多个小数组，找到这些数组的中位数，再在这些中位数里找中位数，这样就能找到全局的主元

# 扩展欧几里得算法Extended Euclidean Algorithm