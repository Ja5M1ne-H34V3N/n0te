# 定义
## 最小生成树
最小生成树，再带权边且联通的图G上，生成树中总边权之和最小的称为最小生成树
## 森林
森林Forset是一种**若干棵互不相交的树的集合**
# 三种有关的经典的贪心算法
[贪心算法的回顾](算法导论/算法导论/贪心算法.md)

## Prim的“长树”法
从当前起点开始，每一步使用离当前树T最便宜的边来接入新顶点

比如下面的一个图（r是起点）：
![Pasted image 20251218152912](最小生成树/Pasted%20image%2020251218152912.png)
我们想找到其最小生成树，我们将我们目前选中的顶点（初始是r）作为树，那么接下来，我们看所有和这个树相连但不在树内的边：3 12 10
可见，权重为3的边是最小的，我们就将这个边以及这个边联通的另一个点加入树（选中），那么现在树的情况是这样的：
![Pasted image 20251218153227](最小生成树/Pasted%20image%2020251218153227.png)
接下来重复上述操作，我们看所有和当前树链接的边：9，7，12， 10
可见，7是权重最小的，那么我们重复上面的操作
![Pasted image 20251218153410](最小生成树/Pasted%20image%2020251218153410.png)
接下来，不断操作，直到图中的所有点都被加入（下图从右往左看）
![Pasted image 20251218153435](最小生成树/Pasted%20image%2020251218153435.png)

## Sruskal的‘合并森林’法
从空的图开始，按边权从小到大扫描，如果这个边连接着两个不同分量（就是如果加入这个边，则会有新的点加入生成树），则将这个边加入生成树
还是这个图，不过不再使用固定的初始点了
![Pasted image 20251218152912](最小生成树/Pasted%20image%2020251218152912.png)
此时，我们知道所有边的权重，我们找权重最短的边：1
我们将这个边和其链接的两个点加入生成树：
![Pasted image 20251218153628](最小生成树/Pasted%20image%2020251218153628.png)
接下来在剩余的边里找最小权重的边：2，我们发现，将2加入，会有一个新的点加入生成树，则选择这个边加入：
![Pasted image 20251218153808](最小生成树/Pasted%20image%2020251218153808.png)
接下来是3，同理：
![Pasted image 20251218153822](最小生成树/Pasted%20image%2020251218153822.png)
我们发现，此时边3和之前的树并未联通，我们可以视为目前已经创建了两个树
同理，再加入4：
![Pasted image 20251218153943](最小生成树/Pasted%20image%2020251218153943.png)
接下来，我们尝试加入边5 6，我们发现了一个问题：加入这两个边，不会有新的节点加入到生成树中（比如上图的红色边），所以，我们不会将这两个边加入生成树
在这之后，就是重复上述操作，知道所有节点都被加入生成树
![Pasted image 20251218154228](最小生成树/Pasted%20image%2020251218154228.png)

# Reverse-Delete（反向删除）法
从全图开始，按照边权从大到小扫描，若删除该边后图仍然联通，则删除这个边
这个就像上个方法反着来
还是这个图
![Pasted image 20251218154700](最小生成树/Pasted%20image%2020251218154700.png)
首先，我们知道所有边的情况，我们假设目前所有边和点都是生成树，我们寻找权重最大的边：12
我们发现，如果删去12，不会有哪一个点离开生成树，那我们将其删去
![Pasted image 20251218154805](最小生成树/Pasted%20image%2020251218154805.png)
重复上述操作，如果删去某个边，会导致点脱离生成树，则不删去这个边，跳过它
![Pasted image 20251218154842](最小生成树/Pasted%20image%2020251218154842.png)

## 时间复杂度：
- **预排序（Presorting）：** $O(m \log n)$
    
- **每一步的操作耗时：** $O((\log n)(\log \log n)^3)$。
    
- **总运行时间：** $O((m \log n)(\log \log n)^3)$
# 方法的正确性证明
## 安全接纳和安全拒绝 safe accept/safe reject
安全接纳和安全拒绝可以用于描述选择边时的策略，特别是在构建最小生成树时如何选择安全的边（接纳）或拒绝不符合要求的边。
这不是一个算法里标准的定义，只是用来概括一种情况

### 安全接纳
如果森林F中包含某棵MST，则称这个森林是安全的
如果e是从F的某个点向外离开的最便宜边，则F + e仍然是个安全森林
证明思路：取一棵包含 F 的 MST T；若 e 不在 T，则在 T 中连接 e 两端点的路径上必存在一条跨越 cut(S) 的边 f，且ℓ(e) ≤ ℓ(f)。用 e 替换 f 得到的新树仍为 MST，且包含 F + e。

简单来说：如果一个MST能引出一个边链接其他点，而且这个边是MST外所有边最小的，那么MST带上这个边和对应点后，还是MST
![Pasted image 20251218160853](最小生成树/Pasted%20image%2020251218160853.png)
### 安全拒绝
令 C 为图中的任意环（cycle），f 为 C 中最贵的边（most expensive edge）。则 f 不可能出
现在任何 MST 中。
证明思路：若某 MST T 含 f，则删去 f 后 T 分成两部分；环 C 中存在一条跨越这两部分的边 e，且 ℓ(e) ≤ ℓ(f)。用 e
替换 f 得到不更差的生成树，从而推出 f 不在某些 MST 中。

简单来说，当一个含有MST的成环图，我们知道，一个树一定是不成环的，那么一定要有几个边被删除，那这个边一定在那个环里找，因为MST是边权重之和越小越好，所以这个带环图中的MST，一定没有这个环里权重最大的那个边
![Pasted image 20251218160846](最小生成树/Pasted%20image%2020251218160846.png)

## 正确性证明：
• Prim：每次加入的是离包含 s 的树分量的最便宜外向边，因此是一次 safe accept。
• Kruskal：每次加入的是离某个树分量的最便宜外向边，因此也是 safe accept。
• Reverse-delete：每次删除的是某个环上最贵边，因此是 safe reject。


# 练习
![Pasted image 20251218162054](最小生成树/Pasted%20image%2020251218162054.png)
给你一个联通图，边数 m 与点数 n 很接近（例如 m = n + O(1)），设计 O(m+n) 的算法求 MST。

## Prim方法实现：
维护节点的数据结构：
包含成员变量：成本c(v)（表示从现有树的所有节点中，已经发现的到这个节点的最小权重边的权重），上一个节点
我们使用优先队列这个数据结构实现这个算法：
我们将图的所有顶点按照key = c（v）放入优先队列
接下来，我们将所有节点的成本c(v)设置为无穷大，将初始节点设置为自己，表示为根节点
接下来进行下面的循环：
	每当队列不为0时，取出队列中c(v)最小的那个节点u，表示为加入最小生成树
	接下来，检查所有和u直接相连的边，并读取相连的其他点的c(v)，。如果从u到那个点的边的权重小于当前c(v)，则更新其成本，对于更新成本的点，我们记录其上一个点为u
一直循环，直到优先级队列为空，表示最小生成树已经找到

### 时间复杂度
根据选择实现优先级队列的方式不同，时间复杂度不同
三种操作的时间消耗是：
Binary heap：三者均为 log n。
• Fibonacci heap：Insert 为 1（摊还），ExtractMin 为 log n（摊还），DecreaseKey 为 1（摊还）。
• Array：Insert 为 1，ExtractMin 为 n，DecreaseKey 为 1。
![Pasted image 20251218195255](最小生成树/Pasted%20image%2020251218195255.png)

## Kruskal 方法实现
节点保存的信息：根节点，下一个节点
考虑到后面两种算法都涉及到最大，最小等操作，我们要对边进行预处理：
我们先将所有边按照权重从小到大排起来（复杂度nlogn）

那么，接下来的操作，就是从小到大取出这些数据，每次取出，检查这个边相连的节点，那么分成两种情况：
### 新的边的两个点都在生成树中
直接pass掉
### 一条新的边，一个点在生成树中，另一个不在（或者第一个边）
对于第一个边来说，随便选择一个节点作为根节点，将其下一个节点设置为边连接的另一个点
对于新的边，且一条边在生成树中，我们设置在树中的节点a的下一个点为边链接的另一个点，同时设置另一个点根节点为a保存的根节点
### 链接这个边，导致两个树合并
这种操作需要我们观察两个树的大小，较小的那个树将被并入较大的那个树中，过程如下：
对于这个新建的边，较大树内的节点a的下一个节点设置边相连的那个较小树的节点b，之后，更新较小树中的所有节点的根节点为较大树的根节点

其实，我们可以这样理解这个树合并逻辑：
这是一个嵌套的过程，我们嵌套的发生是因为一个边把两棵树联通起来了，那么这个边就是这个树联通的通路，这个生成树就像这边一坨用小细线连到了另外一坨上
这种“树嵌套”的结构在计算机科学里还有一个专门的名字叫 **“Kruskal 树”** 或者 **“并查集树”**。它记录了所有点从“孤独的一个人”到“最终大家庭”的全部社交历程。
![Pasted image 20251218203355](最小生成树/Pasted%20image%2020251218203355.png)

预处理之后的时间复杂度：O（m + nlogn）


# 练习
证明只有边的顺序会影响kruskal的结果
对于下面两个图$G = (V, E; l)$ 和 $G = (V, E; l')$，如果l的排序是相同的（哪怕值不一样），最后得到的mst是一模一样的
为什么要强调边的顺序呢？因为哪怕一个图中几个权重相同的边，他们的排序方式不同，得到的mst结果也可能不同

灵活性：
于每一个最小生成树 $T$，都存在一种**打破平局（tie-breaking）的排序方式**，使得克鲁斯卡尔方法能够返回该树 $T$。
这句话的意思是，如果我们在使用过程中出现了相同权重的边，那么选择哪个边进行下一步操作，可能会导致生成不同的树
所以，如果一个图出现了相同的边，那么这个图生成mst的结果可能有多种情况，他们通过特定的排序方式处理边得到，既然出现了这种情况，我们就要想到，怎么测试一个mst的唯一性：是不是唯一的

#### 测试图的mst的唯一性
##### 灵活性
我们可以运用前面的灵活性，我们先进行排序，再检测等大小的边，将其按照排列组合，找到这些边在不同位置的所有情况，再根据这若干个排序结果在图中生成树，如果结果出现了不同的树，则无唯一性；如果这若干个排序方案都生成了相同的树，那么可以确定这个图的mst是唯一的
##### 替换边测试法
如果你已经有一棵 MST（记为 $T$），你可以通过以下步骤测试它是否唯一：
- **步骤：**
    1. 拿出一条**不在 $T$ 中**的边 $e$（假设其权重为 $w$）。
    2. 将边 $e$ 加入到 $T$ 中，这必然会形成一个**环 (Cycle)**。
    3. 检查这个环中其他的边：是否存在另一条边 $e'$，其权重也等于 $w$？
    4. **结论：** 如果存在这样一条权重相等的边 $e'$，那么你就可以用 $e$ 替换掉 $e'$，从而得到一棵权重总和完全一样、但结构不同的新树。这意味着 MST **不唯一**。
 其实和前面的方法大差不差，都是在测试相同权重的边能否造成新的mst的出现，只是一个在找mst之前进行，一个在生成一个mst之后运行

所以，因为mst的性质，如果一个图的所有边权重都是独特的，那么其生成的mst一定时唯一的

## Kruskal的分块变体/批量变体
当图中存在**多条权值相等**的边时，传统的“一次只看一条边”的方法就不够直观了。幻灯片中提到的“分块/批量处理”方法，正是为了解决这种权值冲突，并帮助我们识别边的性质。

### 1. 核心步骤详解
我们可以将算法执行过程分为三个阶段：
#### 阶段 A：预处理与分块

1. **排序**：将图中所有的边按权值从小到大排列。
    
2. **分块**：将权值相同的边归为同一个“块”（Block）。例如，所有权值为 5 的边都在第 $j$ 块，所有权值为 10 的边都在第 $j+1$ 块。
#### 阶段 B：迭代处理每个块（关键步骤）

对于每一个权值块（假设当前处理的是权值为 $w$ 的所有边）：

- **识别连接状态**：观察这些边连接的是哪些节点。此时，一些节点可能已经通过之前更小的边（第 $1$ 到 $j-1$ 块）连成了若干个连通分量。
    
- **缩点（Contraction）**：正如幻灯片中右侧的圆形图所示，我们将每一个已经形成的连通分量看作一个**“超节点”**（Super-node）。
    
- **构建子图**：只考虑当前块中权值为 $w$ 的边，看它们如何在这些“超节点”之间建立连接。
    
- **寻找极大生成森林**：在这些超节点之间，尽可能多地选取当前块中的边，只要不形成环。
#### 阶段 C：更新并进入下一块

将选中的边正式加入生成树中，合并相应的连通分量，然后处理下一组更高权值的边。










# 可交换对，生成树的验证

这个交换对的性质是对生成树而言的，而是对一个图的所有生成树（哪怕不是最小）而言的
后面的定义已经和“最小”无关了
## 基本割和基本回路
当给定一个生成树 $T$ 时：
### 1. 对于属于生成树的边 $e \in T$：
- **基本割 (Fundamental cut)：** 移去边 $e$ 原本的树T会被一分为二，树中所有符合这个性质的边，构成基本割
**特性：** 一条不在树上的边 $f$ 如果属于这个割集，那么把 $e$ 换成 $f$（即 $T - e + f$），得到的新图依然是一棵生成树。
### 2. 对于不属于生成树的边 $f \notin T$：
- **基本圈 (Fundamental circuit)：** 将不在树上的边 $f$ 添加到 $T$ 中会形成唯一的圈，这个圈被称为 $f$ 相对于 $T$ 的**基本圈**
**特性：** 这个圈上的任何一条边 $e$，如果被删掉（即 $T - e + f$），剩下的结构依然是一棵生成树。
## 可交换对
我们称可交换对为在不改变生成树定义的前提下，可以相互替换的一对边
能够实现相互替代，而且是这个最小生成树需要的，那么这个可交换对一定有下面的性质：
删掉可交换对目前在树中的那个边，生成树会割裂
添加可交换对中的不在树里的那个边，生成树会成环
### **可交换对 (Exchangeable pair)**

- **定义**：对于一个图中两棵不同的生成树 $T$ 和 $T'$，对于任何属于 $T$ 但不属于 $T'$ 的边 $e$ ($e \in T \setminus T'$)，一定存在一条属于 $T'$ 但不属于 $T$ 的边 $e'$ ($e' \in T' \setminus T$)，使得替换后的 $T' - e' + e$ 和 $T - e + e'$ 仍然都是生成树。
    （通俗来讲就是，如果一个图的一个生成树减去一个边，加上另一个边，结果还是一个生成树，那么这两个边称为可交换对）
- **实现方式**：令 $C$ 为边 $e$ 关于 $T'$ 的基本回路。$C - e$ 中一定存在一条边 $e'$ 跨越了 $e$ 关于 $T$ 的基本割。
![Pasted image 20251222160628](最小生成树/Pasted%20image%2020251222160628.png)
## 生成树的验证
**对于任何生成树 $T$，以下三项是等价的（TFAE）：**
1. $T$ 是一棵最小生成树 (MST)。
2. 树中的每一条边 $e \in T$ 都是其对应基本割（跨越 $T - e$ 的边）中最短的边。
3. 不在树中的每一条边 $e' \notin T$ 都是其对应基本回路（在 $T + e'$ 形成的环上）中最长的边。
- **证明思路**：通过寻找**可交换对** $(e, e')$ 来最大化两棵不同 MST 的重合部分。如果 $\ell(e) \le \ell(e')$，则可以通过替换得到重合度更大的新 MST。



# 练习：动态MST
给定图 $G$ 的一棵最小生成树 (MST) $T$，当一条边 $e$ 的权重（成本）发生以下变化时，请更新该 MST：
- **权重减少**
- **权重增加**
- **当权重减少时：**
    
    - 如果边 $e$ 原本就在 $T$ 中，它依然会在新的 MST 中。
        
    - 如果边 $e$ 原本不在 $T$ 中，将其加入 $T$ 会形成一个**基本回路 (Fundamental circuit)**。你需要找到该回路中权重最大的边 $e_{max}$。如果新权重 $w(e) < w(e_{max})$，则用 $e$ 替换 $e_{max}$。
        
- **当权重增加时：**
    
    - 如果边 $e$ 原本不在 $T$ 中，它依然不会出现在新的 MST 中。
        
    - 如果边 $e$ 原本在 $T$ 中，将其删除会产生一个**基本割 (Fundamental cut)**。你需要找到跨越该割的所有边中权重最小的一条 $e'_{min}$。如果新权重 $w(e) > w(e'_{min})$，则用 $e'_{min}$ 替换 $e$。




# 练习题
## 全源最小/最大路径
#### **【问题背景】**
你正在驾驶一辆电动汽车准备横穿一片荒野。在这片区域中分布着若干个补电站，补电站之间由一些道路相连。每条道路都有其特定的长度。
你的电动汽车有一个限制：**单次充满电后的最大续航里程是有限的**。如果你选择的路径中，任何一段相邻补电站之间的距离超过了汽车的最大续航里程，你将会抛锚在半路。
#### **【形式化定义】**

给定一个带权无向连通图 $G = (V, E)$，其中：
- **顶点集 $V$**：代表所有的补电站。
- **边集 $E$**：代表连接补电站的道路。
- **边权 $w(e)$**：代表道路 $e$ 的长度。
对于图中任意两个补电站 $u$ 和 $v$，定义一条路径 $P$ 的**“瓶颈值”**为该路径上所有边权的最大值，即：
$$\max \{w(e) \mid e \in P\}$$
#### 【任务要求】**
1. **最小-最大路径问题**：设计一个算法，找出从起点 $s$ 到终点 $t$ 的一条路径，使得该路径的“瓶颈值”达到最小。这意味着你需要找到一辆续航需求最低的车也能通过的路径。
2. **全源扩展**：如何高效地预计算出图中**任意两点**之间的最小“瓶颈值”？
3. **证明与关联**：请证明或利用图论原理说明，为什么该图的**最小生成树（MST）**可以解决上述所有点对之间的最小-最大路径问题。

1：直接前面三种算法找到最小生成树

2：使用prim算法计算mst，接下里，按照下面的lca（最近公共祖先）算法解决问题：
#### **准备工作（预处理）：**

我们使用深度优先搜索（DFS）遍历整棵树，并记录两个关键信息：
1. **`depth[u]`**：节点 $u$ 的深度。
2. **`up[u][i]`**：从节点 $u$ 向上跳 $2^i$ 层到达的祖先。
    - 例如：`up[u][0]` 是 $u$ 的父节点。
    - 根据倍增原理：`up[u][i] = up[up[u][i-1]][i-1]`（跳 $2^i$ 步等于先跳 $2^{i-1}$ 步，再跳 $2^{i-1}$ 步）。
#### **执行查询（Query）：**
假设我们要找 $u$ 和 $v$ 的 LCA：
1. **对齐高度**：先看谁更深，让深的那个节点（假设是 $u$）向上跳，跳到和 $v$ 同一深度。
2. **同步向上跳**：如果对齐后 $u$ 还不等于 $v$，说明 LCA 在更上面。此时 $u$ 和 $v$ 同时向上跳尽可能大的步数（按 $2^i$ 从大到小尝试），但要求跳完后两者**仍然不相等**。
3. **得到结果**：跳到最后，此时 $u$ 和 $v$ 的父节点（即 `up[u][0]`）就是我们要找的 LCA。
4. 同时，在跳的时候，记录下面的信息：**`max_edge[u][i]`**：从 $u$ 向上跳 $2^i$ 层这个过程中，经过的**最大边权**
5. 当两个点找到最小公共祖先后，两个点的路就联通了，此时我们比较两个点上跳过程中记录的最大边权，较大的那个就是瓶颈
#### 时间复杂度
- **预处理**：$O(V \log V)$（每个节点都要计算 $\log V$ 个祖先信息）。
- **单次查询**：$O(\log V)$。
3：采用反证法证明贪心的正确性


## 所有点对最小最大路径
对于树 $T$ 中连接 $u-v$ 路径上的任意一条**最长边 $e$**：
- 每一条 $u-v$ 路径都必须跨越 $T - e$（从树 $T$ 中移除边 $e$）所形成的两个连通分量；
- 在连接这两个连通分量的所有边中，$e$ 是**最短的一条**。

说白了 就是鸡头和凤尾，当前路径里权重最大的边e，如果移去它，那找不到比他更小的边来连接这两个连通分量，e是由贪心算法得到的能找到的权重最小的边，e虽然是路径上最大的，但它是路径之外里最小的

## 单对最小最大路径
**题目要求：** 请给出一个时间复杂度为 $O(m)$ 的算法，用于寻找一条“最小最大 $s-t$ 路径”（min-max $s-t$ path）。
**最小最大路径问题 (Min-Max Path Problem)：** 在一个带权图中，目标是找到一条从源点 $s$ 到终点 $t$ 的路径，使得该路径上**权重最大的那条边**的权值在所有可能的 $s-t$ 路径中是**最小的**。这通常也被称为“瓶颈路径问题”。
思路：
### $O(m)$ 算法详细步骤

假设我们要处理的图为 $G = (V, E)$，寻找 $s$ 到 $t$ 的最小最大路径。
### 1. 选取中位数 (Find Median)

找到当前边集中所有权值的中位数 $w^* = \text{median}(E)$。

- **复杂度**：使用“中位数的中位数”算法（Median of Medians），可以在 $O(|E|)$ 时间内找到。
### 2. 划分边集并测试连通性

将边集 $E$ 划分为两个子集：
- $E_{small} = \{e \in E \mid weight(e) \le w^*\}$
- $E_{large} = \{e \in E \mid weight(e) > w^*\}$

使用 **BFS** 或 **DFS** 仅在 $E_{small}$ 中检查 $s$ 和 $t$ 是否连通。

### 3. 递归与收缩 (Contract & Conquer)
根据连通性结果，分为两种情况：
#### **情况 A：$s$ 和 $t$ 在 $E_{small}$ 中已经连通**

这说明“瓶颈边”的值一定小于或等于 $w^*$
- **动作**：完全抛弃 $E_{large}$ 中的所有边。
- **下一步**：在更小的图 $G' = (V, E_{small})$ 上进行递归。
#### **情况 B：$s$ 和 $t$ 在 $E_{small}$ 中不连通**

这说明“瓶颈边”的值一定大于 $w^*$，必须借用 $E_{large}$ 里的边。

- **动作**：这是最关键的一步。在 $E_{small}$ 中，很多点已经通过小权重的边连通了。我们可以将 $E_{small}$ 形成的每个**连通分量（Connected Component）**“收缩”成一个**超级顶点（Super-vertex）**。
    
- **下一步**：在收缩后的新图中，仅保留 $E_{large}$ 中的边，在更小的图上递归。
### 为什么这样做是 $O(m)$？

这是算法分析中最迷人的部分。我们来看每一轮递归的规模：
1. **第一轮**：处理 $m$ 条边，耗时 $cm$。
2. **第二轮**
    - 如果是情况 A，我们只剩下 $E_{small}$，边数减半为 $m/2$。
    - 如果是情况 B，我们收缩了连通分量，虽然看似只去掉了 $E_{small}$，但实际上通过收缩，图的点数和边数都会显著减少（通常也是减半左右）。
3. 总耗时：
    这是一个典型的等比数列求和：
    $$T(m) = cm + \frac{1}{2}cm + \frac{1}{4}cm + \dots \approx 2cm = O(m)$$


## 最大间隔 $k$-聚类（Max-spacing $k$-clustering）算法
题目背景：
给定平面上的 $n$ 个点（或者一个包含 $n$ 个节点的完全图），点与点之间的距离由欧几里得距离或其他度量方式给出。我们需要将这 $n$ 个点划分为 $k$ 个非空的集合（称为“簇”）。
**定义：**
- **聚类的间隔 (Spacing)：** 指任意两个属于不同簇的点之间的**最小**距离。
任务：
请设计并证明一个算法，找到一种划分方式，使得该聚类的间隔达到最大值。

首先，在图中使用算法找到mst，接着移除mst中前三大权重的边作为间隔
证明同样是反证贪心：这三个在mst中最大的边是外面的边里最小的
![Pasted image 20251222170253](最小生成树/Pasted%20image%2020251222170253.png)




## 练习：最小权重反馈边集 (Minimum-weight feedback edge set)
如果边集的一个子集 $F$ 满足：$G$ 中的**每一个环**都包含 $F$ 中的某条边（这等同于：从图 $G$ 中移除 $F$ 后，剩余的图是不含环的，即无环图），那么 $F$ 就被称为一个**反馈边集 (feedback edge set)**。
_(注：图片中展示了一个带有权重的图，部分边被标红。)_
问题描述：
请描述并分析一种快速算法，用于计算给定的边带权图中权重最小的反馈边集。
![Pasted image 20251222182900](最小生成树/Pasted%20image%2020251222182900.png)

用最小生成树的方法计算权重最大的生成树，然后让边集减去这些树中的边