# 定义
## 最小生成树
最小生成树，再带权边且联通的图G上，生成树中总边权之和最小的称为最小生成树
## 森林
森林Forset是一种由多个树组成的图，或者说，是一个无环的，由多个联通的子树构成的图
# 三种有关的经典的贪心算法
[贪心算法的回顾](算法导论/算法导论/贪心算法.md)

## Prim的“长树”法
从当前起点开始，每一步使用离当前树T最便宜的边来接入新顶点

比如下面的一个图（r是起点）：
![Pasted image 20251218152912](最小生成树/Pasted%20image%2020251218152912.png)
我们想找到其最小生成树，我们将我们目前选中的顶点（初始是r）作为树，那么接下来，我们看所有和这个树相连但不在树内的边：3 12 10
可见，权重为3的边是最小的，我们就将这个边以及这个边联通的另一个点加入树（选中），那么现在树的情况是这样的：
![Pasted image 20251218153227](最小生成树/Pasted%20image%2020251218153227.png)
接下来重复上述操作，我们看所有和当前树链接的边：9，7，12， 10
可见，7是权重最小的，那么我们重复上面的操作
![Pasted image 20251218153410](最小生成树/Pasted%20image%2020251218153410.png)
接下来，不断操作，直到图中的所有点都被加入（下图从右往左看）
![Pasted image 20251218153435](最小生成树/Pasted%20image%2020251218153435.png)

## Sruskal的‘合并森林’法
从空的森林开始，按边权从小到大扫描，如果这个边连接着两个不同分量（就是如果加入这个边，则会有新的点加入生成树），则将这个边加入生成树
还是这个图，不过不再使用固定的初始点了
![Pasted image 20251218152912](最小生成树/Pasted%20image%2020251218152912.png)
此时，我们知道所有边的权重，我们找权重最短的边：1
我们将这个边和其链接的两个点加入生成树：
![Pasted image 20251218153628](最小生成树/Pasted%20image%2020251218153628.png)
接下来在剩余的边里找最小权重的边：2，我们发向，将2加入，会有一个新的点加入生成树，则选择这个边加入：
![Pasted image 20251218153808](最小生成树/Pasted%20image%2020251218153808.png)
接下来是3，同理：
![Pasted image 20251218153822](最小生成树/Pasted%20image%2020251218153822.png)
我们发现，此时边3和之前的树并未联通，我们可以视为目前已经创建了两个树
同理，再加入4：
![Pasted image 20251218153943](最小生成树/Pasted%20image%2020251218153943.png)
接下来，我们尝试加入边5 6，我们发现了一个问题：加入这两个边，不会有新的节点加入到生成树中（比如上图的红色边），所以，我们不会将这两个边加入生成树
在这之后，就是重复上述操作，知道所有节点都被加入生成树
![Pasted image 20251218154228](最小生成树/Pasted%20image%2020251218154228.png)

# Reverse-Delete（反向删除）法
从全图开始，按照边权从大到小扫描，若删除该边后图仍然联通，则删除这个边
这个就像上个方法反着来
还是这个图
![Pasted image 20251218154700](最小生成树/Pasted%20image%2020251218154700.png)
首先，我们知道所有边的情况，我们假设目前所有边和点都是生成树，我们寻找权重最大的边：12
我们发现，如果删去12，不会有哪一个点离开生成树，那我们将其删去
![Pasted image 20251218154805](最小生成树/Pasted%20image%2020251218154805.png)
重复上述操作，如果删去某个边，会导致点脱离生成树，则不删去这个边，跳过它
![Pasted image 20251218154842](最小生成树/Pasted%20image%2020251218154842.png)

# 方法的正确性证明
## 安全接纳和安全拒绝 safe accept/safe reject
安全接纳和安全拒绝可以用于描述选择边时的策略，特别是在构建最小生成树时如何选择安全的边（接纳）或拒绝不符合要求的边。
这不是一个算法里标准的定义，只是用来概括一种情况

### 安全接纳
如果森林F中包含某棵MST，则称这个森林是安全的
如果e是从F的某个点向外离开的最便宜边，则F + e仍然是个安全森林
证明思路：取一棵包含 F 的 MST T；若 e 不在 T，则在 T 中连接 e 两端点的路径上必存在一条跨越 cut(S) 的边 f，且ℓ(e) ≤ ℓ(f)。用 e 替换 f 得到的新树仍为 MST，且包含 F + e。

简单来说：如果一个MST能引出一个边链接其他点，而且这个边是MST外所有边最小的，那么MST带上这个边和对应点后，还是MST
![Pasted image 20251218160853](最小生成树/Pasted%20image%2020251218160853.png)
### 安全拒绝
令 C 为图中的任意环（cycle），f 为 C 中最贵的边（most expensive edge）。则 f 不可能出
现在任何 MST 中。
证明思路：若某 MST T 含 f，则删去 f 后 T 分成两部分；环 C 中存在一条跨越这两部分的边 e，且 ℓ(e) ≤ ℓ(f)。用 e
替换 f 得到不更差的生成树，从而推出 f 不在某些 MST 中。

简单来说，当一个含有MST的成环图，我们知道，一个树一定是不成环的，那么一定要有几个边被删除，那这个边一定在那个环里找，因为MST是边权重之和越小越好，所以这个带环图中的MST，一定没有这个环里权重最大的那个边
![Pasted image 20251218160846](最小生成树/Pasted%20image%2020251218160846.png)

## 正确性证明：
• Prim：每次加入的是离包含 s 的树分量的最便宜外向边，因此是一次 safe accept。
• Kruskal：每次加入的是离某个树分量的最便宜外向边，因此也是 safe accept。
• Reverse-delete：每次删除的是某个环上最贵边，因此是 safe reject。


# 练习
![Pasted image 20251218162054](最小生成树/Pasted%20image%2020251218162054.png)
给你一个联通图，边数 m 与点数 n 很接近（例如 m = n + O(1)），设计 O(m+n) 的算法求 MST。

## Prim方法实现：
维护节点的数据结构：
包含成员变量：成本c(v)（表示从现有树的所有节点中，已经发现的到这个节点的最小权重边的权重），上一个节点
我们使用优先队列这个数据结构实现这个算法：
我们将图的所有顶点按照key = c（v）放入优先队列
接下来，我们将所有节点的成本c(v)设置为无穷大，将初始节点设置为自己，表示为根节点
接下来进行下面的循环：
	每当队列不为0时，取出队列中c(v)最小的那个节点u，表示为加入最小生成树
	接下来，检查所有和u直接相连的边，并读取相连的其他点的c(v)，。如果从u到那个点的边的权重小于当前c(v)，则更新其成本，对于更新成本的点，我们记录其上一个点为u
一直循环，知道优先级队列为空，表示最小生成树已经找到

### 时间复杂度
根据选择实现优先级队列的方式不同，时间复杂度不同
三种操作的时间消耗是：
Binary heap：三者均为 log n。
• Fibonacci heap：Insert 为 1（摊还），ExtractMin 为 log n（摊还），DecreaseKey 为 1（摊还）。
• Array：Insert 为 1，ExtractMin 为 n，DecreaseKey 为 1。
![Pasted image 20251218195255](最小生成树/Pasted%20image%2020251218195255.png)

## Kruskal 方法实现
节点保存的信息：根节点，下一个节点
考虑到后面两种算法都涉及到最大，最小等操作，我们要对边进行预处理：
我们先将所有边按照权重从小到大排起来（复杂度nlogn）

那么，接下来的操作，就是从小到大取出这些数据，每次取出，检查这个边相连的节点，那么分成两种情况：
### 新的边的两个点都在生成树中
直接pass掉
### 一条新的边，一个点在生成树中，另一个不在（或者第一个边）
对于第一个边来说，随便选择一个节点作为根节点，将其下一个节点设置为边连接的另一个点
对于新的边，且一条边在生成树中，我们设置在树中的节点a的下一个点为边链接的另一个点，同时设置另一个点根节点为a保存的根节点
### 链接这个边，导致两个树合并
这种操作需要我们观察两个树的大小，较小的那个树将被并入较大的那个树中，过程如下：
对于这个新建的边，较大树内的节点a的下一个节点设置边相连的那个较小树的节点b，之后，更新较小树中的所有节点的根节点为较大树的根节点

其实，我们可以这样理解这个树合并逻辑：
这是一个嵌套的过程，我们嵌套的发生是因为一个边把两棵树联通起来了，那么这个边就是这个树联通的通路，这个生成树就像这边一坨用小细线连到了另外一坨上
这种“树嵌套”的结构在计算机科学里还有一个专门的名字叫 **“Kruskal 树”** 或者 **“并查集树”**。它记录了所有点从“孤独的一个人”到“最终大家庭”的全部社交历程。
![Pasted image 20251218203355](最小生成树/Pasted%20image%2020251218203355.png)

# 可交换对，生成树的验证
## 可交换对
我们称可交换对为在不改变生成树定义的前提下，可以相互替换的一对边
能够实现相互替代，而且是这个最小生成树需要的，那么这个可交换对一定有下面的性质：
删掉可交换对目前在树中的那个边，生成树会割裂
添加可交换对中的不在树里的那个边，生成树会成环

### **可交换对 (Exchangeable pair)**

- **定义**：对于两棵不同的生成树 $T$ 和 $T'$，对于任何属于 $T$ 但不属于 $T'$ 的边 $e$ ($e \in T \setminus T'$)，一定存在一条属于 $T'$ 但不属于 $T$ 的边 $e'$ ($e' \in T' \setminus T$)，使得替换后的 $T' - e' + e$ 和 $T - e + e'$ 仍然都是生成树。
    
- **实现方式**：令 $C$ 为边 $e$ 关于 $T'$ 的基本回路。$C - e$ 中一定存在一条边 $e'$ 跨越了 $e$ 关于 $T$ 的基本割。
![Pasted image 20251218205345](最小生成树/Pasted%20image%2020251218205345.png)
## 生成树的验证
**对于任何生成树 $T$，以下三项是等价的（TFAE）：**
1. $T$ 是一棵最小生成树 (MST)。
2. 树中的每一条边 $e \in T$ 都是其对应基本割（跨越 $T - e$ 的边）中最短的边。
3. 不在树中的每一条边 $e' \notin T$ 都是其对应基本回路（在 $T + e'$ 形成的环上）中最长的边。
- **证明思路**：通过寻找**可交换对** $(e, e')$ 来最大化两棵不同 MST 的重合部分。如果 $\ell(e) \le \ell(e')$，则可以通过替换得到重合度更大的新 MST。