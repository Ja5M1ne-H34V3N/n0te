# 回溯法Backtracking/单调栈

所有者: H34V3N

## 小行星碰撞

我们用一个数组表示一群按相同速度在一条线移动的小行星

![image.png](回溯法Backtracking%20单调栈/image.png)

其中 每个数的绝对值代表了小行星的质量；移动的方向，数字正负代表了小行星移动的方向

数字的索引代表了此时的相对位置

现规定：当两颗小星星碰撞时，较小的小行星会爆炸，如果质量相同，两者都会爆炸

统计在所有碰撞发生后，未爆炸的小行星

根据题目要求，我们知道，如果方向相同，则这两个小行星一定不会碰撞，对于一个按照某方向移动的小行星，其一定会和自己前方第一个按相反方向的小行星发生碰撞，同时，在发生碰撞后未爆炸的小行星仍然有可能和之后的小行星发生碰撞

根据题意，我们可以利用[单调栈](https://www.notion.so/1e305a2041d2808d9641d33b08c75924?pvs=21)来解决这个问题：

我们从左往右遍历数组中每一个数字，同时维护一个栈

当遍历到第一个数的时候，我们将这个数存入栈，接下来遍历到下一个数后，通过判断当前数和栈顶的正负性是否相同来判断是否会相撞：

如果方向相同，则直接将其入栈

如果方向不同，则和当前栈顶比较，来模拟碰撞的过程：如果小于栈顶的绝对值，则结束比较，接着遍历下一个数；如果大于栈顶的绝对值则将栈顶出栈，接着重复判断的栈顶的正负，比较绝对值的过程，直到当前栈顶的正负性相同或栈已经空了，此时将当前遍历到的数入栈。如果比较过程中栈顶的数较大，则停止比较操作，接着往下遍历；如果两者绝对值一样大，则栈顶出栈后接着向后遍历

在遍历结束后，栈中保存的数就对应着所有未爆炸的小行星

# 所有最近的较小值

给你一个正整数组，要求找到每个数的左侧，比这个数小，而且离他最近的数的索引

（在本题目中 第一个数一直是0，保证之后的所有数字左侧都一定有至少一个小于自身的数）

![image.png](回溯法Backtracking%20单调栈/image%201.png)

还是利用[单调栈](https://www.notion.so/1e305a2041d2808d9641d33b08c75924?pvs=21)

我们维护一个栈，和一个空的数组用于存放结果

依旧从左向右遍历这个数组，此时我们将遍历到的第一个数的下标（0）压入栈中

接着往后遍历，如果接下来的下标指向的数大于栈顶，则将栈顶的数存入保存结果的数组中当前数对应的位置；如果小于栈顶，则栈顶出栈，接着和新的栈顶对应的数比较，直到栈顶小于等于当前遍历到的数，接着将遍历到的数对应的索引压入栈，重复这个过程 直到遍历结束

遍历结束后，存放结果的数组保存的是符合题目要求的数值，而非索引，此时我们可以根据这个数值搜索索引，或直接在比较的过程直接添加答案的索引而非数值

时间复杂度；O（n）

# 最大瓶颈区间

我草 我在力扣做过这个 当时根本想不明白

给你一堆方格构成的奇怪形状：

![image.png](回溯法Backtracking%20单调栈/image%202.png)

在这个形状里，每一个方格都是从下网上累积的，就是数量不同

我们用一个数组表示第n列有多少个方格

好的，请找到这个形状里最大的矩形的面积

这道题就是上一道题的延申，我们用单调栈求出数组里所有数左右最近的更小元素的下标（当然，如果连着），找到两者的距离（不取端点）得到的长度就是当前数字能撑起来的最大的长方形的长度，接着乘当前的数字就得到了数组中某个数数字对应的列能撑起来的最大的长方形的面积，最后，将计算的面积里找到最大值，就是答案

# 窗口

给你一个数组，同时规定一个长度a，对于所有在数组里截取出来的一个长度为a的一个连续的子数组，找到这些子数组的最小值和最大值

我们利用前面的思路，计算出数组中每一个左右最近更小元素和更大元素的下标，这样，我们就知道这个数能够作为窗口内最小/最大元素的范围

# 最小/最大区间

给定一个数组，此时每个数组的元素不再是简单的数字，而是一个闭区间：

S={[1,5], [2,4], [3,6], [7,10], [8,9], [12,13]}

我们在这种情境之下定义最小和最大区间：

最小区间：不包含任何其他的区间

最大区间：不会被任何其他区间包含

这里的“包含”指一个区间的开始和结尾都在另一个区间的范围内

此时，我们要在这个数组里找到所有的最大和最小区间

我们可以利用单调栈

# 凸包问题Convex Hull

![image.png](回溯法Backtracking%20单调栈/image%203.png)

这是一个点阵，我们发现其最外围的一部分点连成的线组成的包能让所有点在其内（包括线上），我们称这个线是一个凸包，现在的问题是：随机给你一个横纵坐标都确定的点阵，请找出这样复合条件的凸包（找出端点即可）

## 礼物包装法/贾维斯步进法Gift wrapping: Jarvis march

我们假设有一个胶带，我们从一个已知确定是答案之一的点开始，在最外层缠胶带那样找下一个点

如何寻找第一个已知的点？

对于一个确定的点阵来说，其最左边（横坐标最小）的点是确定的，因为如果想把它包住的话，必须要有比他靠左的点才行。

接下来怎么找呢？我们想象缠胶带的过程：我们先把胶带拉的老长，然后慢慢向包装靠拢，这样，胶带就会先沾上包装最外部的部分。抽象来说就是：假如我们按顺时针包的话，我们以当前点为原点建系，同时设一条和y轴正半轴重合的直线，接着顺时针转动这个直线，直到直线碰到一个点，那这一个点就是下一个外围点

![image.png](回溯法Backtracking%20单调栈/image%204.png)

在每个外围点上重复这个操作，直到重新回到第一个点（最左边那个点）为止

我们不禁会产生疑问：如果当前点位于整个点阵的下方，这样就会提前碰到点阵里面的点，这该怎么办？好说，维护一个旋转的角度值，在当前旋转角度超过角度值时再开始计数就好

## 单调链算法Monotone chain algorithm

来了嗷，最回溯的一集

我们先将结果分成上凸包和下凸包两部分：

![image.png](回溯法Backtracking%20单调栈/image%205.png)

### 上凸包计算：

我们先将所有点按横坐标从左到右进行排序，接着遍历他们，我们发现，对于这些凸包点，都是那些靠上的点

我们维护一个栈

首先将第一个点入栈，这是符合要求的最左侧的点（符合要求的原因见上文）接着往后遍历，因为我们是从左往右遍历的，此时凸包无论如何也是呈上升趋势的，所以我们寻找第一个纵坐标大于栈顶的点，将其作为栈的第二个值入栈，如果下一个点还是大于栈顶，则将其入栈

此后，在遍历到每个点后，我们都先判断栈顶前两个点纵坐标的大小，来判断凸包目前是上升趋势还是下降趋势

此时栈顶的前两个点是呈上升趋势的

![image.png](回溯法Backtracking%20单调栈/image%206.png)

此时的栈

如果下一个点小于栈顶，也将其入栈。此时栈顶前两个点变成了呈下降趋势，

![image.png](回溯法Backtracking%20单调栈/image%207.png)

接着，我们继续遍历，如果接下来的点比当前栈顶小，则将其入栈，最后就是这样

![image.png](回溯法Backtracking%20单调栈/image%208.png)

接着遍历，突然出现了一个纵坐标大于当前栈顶的点！，这意味着，还有更大的点存在，此时我们的凸包应该还是上升趋势！也就是说，我们要将栈的状态回溯至上升阶段

我们接下来比较前两个栈顶的纵坐标值，如果栈顶的纵坐标小于下一个栈中下一个点的纵坐标，则将栈顶出栈，直到栈顶的纵坐标大于等于栈中下一个点的坐标，此时，栈恢复了上升趋势，我们在将遍历到的点入栈，也就变成了这样

![image.png](回溯法Backtracking%20单调栈/image%209.png)

重复以上的工作，直到遍历完所有点，这样，我们就找到了构成上凸包的点集

### 下凸包

下凸包和上凸包类似，我们还是从最左边的点开始，只是我们开头一定是下降的趋势，遍历到后期才是上升的趋势，也就是和上文反着来

总体时间复杂度：O（n）

### 和分治结合

我们可以将这些点划成几个组，每个组分别用单调链算法计算小凸包，将这些顶点存入数组中，接着，我们再对这些点进行找大凸包的礼物包装法计算即可

![image.png](回溯法Backtracking%20单调栈/image%2010.png)

![image.png](回溯法Backtracking%20单调栈/image%2011.png)