# 利用拓扑排序寻找
![Pasted image 20251203102521](有向无环图的最短路径/Pasted%20image%2020251203102521.png)
我们按照之前学过的方法进行拓扑排序，将排序后的节点重新标号。规定：
d（s） = 0对于原点
$(d(v)=\min _{(u, v) \in A}\{d(u)+\ell(u, v)\})$对于其他点
利用这种方式排好序后，我们就能保证计算到某节点的最短路径时，其前一个节点的最短路径已经计算出来了
## 具体的的实现方式——拉取或推动
### 拉取（惰性更新）

```plaintext
初始化所有节点的d(v)为无穷大，d(s)=0；  // 源点距离设为0
对节点按拓扑顺序（1→2→…→n）执行：
    对每个指向当前节点v的边(u, v)：  // 遍历v的所有前驱边
        用d(u) + ℓ(u, v)更新d(v)（取最小值）；
返回所有节点的d(v)
```


### 推动（主动更新）
```plaintext
初始化所有节点的d(v)为无穷大，d(s)=0；
对节点按拓扑顺序（1→2→…→n）执行：
    对每个从当前节点u出发的边(u, v)：  // 遍历u的所有出边
        用d(u) + ℓ(u, v)更新d(v)（取最小值）；
返回所有节点的d(v)；
```

## 有向无环图中的最长路径树



# 例：带权区间选择
