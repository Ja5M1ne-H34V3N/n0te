# 利用拓扑排序寻找
![Pasted image 20251203102521](有向无环图的最短路径/Pasted%20image%2020251203102521.png)
我们按照之前学过的方法进行拓扑排序，将排序后的节点重新标号。规定：
d（s）= 0对于原点
$(d(v)=\min _{(u, v) \in A}\{d(u)+\ell(u, v)\})$对于其他点
利用这种方式排好序后，我们就能保证计算到某节点的最短路径时，其前一个节点的最短路径已经计算出来了
## 具体的的实现方式——拉取或推动
### 拉取（惰性更新）

```plaintext
初始化所有节点的d(v)为无穷大，d(s)=0；  // 源点距离设为0
对节点按拓扑顺序（1→2→…→n）执行：
    对每个指向当前节点v的边(u, v)：  // 遍历v的所有前驱边
        用d(u) + ℓ(u, v)更新d(v)（取最小值）；
返回所有节点的d(v)
```


### 推动（主动更新）
```plaintext
初始化所有节点的d(v)为无穷大，d(s)=0；
对节点按拓扑顺序（1→2→…→n）执行：
    对每个从当前节点u出发的边(u, v)：  // 遍历u的所有出边
        用d(u) + ℓ(u, v)更新d(v)（取最小值）；
返回所有节点的d(v)；
```
![Pasted image 20251221223820](无负边图的最短生成树/Pasted%20image%2020251221223820.png)
## 有向无环图中的最长路径树

在最短路径树的基础上，把比小改成比大就好

# 例：带权区间选择
下面有n个区间，每个都有自己的权重，下方的时间轴配上其长度表示了其时间跨度，现在请选择合适的区间使其权重最大
![Pasted image 20251221225514](无负边图的最短生成树/Pasted%20image%2020251221225514.png)
根据前面的学习，我们知道这个题可以直接用单纯的动态规划解决

但是，使用拓扑排序也可以解决这个问题
我们将每个时间节点设置为图的节点，将任务区间设置为开始时间点到结束时间点的边，其权重设置为边权重
![Pasted image 20251221225747](无负边图的最短生成树/Pasted%20image%2020251221225747.png)
那么接下来，我们就将问题转化为：寻找权重最大的一个路径，起点任意 终点也任意

那么直接从拓扑排序后的结果从头到尾进行遍历就好了，有路径就一直往前走，走出所有情况，一边走一边更新更好的结果
