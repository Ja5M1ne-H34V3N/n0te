## 迪杰斯特拉算法
按和原点距离递增的顺序来生成树

首先，将除了原点（0）之外，原点到其他点的距离设置为无限
接下来 我们从原点开始，此时通过原点和与原点相邻的边，我们能算出这些连着原点的另一些点的距离，即自己点的距离 + 边的权重（如下图第二个图的4和3），我们称其为解锁状态，此时我们在所有解锁的状态点里，找到距离最短的那个点（如下图第二个图的3），确定这个点。此时点r的最短路径就被确定了，接下来我们将视角移动到确定最短路径的点r上，按同样的流程解锁和这个点直接相连的其他点，再找这些解锁点里距离最短的点……重复操作直到所有结点的最小路径都被确定
过程就像下面这样
![Pasted image 20251203110047](无负边图的最短生成树/Pasted%20image%2020251203110047.png)
### 基于优先队列的实现方法

```plaintext
// 初始化：对每个节点设置距离估计和前驱节点
for 每个节点 v ∈ V do
    p(v) ← ∞  // p(v)表示节点v的当前最短距离估计值，初始为无穷大
    prev(v) ← null  // prev(v)表示v在最短路径中的前驱节点，初始为空
p(s) ← 0  // 源点s的距离估计值设为0（起点到自身距离为0）
将源点 s 插入优先队列 Q  // 优先队列按节点的p(v)值（距离估计）升序排序

// 迭代：逐步提取距离最小的节点并更新邻居距离
while 优先队列 Q 不为空 do
    u ← ExtractMin(Q)  // 提取Q中p(u)最小的节点u，该节点的最短距离正式确定
    for 每个节点 v ∈ 节点u的出邻节点（即所有边(u, v) ∈ A） do
        // 计算通过u到达v的临时距离：u的确定距离 + 边(u, v)的权重
        temp_dist ← p(u) + ℓ(u, v)
        if temp_dist < p(v) then  // 若临时距离比v当前的距离估计更小
            p(v) ← temp_dist  // 更新v的距离估计值为临时距离
            prev(v) ← u  // 更新v的前驱节点为u
            if v 未在优先队列 Q 中 then  // 若v尚未加入队列
                Insert(Q, v)  // 将v插入优先队列Q
            else  // 若v已在队列中
                DecreaseKey(Q, v)  // 减小v在队列中的优先级（更新为新的p(v)值）

// 输出结果：所有节点的最短距离（p(v)此时已为确定的最短路径长度）
return { p(v) | v ∈ V }
```
### 正确性

使用数学归纳法证明

### 时间复杂度
![Pasted image 20251203111118](无负边图的最短生成树/Pasted%20image%2020251203111118.png)


### 这种算法，再出现负权边时，将会出现错误
![Pasted image 20251203111338](无负边图的最短生成树/Pasted%20image%2020251203111338.png)

## 应用：单边机组调度