## 迪杰斯特拉算法
按和原点距离递增的顺序来生成树

首先，将除了原点（0）之外，原点到其他点的距离设置为无限
接下来 我们从原点开始，此时通过原点和与原点相邻的边，我们能算出这些连着原点的另一些点的距离，即自己点的距离 + 边的权重（如下图第二个图的4和3），我们称其为解锁状态，此时我们在所有解锁的状态点里，找到距离最短的那个点（如下图第二个图的3），确定这个点。此时点r的最短路径就被确定了，接下来我们将视角移动到确定最短路径的点r上，按同样的流程解锁和这个点直接相连的其他点，再找这些解锁点里距离最短的点……重复操作直到所有结点的最小路径都被确定
过程就像下面这样
![Pasted image 20251203110047](无负边图的最短生成树/Pasted%20image%2020251203110047.png)
### 基于优先队列的实现方法

```plaintext
// 初始化：对每个节点设置距离估计和前驱节点
for 每个节点 v ∈ V do
    p(v) ← ∞  // p(v)表示节点v的当前最短距离估计值，初始为无穷大
    prev(v) ← null  // prev(v)表示v在最短路径中的前驱节点，初始为空
p(s) ← 0  // 源点s的距离估计值设为0（起点到自身距离为0）
将源点 s 插入优先队列 Q  // 优先队列按节点的p(v)值（距离估计）升序排序

// 迭代：逐步提取距离最小的节点并更新邻居距离
while 优先队列 Q 不为空 do
    u ← ExtractMin(Q)  // 提取Q中p(u)最小的节点u，该节点的最短距离正式确定
    for 每个节点 v ∈ 节点u的出邻节点（即所有边(u, v) ∈ A） do
        // 计算通过u到达v的临时距离：u的确定距离 + 边(u, v)的权重
        temp_dist ← p(u) + ℓ(u, v)
        if temp_dist < p(v) then  // 若临时距离比v当前的距离估计更小
            p(v) ← temp_dist  // 更新v的距离估计值为临时距离
            prev(v) ← u  // 更新v的前驱节点为u
            if v 未在优先队列 Q 中 then  // 若v尚未加入队列
                Insert(Q, v)  // 将v插入优先队列Q
            else  // 若v已在队列中
                DecreaseKey(Q, v)  // 减小v在队列中的优先级（更新为新的p(v)值）

// 输出结果：所有节点的最短距离（p(v)此时已为确定的最短路径长度）
return { p(v) | v ∈ V }
```
### 正确性

使用数学归纳法证明

### 时间复杂度
![Pasted image 20251203111118](无负边图的最短生成树/Pasted%20image%2020251203111118.png)


### 这种算法，再出现负权边时，将会出现错误
![Pasted image 20251203111338](无负边图的最短生成树/Pasted%20image%2020251203111338.png)

## 应用：单边机组调度
**核心需求：** 在上午 9 点到下午 5 点（9am-5pm）期间，每一小时都必须至少有一名司机在岗。
![Pasted image 20251221230715](无负环有向图的最短路径树/Pasted%20image%2020251221230715.png)
同时保持cost最小
我们还是将时间节点视为图的节点，将员工的时间跨度和工钱分别视为边和权重，那么问题就转化成：计算起点（早上九点）到终点（下午五点）的最短路径，直接迪杰斯特拉就行
当然，动态规划更好


## 练习：近似相等的权重

核心问题：

证明在以下两种特定情况下，寻找单源最短路径可以在线性时间（Linear-time，$O(V+E)$）内完成：

1. **情况一**：图中所有边的权重（edge weights）要么是 **1**，要么是 **2**。
    
2. **情况二**：图中所有边的权重都在区间 **$[1, 2]$** 之内。
- **逻辑原理**：在普通的 Dijkstra 中，我们需要排序来找到当前距离最小的点。但如果边权非常小且集中（如 1 或 2），我们不需要复杂的堆结构。
    
- **操作方法**：
    
    - 你可以创建几个“桶”（Buckets），分别代表不同的距离。
        
    - 因为边权最大只有 2，所以待处理节点的距离范围非常有限，你可以直接通过移动指针到下一个非空桶来提取最小值，而不需要进行 $O(\log V)$ 的堆维护。
### **1. 核心原理：桶的有限性**

在标准的 Dijkstra 算法中，我们总是从堆中取出 $dist$ 最小的节点。

- **发现**：如果图中所有边权都在 $[1, 2]$ 之间，那么当前正在处理的节点距离 $d_{min}$ 与图中任何其他待处理节点的距离 $d_{other}$ 之间的差距是非常小的。
    
- **结论**：在任何时刻，所有已发现但未处理的节点的距离值，只可能分布在极小的范围内（通常是 $d_{min}$ 到 $d_{min} + W_{max}$）。
    

### **2. 具体执行步骤**

假设边权只有 $1$ 和 $2$：

1. **创建桶**：准备一个数组，每个位置代表一个距离值。由于边权最大为 $2$，我们实际上只需要 **3 个循环利用的桶**（通过 $dist \pmod 3$ 来定位）。
    
2. **初始化**：
    
    - 将起点 $s$ 放入 `bucket[0]`。
        
    - 设置当前搜索指针 `cursor = 0`。
        
3. **循环扫描**：
    
    - **提取最小点**：从 `bucket[cursor % 3]` 中取出一个节点 $u$。如果当前桶空了，`cursor++` 移动到下一个桶。
        
    - **松弛邻居**：遍历 $u$ 的邻居 $v$：
        
        - 计算新距离 $newDist = dist[u] + weight(u, v)$。
            
        - 如果 $newDist < dist[v]$，更新 $dist[v]$，并根据 $newDist \pmod 3$ 的结果，将 $v$ 放入对应的 `bucket` 中。
            
4. **终止条件**：当所有桶都变为空时，算法结束。
    

---

### **3. 为什么它是线性的 ($O(V+E)$)？**

- **入队与出队**：每个节点只进入和离开桶一次。在桶数组中定位（取模运算）和插入（链表操作）都是 **$O(1)$** 的。
    
- **扫描开销**：由于边权有下界（$\ge 1$），指针 `cursor` 扫过空桶的总次数与最短路径的总长度成正比，但在这种受限边权下，它被分摊后依然是常数级的。
    
- **对比**：相比二叉堆的 $O(\log V)$，桶操作彻底消除了排序的时间，使得总时间复杂度仅取决于点和边的数量。




