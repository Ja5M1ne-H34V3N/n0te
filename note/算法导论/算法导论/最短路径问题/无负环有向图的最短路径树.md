# 贝尔曼-福特（BF）算法
BF算法算是一种动态规划，其子问题表示：限制步数能到达的最短路径
我们定义$d_k(v)$表示从原点到v点走最多k步的条件下的最短路径
若最多k步走不到某个点，则将最短距离设置为无限

所以在任意步数下，$d_k(v)$ 可以这样计算：
$$d_k(v) = \min{d_{k-1}(v),\min_{(u,v) \in A}{d_{k-1}(u) + l(u,v)}}$$
[具体过程在这里](note/算法/算法/基于图的算法/贝尔曼-福特（BF）算法.md)
是的，k步之内的最短路径就是下面的最小值：k-1步之内的最小值，和k-1步之内到u的最小值+u到v的边权重

## 负环检测
如果出现了负环，那意味着在使用贝尔福特满算法寻找最短路径时，负环相关的点会随着步数的无限增多而最短路径无限减小
所以我们的核心思想是：按理说在n步之内，就能确定所有节点的最短路径了，如果n + 1步仍然出现了更短的路径，则说明有负环，这个n的值通常取节点的个数，即最坏的情况，一个点的最短路径要经过其他所有点

## 算法实现
```plaintext
/ 迭代n-1次（n为节点数），更新所有边的距离估计
for k from 1 to n-1 do
    p'(v) ← p(v)  // 保存当前迭代前的距离估计值到p'（用于后续比较）
    for 每条边 (u, v) ∈ A do  // 遍历图中所有边
        if p(v) > p'(u) + ℓ(u, v) then  // 若通过u到达v的距离更短
            p(v) ← p'(u) + ℓ(u, v)  // 更新v的距离估计值

// 检测是否存在负环
for 每条边 (u, v) ∈ A do
    if p(v) > p(u) + ℓ(u, v) then  // 若仍能更新距离，说明存在负环
        return "图中存在负环（NC）"

// 若未检测到负环，返回所有节点的最短距离
return { p(v) | v ∈ V }
```

时间复杂度为O（mn），即节点数和边数的乘积


## 应用：网路路由
略

## 应用：套利机会
![Pasted image 20251222104418](无负环有向图的最短路径树/Pasted%20image%2020251222104418.png)
**给定 $n$ 种货币以及各对货币之间的汇率，是否存在套利机会？**
**备注：** 最快算法的价值极高！
### 图表内容翻译
该图展示了一个**有向图**，其中每个节点代表一种货币或资产，边上的数字代表汇率（转换率）：
- **节点符号：**
    - **$**：美元
    - **£**：英镑
    - **DM**：德国马克
    - **¥**：日元
    - **F**：法郎
    - **IBM**：IBM 股票
（**套利机会（Arbitrage Opportunity）** 是指在金融市场中利用资产在不同市场或不同形式下的**价格差异**，通过同时买入和卖出，从而获取**无风险利润**（或低风险利润）的可能性。在计算机科学和图论中，套利机会通常被建模为寻找图中的**负权环（Negative-Weight Cycle）**）
那直接进行贝尔曼福特搜索n次是否有负环就好了