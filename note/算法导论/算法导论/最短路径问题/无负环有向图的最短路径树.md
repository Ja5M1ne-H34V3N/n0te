# 贝尔曼-福特（BF）算法
BF算法算是一种动态规划，其子问题表示：限制步数能到达的最短路径
我们定义$d_k(v)$表示从原点到v点走最多k步的条件下的最短路径
若最多k步走不到某个点，则将最短距离设置为无限

所以在任意步数下，$d_k(v)$ 可以这样计算：
$$d_k(v) = \min{d_{k-1}(v),\min_{(u,v) \in A}{d_{k-1}(u) + l(u,v)}}$$
[具体过程在这里](note/算法/算法/基于图的算法/贝尔曼-福特（BF）算法.md)
是的，k步之内的最短路径就是下面的最小值：k-1步之内的最小值，和k-1步之内到u的最小值+u到v的边权重

## 负环检测
如果出现了负环，那意味着在使用贝尔福特满算法寻找最短路径时，负环相关的点会随着步数的无限增多而最短路径无限减小
所以我们的核心思想是：按理说在n步之内，就能确定所有节点的最短路径了，如果n + 1步仍然出现了更短的路径，则说明有负环，这个n的值通常取节点的个数，即最坏的情况，一个点的最短路径要经过其他所有点

## 算法实现
```plaintext
/ 迭代n-1次（n为节点数），更新所有边的距离估计
for k from 1 to n-1 do
    p'(v) ← p(v)  // 保存当前迭代前的距离估计值到p'（用于后续比较）
    for 每条边 (u, v) ∈ A do  // 遍历图中所有边
        if p(v) > p'(u) + ℓ(u, v) then  // 若通过u到达v的距离更短
            p(v) ← p'(u) + ℓ(u, v)  // 更新v的距离估计值

// 检测是否存在负环
for 每条边 (u, v) ∈ A do
    if p(v) > p(u) + ℓ(u, v) then  // 若仍能更新距离，说明存在负环
        return "图中存在负环（NC）"

// 若未检测到负环，返回所有节点的最短距离
return { p(v) | v ∈ V }
```

时间复杂度为O（mn），即节点数和边数的乘积
