总是做出当下看似最佳的选择
# 总览
和动态规划有点像，但是在动态规划的基础上有一个特定的选择答案的规则——在当前的情况下最好的选择，即使对以后不利
“即使”后的条件就说明了，贪心算法未必在原来的大问题上得到的结果是最好的，所以对于贪心算法来说，我们在使用它的时候，需要证明其正确性
# 活动选择问题
![Pasted image 20251119205709](贪心算法/Pasted%20image%2020251119205709.png)
兼容任务问题，前面的动态规划里就有类似的题目
对于这个问题来说，该往哪方面“贪心”呢，选择的标准是什么呢
我们选择当前规模的问题里最早结束的时间，因为这样，能给后续的任务留下更多的选择空间
所以我们的第一步还是按照结束时间从早到晚排列这些任务

## 后续子问题的选择
接下来，我们选择了一个任务a（当前结束时间最早的那个任务），接下来我们要考虑下一步的操作
首先，在选择任务a的基础上，所有何其冲突的任务就都不能选了，把这些任务删除后，再看剩下的任务，仍然按结束时间排序，选择结束时间最小的那个

## 证明算法的正确性
### 1.证明首个贪心选择后归纳
首先，我们还是找到最小规模（排序后的）问题也就是从排序后的事件1开始，对于这单个任务的问题来说，任务1是干活数量最多的选择，那么我们将总任务数量扩大到两个，三个，发现这几个任务都互相冲突，所以，对这个规模（1-3个任务）来说，选择任务1是正确的选择
在我们将问题规模扩大到四个及以上的时候，出现了和任务一不冲突的任务（任务4），我们不妨将前三个任务和之后的任务分成两个部分，对于前一个部分，最好的答案还是1，而对于整个问题的但你，我们可以直接用贪心单独计算结果就好
，其利用贪心算法选择是和前三个任务的答案是不冲突的（对于4之后的任务来说，其完成时间一定比4晚，而4前面的任务完成时间一定比4早，如果这个任务能和前三个任务冲突，他也就和第四个任务冲突了，那为什么不选择结束时间更早的任务4呢）
所以，就算规模扩大，这个算法还是最优的
### 2.拓展公共前缀，利用反证法证明
思路证明下面的内容：
如果不用别的算法而是使用贪心算法，得到的结果不会比别的算法差

所谓公共前缀，就是前面提到的先解决由前n个事件组成的小问题
拓展公共前缀，即问题规模从a扩大到更多事件a + b后，我们利用贪心得到的结果是n个事件是最多的情况
那么我们在解决前三个事件得到的答案是1 ，解决整个问题的答案的结果是1，4，8
那么利用反证法，假设对于前3个问题来说，不用贪心算法就能得到更好的结果，或者说，更好的结果不包含事件1，而是事件2或3，此时新的答案就是n + i个
那么问题来了，如果这真的是正确答案的话，将答案中的问题2/3换成问题1对答案没什么影响

## 时间复杂度
第一次排序：O（nlogn）
对于整个算法，可以用遍历一次来实现，同时每遍历到一个事件，都要比较其开始时间，所以时间复杂度是O（n）
总的时间复杂度：O（n）
# 最长递增子序列
![Pasted image 20251119214537](贪心算法/Pasted%20image%2020251119214537.png)
这是一些牌，接下来，这些排会按从左到右（即从红桃6到红桃Q的顺序）发给你
你要做的是，将这些牌放到你面前按堆放在一起，对于新来的牌，你有两种选择：
- 放在现有的牌堆的上面，要求放上去的牌的点数小于最上面那个牌的点数
- 新开一个牌堆，让当前的牌做最下面那个牌
现请设计一种分牌方案，要求最后得出的牌堆数最小
## 策略
采用贪心算法：对于一个新到来的牌，优先判断其能否放到最先创建的牌堆上，如果不行，则判断能否放到下一个创建的台阶上……如果所有牌堆都放不了，则新建一个牌堆
如果有多个牌堆能放牌呢？则选顶部面值最小的堆
对于寻找面值最小的堆，我们可以采用二分算法：根据放牌的规则，从左到右牌堆顶部的牌的面值是一次增大的（如果后一个堆顶比我小，为什么不干脆放到我的顶上呢），所以二分算法是可行的，同时因为这个顺序增大的性质，我们在选择一个牌堆放牌，意味着这个牌堆的前一个牌堆顶的值一定是比自己小的
对于这个题，最后的结果是这样的
![Pasted image 20251119215649](贪心算法/Pasted%20image%2020251119215649.png)
而且我们发现，这思路还帮我们找到了这些牌数值的最大递增子序列长度，就是这些牌堆的堆数：首先，对于这些牌堆，我们知道：新的牌堆产生的原因是当前牌大于当前上一个牌堆的牌顶，也就是说，后一个牌堆的牌底一定大于前一个牌堆的中的某一张牌，而且出现在它之后。假设n张牌，则存在第i 张牌 < 第j张牌（0< i < j <= n）的情况最多有4个，形成最长5个的递增子序列长度，也就是说，最长递增子序列的长度不会超过5
而贪心算法的规则是
### 实现算法
遍历每个卡牌，同时维护四个数组：
- \(c[1:n]\)：卡牌序列
- \(p[1:n]\)：卡牌所属堆的索引
- \(b[1:n]\)：卡牌的回溯指针（创建新堆时，在对应位置保存前一个牌堆的堆顶牌的索引，用于找到最长递增子序列）
- \(t[1:n]\)：堆顶卡牌的索引
```plaintext
k ← 1, p[1] ← 1, b[1] ← 0, t[1] ← 1;
for 卡牌 i = 2 到 n do
    if c[i] > c[t[k]] 则 {k ← k + 1, j ← k;} // 新建堆
    else 找到最小的堆 j ≤ k，使得 c[t[j]] < c[i]; // 二分查找
    p[i] ← j（记录这个牌对应堆的缩影）, b[i] ← t[j - 1]（更新这个牌的回溯指针，即当前牌堆中这个牌下面那个牌，其能加到这个）, t[j] ← i（新牌堆的堆顶索引为当前牌）;
```
### 时间复杂度
O（nlogk） k是堆的数量，不大于n


# 最小化最大延迟
你手头有一堆任务，每个任务都有一个自己的完成所需时间和DDL，现请安排这几个任务的完成顺序，让完成整个任务后最大延迟时间最小
延迟时间：若一个任务在ddl之后完成，则完成时刻到ddl的时间差是延迟时间
![Pasted image 20251120205636](贪心算法/Pasted%20image%2020251120205636.png)
上面是给出的数据和几种可能结果的实例

### 分析
对于两个任务来说：
我们可以采用多种方式作为贪心的标准，在这里我们选择先做ddl最早的任务因为这个完成后，就会给其他任务争取时间，导致ddl之后完成的任务堆积太多，让延迟时间最长的上限变得太大
实现方式就是将这些任务按结束时间升序排列就好
可以从下面的比较图理解
![[Pasted image 20251220185617.png]]

### 正确性
假设存在一种计算方法，让结果更小，即存在一种新的答案，这个答案中，存在相邻的任务，但结束时间晚的任务放在了前面
比如i 和 j任务，我们用t表示每个任务的运行时间，则其结束时间和DDL在下图表示：



那么无疑，延迟时间最长肯定发生在DDL更早但是安排得更晚的任务上
现在，我们尝试将这两个任务调换顺序：


是的，原本的边界就是最早的DDL + 最晚的完成时间的组合了，那么调换顺序，延迟时间只会更短

### 时间复杂度
简单排序，就是O（nlogn）

# 最大早到作业
还是有一些任务，这些任务默认按截止时间升序排序，每个任务都需要一定时间来完成
选择一种完成这些任务的方案，让在截止时间前完成的任务尽可能多
注：没有一定会推迟完成的任务

## 策略
摩尔霍奇森算法，贪心拒绝
问题已经是按ddl升序排列好了，我们维护一个选择的列表S，从第一个任务开始，挨个将其加入S并进行一下操作：
	判断这些作业是否可以全部按时完成：判断其耗时之和有没有超过最晚的DDL
	如果全能按时完成，则接着往后看下一个任务
	如果不能全按时完成，则抛去耗时最长的那个任务，接着重复上述操作
在遍历完所有任务后，S中的任务就是最好的安排

## 时间复杂度
涉及到排序，遍历过程中插入堆或搜索最大值：O（nlogn）
单次遍历，贪心拒绝：O（n）
总复杂度：O（nlogn）


# 赛马问题（田忌赛马）
给定两个已经排序的整数数组A，B（等长度），同时B的顺序是固定的，现要求对数组a重新排序，排序后的A的每一位数a都和B的对应位置的数b比大小
比较规则如下：
如果a > b 则A得一分
如果a = b 则A得0分
如果a < b 则A减一分

现设计一种排序方案，让A的得分最多

## 思路
联想到田忌赛马的思路，我们的目标就是筛选我方太小的数，去和敌方最大的几个数去比
维护双方数组的头（最弱）和尾（最强）指针，按以下优先级决策：
1. **下等马能赢吗？**
    - 如果**我方最弱 > 敌方最弱**：直接比，拿下一分。（稳赚）
2. **上等马能赢吗？**
    - 如果**我方最强 > 敌方最强**：直接比，拿下一分。（防止强马被浪费）
3. **都赢不了？**
    - **弃卒保车**：用**我方最弱**去消耗**敌方最强**。（虽然输了，但消耗了对方王牌，保护了我方主力）
**一句话总结**：  
**能赢就赶紧赢（无论是用弱马还是强马），赢不了就用最烂的马去兑掉对手最强的马。**
## 正确性
如果当前a的值比b的值大，那么直接比较，如果用其他数（一定是比a大的数）和b对应的值比较，就浪费点数了
同时，如果没有比较过的最弱的数和最强的数都劣势，则采用最弱的数和对方最强的数比，以实现浪费对方的点数

## 时间复杂度
单次遍历两个数组 O（n）



# 霍夫曼码和霍夫曼树
我们知道，用机器表示英文字符的方式是8位ascii码，而且我们知道，每个字母的常用程度不同
![Pasted image 20251124181805](贪心算法/Pasted%20image%2020251124181805.png)

我们就想到了，对于一个较长的英文句子，如果里面有很多e，那么有没有一种别的方案，能比来回使用101更节省空间？

## 策略
假设一部分的英文单词使用频率从低到高如下：
![Pasted image 20251124182423](贪心算法/Pasted%20image%2020251124182423.png)

那么，我们可以按下面的树，来生成不同长度的码来表示这些单词
![Pasted image 20251124182659](贪心算法/Pasted%20image%2020251124182659.png)
我们看到每个叶节点都是方块而且里面写了一个数字，这个数字是上表的对应单词顶上那个索引
比如最左边的10对应的就是O
接下来介绍几个定义：
码字（Codeword）：从根子节点到叶子节点路过的路径，比如到10是000，这就是在当前变长规则下，这个字母转换成二进制码的结果
码长（Codeword length）：某个字母对应的叶子节点的深度
我们发现，在这个树里，使用频率越高的单词码长约短

## 霍夫曼树
霍夫曼树是一种二叉树，每个叶节点对应一个字符，其使用频率是f，而所有字符 * 码长的和最小的树，我们称其为霍夫曼树
也就是$∑f(l)depthT​(l)$ 最小
其有一些性质：
- 对于几个相同深度的节点来说，他们呼唤位置不会影响结果
- 根据定义，我们知道：频率越高，深度越低，如果出现了违反这种规则的情况出现，我们就应该选择优化
- 霍夫曼树通常是满二叉树（除了叶子节点，其他节点都有两个子节点），如果出现二叉树不是满二叉树的情况，我们应该使用一些操作来优化这个树

现在问题来了，给定一些任意的字母（或者什么其他语言的）的使用频率，我们该按怎样的思路去构建这个树呢
## 策略
通过递归+贪心算法构建这棵树
我们首先将给的字母按照使用频率从低到高排序
接下来，我们先看一个生成好的霍夫曼树
![Pasted image 20251124185844](贪心算法/Pasted%20image%2020251124185844.png)
可见，两个使用频率最低的字母的叶节点，含有相同的父节点
那么我们可以将这两个叶节点和父节点看成一个大的叶节点，而其对应的频率是两个叶节点对应的字母的使用频率之和，而这两个合并的字母，称为元字母
那么现有的字母序列，就是一个元字母加上n - 2个正常字母，接下来要做的，就是在这个序列的基础上重复上面的操作来构建树
（非常巧妙喔，在递归的尽头，就是由n-1个字母组成的原字母和频率最低那个字母进行比较，这样频率最低的字母就自然放在深度最低的位置了）

那么新的问题来了，对于两个字母的频率之和，未必还是整个序列的最小频率，直接放回原数组还要重新排序，所以我们采用双数组法
队列1：存放原始的已经排好序的叶节点
队列2：存放新生成的节点
我们知道，队列2中的节点要么是在前一个元字母的频率基础上再加一个字母的频率得到的，要么是频率更大的两个字母的频率之和，无论情况如何，后加入队列2的元字母的频率大于先加入的，这样保证了队列的顺序

那么接下来，我们用具体流程来体现一下

