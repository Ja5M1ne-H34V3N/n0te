这两个策略的实现逻辑完全不同：**循环（RR）** 是基于“次数”的简单轮流，而 **加权公平排队（WFQ）** 是基于“虚拟时间”的复杂计算。

以下是它们的具体实现细节：

---

### 1. 循环/轮循 (Round Robin - RR) 的实现

RR 的实现非常像一个**转盘**。它的核心逻辑是维护一个“指针”，指向当前正在服务的队列。

#### 数据结构

- **多个队列**：假设有 NN 个队列 (Q0,Q1,...,QN−1Q0​,Q1​,...,QN−1​)。
- **当前指针 (Current Index)**：一个变量 ii，记录上一次服务的是哪个队列。

#### 算法流程

1. **检查**：调度器查看指针指向的队列 QiQi​。
2. **判断**：
    - 如果 QiQi​ **不为空**：取出队头的一个数据包发送。发送完毕后，指针移向下一个队列 (i=(i+1)%Ni=(i+1)%N)。
    - 如果 QiQi​ **为空**：直接跳过，指针移向下一个队列，立即重复步骤1。
3. **循环**：周而复始。

#### 伪代码逻辑
```
queues = [Q1, Q2, Q3, Q4]
current_index = 0
while True:

    # 获取当前队列

    queue = queues[current_index]

    if not queue.is_empty():

        packet = queue.dequeue()

        send(packet)

        # 发送完一个包，轮到下一家

        current_index = (current_index + 1) % 4

    else:

        # 队列是空的，直接跳过，轮到下一家

        current_index = (current_index + 1) % 4
```
#### 致命缺陷（为什么需要WFQ？）

RR 是按**包的个数**轮询的。

- 队列A全是 **1500字节** 的大包。
- 队列B全是 **64字节** 的小包。
- RR 轮流发：A发一个（1500B），B发一个（64B）。
- **结果**：A 占用的带宽是 B 的 **20多倍**。这并不公平。

---

### 2. 加权公平排队 (WFQ) 的实现

WFQ 的目标是模拟一种理想状态（流体模型），即让数据像水流一样，粗管子（高权重）流得快，细管子（低权重）流得慢。但数据包是离散的（不能切开），所以 WFQ 通过计算**“虚拟完成时间”**来实现。

#### 核心概念：虚拟完成时间 (Virtual Finish Time)

WFQ 会给每个到达的数据包打上一个“标签”，计算这个包**“如果是在理想的按权重分配带宽的环境下，应该在什么时候发送完”**。

#### 算法流程

1. **分类 (Classification)**：  
    数据包到达时，根据 IP 或协议被放入不同的队列（流）。每个队列分配一个权重 WW。
    
2. **计算标签 (Tagging)**：  
    对于到达队列 ii 的第 kk 个数据包，计算它的**虚拟完成时间** F(i,k)F(i,k)。  
    公式逻辑简化版：
    1. F(i,k)=max(上一个包的完成时间,当前时间)+权重包长度​
    
    - **包长度 (LL)**：包越大，发送所需时间越长，完成时间越晚。
    - **权重 (WW)**：权重越大（分母越大），计算出的数值越小，完成时间越早（优先级越高）。
3. **排序与调度 (Sorting & Scheduling)**：
    
    - 调度器查看所有非空队列的**队头**数据包。
    - **比较它们的“虚拟完成时间”标签。**
    - **选择标签数值最小**（即理论上应该最早发完）的那个包进行发送。

#### 举个例子（直观理解）

假设带宽是 10 bit/s。

- **队列A（权重 2）**：来了一个 100 bit 的包。
    - 虚拟耗时 = 100/2=50100/2=50 秒。
- **队列B（权重 1）**：来了一个 100 bit 的包。
    - 虚拟耗时 = 100/1=100100/1=100 秒。

**调度器决策**：  
比较 50 和 100。因为 50 < 100，所以**先发送队列A的包**。  
这就实现了“权重高，先发送”。

同时，如果：

- **队列C（权重 1）**：来了一个 **10 bit** 的超小包。
    - 虚拟耗时 = 10/1=1010/1=10 秒。

**调度器决策**：  
比较 A(50) 和 C(10)。因为 10 < 50，**先发送队列C的包**。
这就实现了“小包优先”（交互式流量优先）。

#### 总结 WFQ 的实现

它本质上是一个**基于优先级的系统**，但这个优先级不是固定的，而是**动态计算**的：

- **权重越大** →→ 优先级越高。
- **包越小** →→ 优先级越高。

调度器每次都要在所有队头包里找“虚拟完成时间”最小的那个，这通常需要使用**最小堆 (Min-Heap)**

等数据结构来实现高效查找。