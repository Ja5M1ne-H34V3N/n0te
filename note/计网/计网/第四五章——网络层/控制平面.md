我们还记得，网络层的功能是转发和路由，转发的功能通过数据平面实现了：通过转发表和流表，定义了本地数据平面的转发行为。而路由，即如何规划从起点到终点的路径，需要控制平面来解决

我们知道，路由器在数据平面上只负责根据转发表和流表进行数据的端口迁移，也就是说，只是把数据带到他的下一站。可是对于数据来说，他的最终目标是要到达对方主机才是，如果一帮邪门路由器瞎传，把这个数据在每个路由器之间都传了一次（假设这个数据的寿命够长），那得等到猴年马月才能到？~~真的……真的……绕了好大一圈啊~~
所以，对于每个路由器之间传输的速度不同，我们需要规划一个合理的从客户机到服务器的数据传输路线，保证数据以最短的路程或最小的开销来到达目的地
控制平面大概有两种：
#### 每路由器控制平面
每个路由器都有一个独立的路由算法组件来通过控制平面相互交互

![Pasted image 20251109125841](控制平面/Pasted%20image%2020251109125841.png)
#### 软件定义网络（SDN）控制平面
通过远端的控制器计算最合适的路径，并远程把对应的转发表安装在路由器里

![Pasted image 20251109130031](控制平面/Pasted%20image%2020251109130031.png)
具体的内容会在后面和大家提到
# 路由协议
路由协议的目标：通过路由器网络，从发送主机到接受主机确定优质的路径（路由）
所谓路径，就是从发送主机到接收主机所经过的路由器的序列
一个优质的路径，需要实现最低成本，最快速或最不拥塞
## 路由算法
我们知道，数据在互联网上每个路由器之间穿梭，而不同的相邻路由器，因为举例，性能等不同，传输的消耗和时间也不同，所以可以将这个体系抽象为：很多个节点用线连接，每个线都有不同的权重——也就是 图 这个数据结构

![Pasted image 20251109130734](控制平面/Pasted%20image%2020251109130734.png)
### 路由算法的分类
主要按两个维度分

![Pasted image 20251109130943](控制平面/Pasted%20image%2020251109130943.png)
#### 集中/全局 or 分散
##### 集中式路由选择算法
从全局视角来找最好的路径，我们会知道范围内所有的路由器节点和每个节点的边，根据这些已知条件计算最短路径
而我们把这种计算时知道完整的链路信息的算法称为**链路状态算法**
##### 分散式路由选择算法
和集中式相反，当我们仅仅知道每个节点到其相邻的节点的路径和开销，这种算法就能工作，通过迭代计算和相邻节点的信息交换，就能逐渐计算出到达某个目的地的节点的最好路径

#### 静态or动态
##### 静态路由选择算法
一般这种算法得到的结果不会轻易改变，除非人工修改了某个路径（边）的权重，通过计算得到了新的最好的路径
##### 动态路由选择算法
这种算法会根据网络流量负载和拓扑发生变化而及时改变路径。这种算法可以是周期式的运行，定期更新路径，或是在流量，拓扑发生变化时，算法被触发重新计算
### 几种路由算法
#### 链路状态选择算法（LS）
一种典型的集中式路由选择算法,采用迪杰斯特拉算法
这种算法能够实现找到到网络内每个路由器的最短路径，每个路由器都会知晓整个网咯的情况，并在自己内部计算出合适的通往某个路由器的路径，并配置转发表
[就是按照迪杰斯特拉算法进行计算最短路径的](note/算法导论/算法导论/最短路径问题/无负边图的最短生成树.md)自己点连接，不在这里赘述了
迪杰斯特拉算法是一种集中式的算法：我们需要知道全网的拓扑和链路成本
经过多次迭代后，能到达经过k个路由器的最终路径
##### 对这种算法的探讨
总共需要$$
n(n + 1) / 2
$$
次比较才能计算完整（每比较一轮，，确定一个最短节点。下一轮就少比较一个节点），时间复杂度是O（n）（基于堆数据结构的话，可能会降到nlogn）
##### 这种算法可能造成路由震荡
假如路由器之间的节点开销是由当时的流量决定的，而流量是实时变化的，可能根据流量的变化，让你按着最短路径在运行到一半时，突然告诉你新的最短路径怎么走，而且这个最短路径要求你从当前位置往回走……然后往回走了一，新的最短路径又让你调头……
假设数据每在路由器之间移动依次，所有路由器就进行一次最短路径运算，更新转发表

![Pasted image 20251109135335](控制平面/Pasted%20image%2020251109135335.png)
这是初始状态，我们计算出了一个从c到a的逆时针方向的最短路径，同时，各个路由器确定了这个路径，更新了自己边的流量情况

没错，边的情况更新了。逆时针方向添加了我们按最短路径走的流量，而顺时针方向还是清一色的0，所以在下次b路由器计算咱们的最短路径的时候，他就会提示我们按顺时针走回到a，然而这样，咱们的流量从逆时针到顺时针，逆时针方向又空了

![Pasted image 20251109135558](控制平面/Pasted%20image%2020251109135558.png)
于是a的计算结果又提示你往逆时针走……

![Pasted image 20251109135725](控制平面/Pasted%20image%2020251109135725.png)

对于这种问题的解决方案，我们可以强制开销不包含承载的流量，或确保所有的路由器不会同时运行这个算法
####  距离矢量算法（DV）
一种典型的分散式路由选择算法，基于[贝尔曼-福特（BF）方程（动态规划）](note/算法导论/算法导论/最短路径问题/无负环有向图的最短路径树.md)，其在网络中的运作过程还是要说到说到的
##### 具体过程
在这种方法中，所有路由器都只知道自己和相邻的距离，在初始状态下路由器记录自己的距离矢量（一个类似表格的东西，记录自己到其他路由器的距离）到任何路由器的距离是无限，到自己的距离是0

此时，这些路由器遵循着一个原则：当整合了其他路由器发来的转发表，或链路权重发生改变导致自己的转发表发生更改时，其一定会向链路上相邻的路由器发送自己的转发表作为更新

当运算开始 t = 0时，所有路由器向自己相邻的路由器发送自己的距离矢量

![Pasted image 20251109144331](控制平面/Pasted%20image%2020251109144331.png)
假设b收到了a发送的关于a她自己的距离矢量，那么他知道了：a 到 a的距离是0，a到b的边的权重是8，0 + 8就是8，而我这里记录的a到b的距离是无限，说明我得到了a到b更短距离的方案，为8，那么b会记录下来，当前根据已知信息，a 到 b的最短路径为8到自己的距离矢量上
此时，a到b的最短路径从无限改成8，即转发表发生改变，则b会将自己的转发表发给相邻的路由器，而其他的路由器也会这么做
在t = 0的状态下，所有的路由器均按这种思路计算完到所有的路由器的最短路径并更新完成后，进入t = 1，所有路由器接着向自己的邻居路由器发送距离矢量
路由器在接收到距离矢量之后并更新自己的矢量表后，重复上述计算更新过程，

迭代几次后，有的路由器已经接受了很多次的更新，转发表已经完善，某一次通过整合相邻路由器传来的矢量表后，发现自己的转发表不需要更新，则此次不会更新自己的矢量表，因为没有更新，也不会将矢量表发给其他路由器

之后，越来越多的路由器的转发表趋于稳定，逐渐不再向相邻路由器更新矢量表，在所有路由器停止转发后，整个网络趋向平衡，整个路由过程也算完成了

如果理解前面提到的贝尔曼福特方程的具体原理，我们不难理解：这个迭代次数不会超过n - 1次（n指路由器数量）
###### 链路成本改变的应对措施
问题较少的情况
如果在计算结束后，有一条链路成本改变（边的权重发生变化）

![Pasted image 20251109145405](控制平面/Pasted%20image%2020251109145405.png)
可见，y到x的链路成本从4变成了1
y会感知到这个问题，接着更新自己的距离矢量，发现表发生了更新，接着把这个矢量表发送给邻居x，z
z，x收到后，重新计算距离矢量，会根据情况更新自己的矢量表，并重复发送给邻居的过程，直到每个路由器的矢量表趋于稳定
y接收到z的距离矢量后，发现没有影响自己的距离矢量，则不再发送给别人

问题较大的情况
（下面的文字你可能读起来有点蠢，但这坨机器内想的就是这样的，描述能力有限，见谅）
如果边权重从4变成60

![Pasted image 20251109145821](控制平面/Pasted%20image%2020251109145821.png)
y直接到x的路径是60，而y知道z曾经和自己说过z到x的距离是5，即z到y的距离为1和yx修改前的权重4的和，所以y认定这种情况下，y先到z再到x（1 + 5 = 6）的方案是最快的，所以他更新了自己的距离矢量，并和yx距离变成60的消息一块发给z
z知道这个消息后，他知道按原来经过y再到x的方案距离变成了6 + 1 = 7，z选择先到y，再通过y的那条路径去找x，此时他认为自己到x的距离是7，因为和y有关，他接着更新自己的距离矢量，发给y
y发现z到x的新成本是7，而自己的路径是先到z，再按着z到x的路径到x，所以自己的路径也会更新为 7 + 1 = 8，他就会再更新自己的距离矢量，再把新的距离矢量发给z，接着z再更新发给y……他俩没完没了了

但是也不是无限次叠加，当几次迭代之后，z到x的路径更新为49并转发后，y知道了通过z到x开销50，更新后，再发给x，此时x发现经过y再到x（50 + 1 = 51），比自己直接到x（50）开销大，此时z将信息更新为50，而y的更新信息再来后，因为52 比50大，所以z不会再更新自己的矢量表，更不会转发，整个网络又稳定了……

确实稳定了，但是如果x到y 和x到z都突然变成9999呢，那链路有的受了，所以我们得研究一个办法解决一下这个问题

**解决方案：毒性逆转**
假如z要向y更新自己的距离矢量，那么发送前他会修改自己的距离矢量：凡是经过y才会实现最短到达的路由器，都会标注为无限，即无法到达
这种方法，对于三个或更多节点的情况将无法起作用
#### 两种算法的对比

![Pasted image 20251109151049](控制平面/Pasted%20image%2020251109151049.png)
各有各的好处和坏处，反正都得用
# ISP内部路由
一种互联网中自治系统内部的路由选择
我们之前对于路由的研究还是简单化，理想化的：所有的路由器都完全相同，网络结构是扁平的
可事实上并非如此
现实问题中，我们的目的地有数十亿个，而刚才的算法演示路由器数量两只手都数的过来，如果让那种规模的路由表保存在路由器中，对内存的消耗太太太太大，而且执行距离矢量算法的话，每个路由器都要传包含数十亿条信息的距离矢量，那这互联网也甭干别的了
同时，互联网是网络的网络，每个网络管理员还希望有权限控制自身网络内的路由，可能他管的这个区域的路由器就偏要按一种与众不同的算法路由，和大部队格格不入
## 互联网自治系统ASes
所以我们引出了自治系统（AS，或者称为域）的概念，将路由器组织进自治系统来解决上面两种问题。
自治系统内，又称域内，指的是统一统一AS下路由器之间的路由，再相同的域内，所有路由器都必须运行相同的域内协议。如果有路由器位于自身AS的边缘，拥有和其他AS中路由器连接的链路，我们称其为**网关路由器**

自治系统之间，也成为域间，指的是域之间的路由，对于网关路由器来说，它既执行自己域内的路由，也执行域间路由

转发表通过域内和域间路由算法共同配置，域内路由确定域内部目的地的转发表条目，就是自己内部怎么走。域间和域内路由共同确定外部目的地的转发表条目（对于一个域内路由器，得先由域内路由给自己送到网关路由器，再通过对应路由送到目的地所在域的网关路由器）

也就是说，域就像子网一样，让一群路由器变成一个整体，减少了宏观上运算需要顾及的规模
### 域间路由
域间路由也会对域内转发产生影响
假设一个主机想要向域外某个主机发送信息，那么问题就来了：对于一个域来说，可能有很多网关路由器，他们各自和不同的域的网关路由器相互连接这，到底该把信息发送给哪个网关路由器，才能带着这些信息前往正确的域呢

![Pasted image 20251109164644](控制平面/Pasted%20image%2020251109164644.png)
所以，一个域间路由，必须要了解哪些目的地可以通过哪个和自己直接连接的域到达，如果想去那个域，该先把信息往哪个域传输

![Pasted image 20251109164916](控制平面/Pasted%20image%2020251109164916.png)
## OSPF路由协议
OSPF是一种链路状态协议，使用洪范链路状态信息和迪杰斯特拉最低开销路径算法                        
应用这种路由器的协议，都会把自己的周边信息：我和谁相邻，权重是多少，发给其他所有在互联网内的路由器，当每个路由器都掌握了其他路由器的周边信息，就能根据算法计算出整个互联网的情况，接下来，这个路由器就可以根据迪杰斯特拉算法实现路由
![Pasted image 20251109165256](控制平面/Pasted%20image%2020251109165256.png)
### 工作流程
 **发现邻居 (Hello 包)**：  
路由器启动后，会向周围发送 Hello 包，以此来确认“谁在我的隔壁”。建立邻居关系。
**泛洪链路状态 (LSA Flooding)**：  
路由器将自己的连接情况（比如：我连着 A，成本是 10；连着 B，成本是5）打包成 LSA（链路状态通告），并发送给所有邻居。邻居收到后继续转发，直到全网所有人都收到这份通告。
构建数据库 (LSDB)：
每个路由器收集了全网所有的 LSA 后，就像拼图一样，拼出了整个网络的完整拓扑结构图，这叫做 链路状态数据库 (LSDB)。
计算最短路径 (SPF 算法)：
每个路由器以自己为中心（树根），使用 Dijkstra 算法（最短路径优先算法），计算到达网络中每一个目的地的最短路径。
衡量标准是“开销（Cost）”：通常基于带宽。带宽越大（路越宽），开销越小，路径越优。
生成路由表：
计算出的最佳路径会被放入路由表中，用于指导数据包转发。
#### . 区域 (Areas) 的划分

如果网络非常大，几千台路由器都在交换地图、计算路径，路由器的 CPU 会累死，数据库也会太大。  
OSPF 引入了**分层设计**：

- **骨干区域 (Area 0)**：核心区域，所有其他区域必须连接到这里。
- **非骨干区域 (Area 1, 2, ...)**：普通区域。
- **作用**：区域内部的细节不需要告诉其他区域，只汇总一条路由发出去。这大大减少了路由表的规模和计算压力。
![Pasted image 20251109165318](控制平面/Pasted%20image%2020251109165318.png)


# 互联网域间路由：BGP协议(边界网关协议)
这个协议主要处理域和域之间的路由问题，这个协议将这个世界上数以千计的ISP联系起来
BGP，即边界网关协议，所有域之间路由都遵守的协议
在BGP中，分组的发送目的地不是特定的IP，而是CIDR化的前缀（比如138.16.68/22），也就是一类固定位数的IP前缀相同的域，就是一个子网（确实符合域间路由的定义）.所以对于路由器来说，其转发表会有（x，I）的表项，x指前缀（如138.16.68/22），I指这个前缀对应的这个域的网关路由器的一个端口号
BGP允许子网向互联网其他部分通告自身存在和其可达性信息，也就是告诉整个互联网的其他子网，有这么一个子网，是可以到达的
同时，BGP还能实现确定到达某个前缀的域最好的路径，一个路由器可能保存了到达某个域的多个路径，那么路由器可以本地运行BGP路由选择过程来确定最好的那个路径
BGP协议为每个域提供了下面的能力：
- 能在相邻域通过eBGP(和下面的iBGP后面会解释)获取目的网络的可达性信息
- 根据得到的可达性信息和策略，规划好通往其他网络的路由
- 通过iBGP向AS内部所有路由器传播可达性信息
- 向相邻网络通告目的地可达性信息


注意：只要是涉及带了跨域的路由，都是BGP协议，对于网关路由器来说，其获得路由信息是从别的域的路由器的到的，这个过程就是ebgp，而域内的其他路由器从网关路由器得知别的域的路由，尽管这个信息是域内传播，但遵循的协议是ibgp协议，而不是自己域内路由的协议
## BGP协议报文的消息类型
### OPEN
打开远程BGP对等体（路由器）的TCP连接并对发送方进行认证
### UPDATE
通告新的路径或撤回旧的路径
### KEEPALIVE
在没有UPDATE信息时保持连接活跃，同时确认OPEN请求
### NOTIFICATION
报告前一条信息中的错误，或关闭连接

## BGP协议的传播方式
eBGP和iBGP是用这种方式连接的：

![Pasted image 20251110162052](控制平面/Pasted%20image%2020251110162052.png)
不同域的网关路由器之间，通过eBGP连接，在域内，路由器通过逻辑iBGP连接
所以，对于一个域的网关路由器来说，它同时运行eBGP和iBGP协议
在上面的例子中，1c 2a 2c 3a是网关路由器，其余的是域的内部路由器
那么对于域AS 1来说，如果其前缀是x，那么网关路由器1c就会向相邻的2a发送一个报文：AS1 x 即前缀x的域是存在的，并且位于AS1中。AS2的2a知道后，还会把这个信息在AS2的子网中传播AS1，x，让域内其他路由器都知道，然后，2c路由器会像外继续扩展这个信息，比如发送给相邻的AS3以下内容：AS2 AS1 x，意为前缀为x的域位于域AS1中，可以让分组先经过AS2，再发送到AS1.AS3收到后，还会把这个信息传给相邻的其他的域的网关路由器
在这个报文传递的过程中，路由器都是通过179端口的半永久TCP连接（或称其BGP会话）来交换信息的，其中的每条连接以及他们发送的报文，称为BGP连接，其中，在域之间的连接称为eBGP连接（外部EGP如1c和2a的连接），在一个域内部的连接称为iBGP连接（内部BGP连接，如1a 1d 1c之间的连接，对于BGP报文，从一个网关路由器收到后，还是要通过内网发给其他路由器的）
## 路径属性和BGP路由
通过上面的描述我们不难想到：对于真正复杂的路由器网络来说，一个路由器难免收到多条通往同一个前缀的子网的路径，，对于网关路由器来说，他会选择最好的路径，通告给域内其他路由器
对于前面提到的AS2 AS1 x 这类信息，我们称其为BGP路由，其组成部分如下：
- x指的就是前缀
- x前面的AS2 AS1是这个路由的BGP属性
	- 其中AS2 AS1表示了这个路由到这个域走过的路径，我们称其为AS-PATH，当AS3还要把这个信息传递给下一个域的时候，就会在这个属性前加上自己所在的域，构成AS3 AS2 AS1
	- 同时还有一个属性是NEXT-HOP。用来告知你：如果你想根据这个AS-PATH来向x传递信息，那么，你的下一步是把信息传给这个路由器的这个接口的ip地址
对于路由器来说，如果一个路由器有自己的导入策略，那么它可以根据自己的导入策略（比如，不经过AS2）来拒绝接收一个特定的路径（比如AS2 AS3 x）
AS策略还会决定是否向其他相邻AS通告这个路径
#### BGP填充转发表

![Pasted image 20251110170244](控制平面/Pasted%20image%2020251110170244.png)
![Pasted image 20251110171649](控制平面/Pasted%20image%2020251110171649.png)

## 确定最好的路由选择
所以，对于一台收到了很多路径的路由器，他知道能通过自己域内的很多网关到达目的地，哪一条路径才是最好的呢？
### 热土豆（烫手山芋）路由
山芋烫手，所以要尽快传给别人 在一个路由器收到多条路径后，他会计算从自己，到每条路径的出口网关路由器的开销，使用开销最小的那个路径，尽快把我的信息传出去，哪怕出了自己的域后，这条信息到达目的地还要饶一个远路
具体过程如下
![Pasted image 20251110172759](控制平面/Pasted%20image%2020251110172759.png)
![Pasted image 20251110173118](控制平面/Pasted%20image%2020251110173118.png)
对于这个网络来说，假如路由器1b想传递一个信息到AS3，面前有两条路径：通过网关1c到AS2再到AS3，和通过网关1d直接到AS3
对于1b来说，想要把信息传递给1d网关，还要把信息传递给1a或1c再传给1d，还要多传一次，没有直接把信息传给1c痛快，对加重域内传递信息的开销。所以，1b会采取第一条路径：通过网关1c到AS2再到AS3


总结一下BGP路由选择的步骤
![Pasted image 20251110221903](控制平面/Pasted%20image%2020251110221903.png)
# 为何采用不同的域内和域间路由
![Pasted image 20251110173511](控制平面/Pasted%20image%2020251110173511.png)

# SDN控制平面
## 软件定义网络（SDN）
和每路由器控制平面不同，软件定义网络会有一个在远端的控制器统一根据当前网络情况，计算合适的路由，并远程将路由对应的转发表发送给每一个管理的路由器
[在正式看这里之前，可以先再重温一下有关通用转发的内容](note/计网/计网/第四五章——网络层/数据平面.md)，我们会多次提到其中的定义

### 为什么采用SDN这样逻辑集中式的控制平面
更易管理：避免像每路由器控制平面一样发生震荡等意外，所有信息统一由控制台管理，避免路由器的配置发生错误，提高流量调度的灵活性
基于转发表（流表）的转发：中央可以集中计算转发表，然后分发给各个路由器，避免了所有算法在每个路由器中运行，各算各的的情况

基本的流量工程（之前学到的路由方法），通常只是死板地根据边的权重情况计算路由，如果运营商就想要信息按某个路径传播，则需要给每个路由器更新算法或更新某个边的权重，处理起来十分麻烦

### SDN的关键特征
![Pasted image 20251112193959](控制平面/Pasted%20image%2020251112193959.png)
#### 基于流的转发
SDN控制的交换机的转发工作，是基于应用，运输，网络层其中一个层面的头部的字段来决定转发去向的。SDN的工作是计算，管理和安装所有网络交换机的流表项，就像更新传统ip转发表一样
#### 数据平面和控制平面分离 控制平面功能位于数据平面交换机外部
上图可以看到，和数据转发有关的设备都在路由器之间进行，路由器的工作只是转发数据，而转发的依据是什么呢？是由集中的SDN那里经过计算下载来的，而负责掌管信息流向的SDN，并不处理到来的某个特定的数据报，也就是说，控制和数据是分开的

#### 可编程的网络
具体控制的实现，是由运行在SDN平面上的程序实现的，而编程的过程由人类实现，而控制又分为多种操作：如为信息传递规划路径，和控制是否接收这个数据等，他们来自不同的程序，甚至来自不同的设备，而这些设备通过api将操作指令发送给数据平面，不会冲突


## 以SDN的视角再看数据平面
像路由器这样的数据平面交换机
在硬件上实现了通用数据平面转发，而转发的依据——流表在控制器的监控下计算并安装
交换机提供API，使用和控制器通信的协议（如Openflow）

## 以SDN的视角看SDN控制器（硬件）
这个设备的作用就是维护网络的状态信息，他们通过分布式的系统实现，提供了容错和鲁棒性，提高总体性能
SDN控制器含有两方向的接口，分别是面向上层，也就是软件方面的网络控制应用，将其计算机额过应用到物理层面的API和面向下层，即发送流表信息给交换机的API

## 以SDN的视角看网络控制应用
这是控制的大脑，计算路由，访问控制等信息，通过面向SDN控制器API将计算结果传递到下层，实现控制数据平面
同时，这应用是非捆绑式的，可以由第三方提供软件，无需和下层的SDN硬件以及数据平面来自相同供应商
![Pasted image 20251112200339](控制平面/Pasted%20image%2020251112200339.png)

## OPENFLOW协议
OPENFLOW协议是交换机，上层SDN控制器以及其他涉及OPEN FLOW接口的设备通信交流使用的协议。这种协议运行在TCP之上端口号默认6653
### 从控制器流动到受控交换机的重要报文有：
![Pasted image 20251112200830](控制平面/Pasted%20image%2020251112200830.png)

### 从受控交换机到控制器流动的重要报文有：
![Pasted image 20251112200916](控制平面/Pasted%20image%2020251112200916.png)交互实例如下：
![Pasted image 20251112200951](控制平面/Pasted%20image%2020251112200951.png)
![Pasted image 20251112201002](控制平面/Pasted%20image%2020251112201002.png)
谷歌还定义了猎户座（Orion）SDN控制平面，有兴趣的可以了解
![Pasted image 20251112201251](控制平面/Pasted%20image%2020251112201251.png)![Pasted image 20251112201257](控制平面/Pasted%20image%2020251112201257.png)


# ICMP：互联网控制报文协议
是的，聊了好多主机的信息从发出主机出发到接收主机接收的细节了，终于聊到了主机和路由器之间信息传递的协议——ICMP协议
ICMP协议的消息承载于IP数据报中，主要传递的信息如下：
- 错误报告，当路由器找不到一个路径能到达主机发送信息的终点IP，就会 向主机发送这个报告
- 回声请求/回复，被ping使用，ping程序就是发送一个类型8编码0的报文(request)到指定主机，对方主机发送一个类型0编码0的回显回复(reply)
一个ICMP协议分为二个部分：类型，编码两个字段，不同类型，编码对应的功能如下：
![Pasted image 20251112202303](控制平面/Pasted%20image%2020251112202303.png)

## Traceroute 和 ICMP
Traceroute是一种程序，允许我们跟踪从一台主机到世界上另一台主机的路由，这个程序就是利用路由器发来的ICMP报文实现的
首先，这个程序会向目的地主机发送一系列的普通IP数据报，只是，ip是对的，但是UDP端口是不可达的端口，而且，这一系列数据报的TTL（寿命）从1开始递增的，这就有一个妙处：当第一个数据报传往第一个路由器的时候，由于数据报寿命已经归零，路由器不再传播，而是向源主机返回寿命归零的ICMP警告（上图的类型11编码0），当报文传递给源主机后，源主机通过分析定时器和往返时延，就分析出来了：原来从我这里到对方主机的链路上，第一个经过的路由器是这个路由器
接下来，寿命为2的路由器就会在第二个路由器处寿命归零，返回ICMP报文，再分析确认第二个路由器……最后，当udp报文到达目标主机，因为端口不可用，不会惊动对方主机还能向自己返回错误报告，整个路径的路由器都被确认下来了
![Pasted image 20251112203643](控制平面/Pasted%20image%2020251112203643.png)


# 网络管理与配置
燃尽了，先放ppt 日后踢我填坑
![Pasted image 20251112203759](控制平面/Pasted%20image%2020251112203759.png)![Pasted image 20251112203813](控制平面/Pasted%20image%2020251112203813.png)![Pasted image 20251112203821](控制平面/Pasted%20image%2020251112203821.png)![Pasted image 20251112203826](控制平面/Pasted%20image%2020251112203826.png)
![Pasted image 20251112203832](控制平面/Pasted%20image%2020251112203832.png)![Pasted image 20251112203838](控制平面/Pasted%20image%2020251112203838.png)![Pasted image 20251112203844](控制平面/Pasted%20image%2020251112203844.png)![Pasted image 20251112203850](控制平面/Pasted%20image%2020251112203850.png)
![Pasted image 20251112203854](控制平面/Pasted%20image%2020251112203854.png)
![Pasted image 20251112203900](控制平面/Pasted%20image%2020251112203900.png)
![Pasted image 20251112203906](控制平面/Pasted%20image%2020251112203906.png)