# æŠ½è±¡æ•°æ®ç±»å‹ï¼ˆADTï¼‰

æ‰€æœ‰è€…: H34V3N

[çº¿æ€§è¡¨](æŠ½è±¡æ•°æ®ç±»å‹ï¼ˆADTï¼‰/çº¿æ€§è¡¨%201e305a2041d280628bb4c2661b2a9244.md)

æŠ½è±¡æ•°æ®ç±»å‹ æ˜¯ä¸€ç§å°†ç»†èŠ‚ä¿¡æ¯å’Œæ“ä½œæ–¹å¼å°è£…çš„æ•°æ®ç±»å‹ ï¼Œåªèƒ½é€šè¿‡è®¾å®šå¥½çš„æ“ä½œæ–¹å¼ä¿®æ”¹ æŸ¥çœ‹æ•°æ®ã€‚ä½¿ç”¨è€…ä¸ç”¨çŸ¥é“å…¶èƒŒåçš„è¿ä½œå½¢å¼ï¼Œåªè¦ä¼šä»–çš„å„ç§æ“ä½œå°±èƒ½ä½¿ç”¨

æˆ‘ä»¬åœ¨å®šä¹‰ADTæ—¶ï¼Œä¼šä½¿ç”¨pythonè‡ªå¸¦çš„ABCåº“ï¼Œåˆ›å»ºä¸€ä¸ªæŠ½è±¡åŸºç±»ï¼Œè¿™ä¸ªåŸºç±»ä¸ä¼šè¢«å®ä¾‹åŒ–ï¼Œåªæ˜¯æä¾›ä¸€ä¸ªæ¨¡æ¿ï¼Œéœ€è¦æˆ‘ä»¬åœ¨åç»­å®šä¹‰æ•°æ®ç»“æ„æ—¶é‡è½½å‡½æ•°ï¼Œä»¥ç¡®å®šå…·ä½“çš„æ“ä½œ

æ‰“ä¸ªé€šä¿—çš„æ¯”æ–¹ï¼š

æˆ‘ä»¬ä»¥æ ˆçš„ADTå®šä¹‰ä»£ç æ¥è¯´

```python
from abc import ABC, abstractmethod
#åœ¨ Python é‡Œï¼Œabc æ¨¡å—ï¼ˆabc æ˜¯ Abstract Base Classes çš„ç¼©å†™ï¼‰æä¾›äº†åˆ›å»ºæŠ½è±¡åŸºç±»çš„å·¥å…·ã€‚è¯¥è¯­å¥å¯¼å…¥äº† ABC ç±»ä¸ abstractmethod è£…é¥°å™¨ã€‚
#å®ƒæ˜¯ Python ä¸­æ‰€æœ‰æŠ½è±¡åŸºç±»çš„åŸºç±»ã€‚è‹¥è¦å®šä¹‰ä¸€ä¸ªæŠ½è±¡åŸºç±»ï¼Œå¯è®©ç±»ç»§æ‰¿è‡ª ABC ç±»ã€‚æŠ½è±¡åŸºç±»æ— æ³•ç›´æ¥å®ä¾‹åŒ–ï¼Œå…¶ä½œç”¨æ˜¯ä¸ºå­ç±»è§„å®šå¿…é¡»å®ç°çš„æ–¹æ³•ã€‚
#abstractmethod è£…é¥°å™¨ï¼šæ­¤è£…é¥°å™¨ç”¨äºå°†æ–¹æ³•æ ‡è®°ä¸ºæŠ½è±¡æ–¹æ³•ã€‚æŠ½è±¡æ–¹æ³•åœ¨æŠ½è±¡åŸºç±»é‡Œä»…ä½œå£°æ˜ï¼Œæ²¡æœ‰å…·ä½“çš„å®ç°ä»£ç ï¼Œç»§æ‰¿è¯¥æŠ½è±¡åŸºç±»çš„å­ç±»å¿…é¡»å®ç°è¿™äº›æŠ½è±¡æ–¹æ³•
#å®šä¹‰ä¸€äº›æœ‰å…³æ ˆçš„åŸºç±»ï¼Œå…¶å…·ä½“æ“ä½œä¼šåœ¨ä¹‹åçš„ç±»å®šä¹‰é‡Œé¢é‡å†™ï¼ˆè‡³äºä¸ºä»€ä¹ˆè¿™ä¹ˆæï¼Œå› ä¸ºè¿™ä¸ªåŸºç±»åé¢çš„ä»£ç è¿˜è¦ç”¨awaï¼‰

class Stack(ABC):
    @abstractmethod
    def is_empty(self):
        pass
    @abstractmethod
    def peek(self):
        pass
    @abstractmethod
    def push(self, item):
        pass
    @abstractmethod
    def pop(self):
        pass
```

è§£è¯»ä¸€ä¸‹ï¼š

è¿™ä¸ªè™šåŸºç±»ï¼Œå®šä¹‰è¯­å¥ï¼Œä¼ è¾¾äº†ä»¥ä¸‹å†…å®¹ï¼š

â€œè¿™ä¸ªæ ˆå•Šï¼Œä»–ä¸€å®šè¦ èƒ½å¤Ÿè¿”å›æ˜¯å¦ä¸ºç©ºï¼Œè¾“å‡ºæœ€åä¸€ä¸ªå€¼ï¼Œèƒ½å¤Ÿå¢å‡å…ƒç´ â€

ç¼–è¯‘å™¨ï¼šâœğŸ»âœğŸ»âœğŸ»ğŸ˜­

æ‰€ä»¥ï¼Œè¿™å‡ ä¸ªåˆ°åº•æ€ä¹ˆå®ç°å‘¢ï¼Ÿ

å…¶å®ï¼Œé€šè¿‡åç»­å­¦ä¹ æˆ‘ä»¬çŸ¥é“ï¼Œæ ˆæ—¢å¯ä»¥ç”¨æ•°ç»„å®ç°ï¼Œä¹Ÿèƒ½å¤Ÿç”¨é“¾è¡¨å®ç°ï¼Œä½†æ˜¯ç”±äºç»“æ„å·®å¼‚ï¼Œæˆ‘ä»¬åœ¨å…·ä½“å®šä¹‰æ ˆæ—¶æ“ä½œä¸åŒï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å°±èƒ½é‡è½½è¿™äº›å‡½æ•°ï¼Œå†™ä¸€ä¸ªå…·ä½“çš„æ“ä½œæ–¹å¼

å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

```python

from abc import ABC, abstractmethod
class Stack(ABC):
    @abstractmethod
    def is_empty(self):
        pass
    @abstractmethod
    def peek(self):
        pass
    @abstractmethod
    def push(self, item):
        pass
    @abstractmethod
    def pop(self):
        pass
#å®šä¹‰æ•°ç»„æ„æˆçš„æ ˆ
class ArrayStack(Stack):
    def __init__(self, initial_capacity=10):#åˆå§‹åŒ–æ“ä½œï¼Œé€šè¿‡ç»™initial_capacityèµ‹å€¼ æ¥å†³å®šæ ˆçš„å®¹é‡
        if initial_capacity < 1:
            raise ValueError("Initial capacity must be >= 1")
        self.stack = [None] * initial_capacity
        self.top = -1#å®šä¹‰åˆå§‹åŒ–åæ ˆé¡¶çš„ä½ç½®
    def is_empty(self):
        return self.top == -1
    def peek(self):
        if self.is_empty():#åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
            raise IndexError("Peek from empty stack")
        return self.stack[self.top]

    def push(self, item):
        if self.top == len(self.stack) - 1:  # åˆ¤æ–­è¿™ä¸ªæ ˆæ˜¯å¦å·²æ»¡
            new_capacity = len(self.stack) * 2  # å¦‚æœæ»¡äº† æˆ‘ä»¬å°±æ–°å»ºä¸€ä¸ªæ›´é•¿çš„æ ˆæ•°ç»„
            new_stack = [None](æŠ½è±¡æ•°æ®ç±»å‹ï¼ˆADTï¼‰/çº¿æ€§è¡¨/æ•°ç»„å’Œé“¾è¡¨%201dc05a2041d28023bd66c9332325196d.md)ï¼Œå¾€å›çœ‹
            for i in range(len(self.stack)):
                new_stack[i] = self.stack[i]
                self.stack = new_stack
            # è¿›è¡Œæ ˆæ·»åŠ æ“ä½œ
        self.top += 1#ç§»åŠ¨æ ˆé¡¶
        self.stack[self.top] = item

    def pop(self):
        if self.is_empty():  # åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
            raise IndexError("Pop from empty stack")
        item = self.stack[self.top]
        self.stack[self.top] = None#ä¿®æ”¹å½“å‰ä½ç½®çš„æ•°æ® æ”¹æˆnone æ„ä¸ºåˆ é™¤
        self.top -= 1#ç§»åŠ¨æ ˆé¡¶
        return item
  #å®šä¹‰é“¾è¡¨æ„æˆçš„æ ˆ
  class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node
class LinkedStack(Stack):
    def __init__(self):
        self.top = None
#return true if list is empty
    def is_empty(self):
        return self.top is None

# return top element of stack
# throws EmptyStackException if stack is empty
    def peek(self):
        if self.is_empty():
            raise IndexError("Peek from empty stack")
        return self.top.data

    def push(self, item):
        self.top = Node(item, self.top)

    def pop(self):
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        item = self.top.data
        self.top = self.top.next
        return item
#ä¸€äº›æ“ä½œ
if __name__ == "__main__":
    s = LinkedStack()
    s.push(1)
    s.push(2)
    s.push(3)
    s.push(4)

    while not s.is_empty():
        print("Top element is", s.peek())
        print("Removed the element", s.pop())
 
```

ç»§æ‰¿å’Œå¤šæ€ï¼ˆï¼‰