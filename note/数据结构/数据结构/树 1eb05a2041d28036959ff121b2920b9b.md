# 树

所有者: H34V3N

一种不是线性的数据结构

有的时候，我们存储一些数据不需要线性的存储，而是由层级，有层次地每层存多个数据，数据有明确地从属关系

生物上有界门纲目科属种，数据结构这有树

![image.png](树/image.png)

大概长这样，就像我画的唐的一b的思维导图

或者这样，我们在[二分搜索](https://www.notion.so/1d605a2041d28043bb9dc9f91ef0055f?pvs=21)时看见的

![image.png](复杂度%20和大O记法（ing）/image.png)

# 优势：

这种数据结构，能够清晰明确地体现数据间地从属关系

### **树的应用**

- **二叉搜索树**：（图示二叉搜索树结构 ）
- **表示计算机文件系统**：（图示文件系统树的一部分 ）
- **路由算法（最短路径计算）**：（图示网络路由相关 ）

还有更多应用？

- 用于二叉搜索的有序存储
- 决策树
- 表达式树

# 树的结构：

树顶端的元素成为根（root）

紧邻根下方的是根的子节点（children of the root）

再往后是孙节点，以此类推

最底层的节点是叶节点（leaves）

某个节点的祖先节点就往上捋，从父节点开始捋到根

~~按祖宗十八代那个顺序来就行~~

树的高度：某个节点节点和根节点隔了几层、

（深度的最大值是叶节点的深度）

![image.png](树/image%201.png)

一个树是一个有限的非空元素集合，其中一个元素被当作根

一个根也能引出多个子树

树的高度：这个树的层数

节点的度：一个节点的子节点数量（注意，是子节点，就是自己下面离自己最近的那一层的子节点数）

数的度：树中节点的度的最大值

（如果一个树的度是2，我们称其为二叉树（binary tree），若是3，则称其为三叉树）

树和图不同，图可以成环，叶和根也可以有联系，但树不行，树的从属是单向的。

# 二叉树（binary tree）：

如果一个树的度是2，我们称其为二叉树（binary tree）

其实，二叉树都指向子树，这个树要么为空（叶节点啥都没指），要么是二叉树，也就是说，每个数的节点的度是0 到 2

所以，我们能理解到，二叉树可以递归地来定义，树是一种递归结构

数和图有啥区别

如果一个二叉树有 h 层，则其最少的节点数量就是 h，此时每个非0度数节点的的度数都是 1

最多节点的数量是2^h - 1，此时每个非0度数节点的度数都是2

我们称其为满的二叉树（full binary tree）

## 二叉树节点的排序：

二叉树的每个节点都有自己的序号，排序规则：从上到下，从左到右。如图

![image.png](树/image%202.png)

我们默认根节点的序号是1

i节点的父节点的序号是 i // 2（整除）

对应的，节点i的子节点的序号是2i（左边那个）和2i + 1（右边那个）

## 完全二叉树：

完全二叉树是一棵二叉树，除了最底层可能有例外（最底层从左到右填充 ），其他层都完全填满。

![image.png](树/image%203.png)

如图，除最底层外全部填满，最底层从左到右填充，符合完全二叉树定义

![image.png](树/image%204.png)

如果没有最左边的4 不实现从左到右填充，就不是完全二叉树

## 满二叉树：

满二叉树所有层数都是所在层数能包含的节点的最大值，除了最低的那一层的节点外，所有节点的度都是2

### 辨析

![image.png](树/image%205.png)

满但不完整、

![image.png](树/image%206.png)

不满也不完整

![image.png](树/image%207.png)

完整，但不满

<aside>
💡 满二叉树和完全二叉树是对二叉树的定义，不在其他树上定义

</aside>

## 用数组实现二叉树：

由于二叉树可以把每个节点用序号表示，加上我们已经知道父子节点的对应关系，我们就可以用数组来表现出二叉树

如果我们有一个树，其有n层，那么，我们准备的数组的长度应是n到2^n - 1（因为对于一个n层的树来说，其最多有2^n-1个节点）

我们仍然用满二叉树的编号方式来给里面的元素编号，即从上到下，从左到右

那么每个节点的编号就是其在数组中的下标

![image.png](树/image%208.png)

比如这个

但是这个树可能不是完整的，我们就假设其已经被补成完整的了

**右斜二叉树**

![image.png](树/image%209.png)

对于这种一直在往右加节点的二叉树，我们称其右斜二叉树

所以，我们先将其补成完整二叉树

![image.png](树/image%2010.png)

可见，为了保持编号的有序性，我们要补充很多节点，在数组的实现上，也需要给这些本就不存在的节点空出位置

在这种纯右的情况下，有n个节点就相当于n层，需要一个2^n - 1长的数组实现，相当浪费空间

如果对于一直偏左的完全二叉树来说，最后一层补一个节点就行了，这样就很舒服

## 用链表实现二叉树：

一个链表节点，保存本节点的数据，和自己下面两个子节点的地址

![image.png](树/image%2011.png)

代码实现：

```python
class BinaryTreeNode:
    def __init__(self, element=None):
        self.element = element  #本节点保存的值
        self.leftChild = None #左子节点的地址
        self.rightChild = None   #右子节点的地址

```

我们对二叉树的操作有：

- 输出树的高度
- 输出节点数
- 确定两颗二叉树是否相同
- 展示二叉树
- 计算二叉树表示的算术表达式的值
- 获得表达式的前中后缀形式

## 二叉树的遍历：

三种遍历方式都是左节点先比右节点被访问，区别是根节点什么时候被访问，分为先中后序遍历

![image.png](树/image%2012.png)

先序遍历 ： 从根 到左 再到右 ： 12453

代码：

```python
def pre_order(self, t):
    if t is not None:
        self.process(t)  # 访问时具体的操作，直接访问当前节点
        self.pre_order(t.leftChild)#当前节点访问完了，就跳到自己左边的节点，看看有没有左节点
        self.pre_order(t.rightChild)#如果当前节点没有左节点/左节点都被访问过了，就跳到右节点
        #如果右节点也没有/也被访问过了，就说明节点到头了，开始往回倒
```

前序遍历的规则是先根，再左，再右

我们从根节点开始，先访问他的左节点，此时，我们将这个左节点视为根节点，继续访问他的左节点，直到某个根不再有左节点……

此时，我们访问这个根节点的右节点，将这个节点视作根节点，重复根 - 左- 右的访问顺序

这是一个递归过程

in:  a * b + c D / e *

post : a b * c + d e / *

中序遍历：从左到根，再到右：42513

代码：

```python
def in_order(self, t):
    if t is not None:
        self.in_order(t.leftChild)    # 直接访问左节点
        self.process(t)      # 访问时的操作
        #先访问左节点，之前不进行任何操作
        self.in_order(t.rightChild)   # 访问右节点

```

后序遍历：左到右再到根：45231

代码：

```python
def post_order(self, t):
    if t is not None:
        self.in_order(t.leftChild)    # 直接访问左节点访问到最左边
        self.in_order(t.rightChild)   # 如果当前节点的左边没有了，就访问右节点
        self.process(t)#如果左边没有 右边也没有，就说明到头了，开始执行访问时的操作
```

层序遍历，按从上到下，从左到右遍历：12345

代码：

```python
	while (t != null)
	{
	    process t and put its children on a FIFO queue;
    	remove a node from the FIFO queue and call it t;
	}
#最简单的一集
```

总结：

很多二叉树的操作都在遍历二叉树时进行，我们在遍历每个节点时，也访问了这个节点

## 二叉树的应用：

### 算术表达式的实现

算术表达式，无非就三个东西：操作符（加减乘除），操作数（数），定界符（各种括号）

中缀表达式：

就是运算符写在俩操作数之间的式子，比如1 + 2，2 * 3这些

那么，对于这种算式，我们就能使用二叉树思想在机器上实现：

我们让叶节点保存操作数，其他高一层的节点保存操作符

运算的顺序（乘除优先也好，括号也好）都用二叉树的层数实现，作为数据的子节点和作为运算符的当前节点，构成一个带括号的小算式

![image.png](树/image%2013.png)

我们发现，如果用中序遍历取得数据并计算，就是表达式的内容

(((a + b) *（c -d）) / (e + f))

我们发现，除了节点保存操作数之外，别的节点都是符号，这样通过中序遍历就能写出中缀表达式

计算机本身很方便运算非中缀的表达式，因为无论是前缀或后缀，只有一个方向的运算免去了运算顺序这一个麻烦的话题，从左一路算到右（或一路算到左）都很好实现([用栈就行](抽象数据类型（ADT）/线性表/栈%201e305a2041d2808d9641d33b08c75924.md))

中缀表达式a + b 改成后缀表达式a b+

a * b + c((a ***  b) +c)→ a b * c +

a + b * c(a + (b * c)) →a b c * +

中缀怎样转化成后缀表达式？

我们随便拿一个中缀表达式：a + b + c

其后缀表达式形式为：a b + c +

![image.png](树/image%2014.png)

我们发现，将中缀表达式按二叉树形式写出来，再用后序遍历写下每个节点的内容就是后缀表达式的形式

同理，按前序遍历，就是前缀表达式

[前后缀表达式的计算方式在栈里](抽象数据类型（ADT）/线性表/栈%201e305a2041d2808d9641d33b08c75924.md)

## 由单一遍历构建二叉树

我们发现，如果给我们一段数据a，b，要求使用一种遍历方式在这些树中读出a。b（按顺序）在不同的遍历顺序下，每种树的构建方式都不止一种，遍历方式之间树也不同

![image.png](树/image%2015.png)

如图 我们想按一种遍历方式得到 a b这个顺序的数据，四种遍历方式都有两种二叉树画法

左到右 上到下依次是前中后层序遍历

如果我们按两种遍历方式读取一个二叉树（必须包含一个中序遍历），那其结构一般是可以确定的

### 具体的构建思路：

我们已知一个树，接下来给你两种遍历方式得到的结果，画出分叉方式

前序遍历：a b d g h e i c f j

中序遍历：g d h b e i a f j c

整体思路：我们记住前面两个节点遍历出AB的图是什么样的，在具体题目中将所有节点分成2到三个整体，通过比对怎样排列这2（3）组数据能让两种遍历方式得到同一个东西

首先，根据前序（或后序）遍历的性质，整个树的根节点应该是遍历结果的第一个（最后一个）节点，本题目是a

因为中序遍历是按照左-根-右的顺序来便利的，我们就知道，在中序遍历的结果中，在a左侧的都是左子树的内容，在a右侧的都是右子树的内容

![image.png](树/image%2016.png)

此时我们发现，尽管顺序不同，左子树和右子树的节点内容在前序遍历的结果里也是挨着的（cfj在一块，bdgheic在一块）

先研究左子树，根据前序遍历的性质，我们知道了b是这个子树的根，那么用同样的方法，我们就可以将左子树再分组

![image.png](树/image%2017.png)

接着看b的左子树，我们发现，还可以按照桐言的方法分

接下来按同样的方法接着分

![image.png](树/image%2018.png)

不过，我们能发现，b的右子树只有两个节点，这两个节点在前序遍历和中序遍历的结果中都是挨着的

根据前序遍历的性质，我们能知道，e是下面的根节点，此时，i在e的右面，我们就知道i是e的右节点

![image.png](树/image%2019.png)

a的左子树看完了，看右子树fjc这些，还是根据前序遍历找到右子树的根节点，发现是c

此时 fj 都在c的左边，说面fj都在c的左子树里，c没有右节点

根据前序遍历的顺序，树fj的根节点是f j在f的右侧，整体树的形状都已经找到了

![image.png](树/image%2020.png)

其他的练习（图能点）

方法总结：

这种题目一定会给出中序遍历的结果，剩下一个结果在其他三种遍历方式中选出一个，这三种遍历方式的特点是，一定能找到树或子树的根节点，我们就把根节点带入中序遍历的结果，将中序遍历的结果以这个根节点为界限左右分开，就找到了其子树，这样一步步分开，就能把整个树画出来

![image.png](树/image%2021.png)