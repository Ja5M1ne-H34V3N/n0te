# CS425 Database Organization 核心知识点复习

---

## 1. Introduction (Chapter 1)

### 1.1 为什么需要数据库系统 (DBMS)?

- **文件系统的缺陷 (Drawbacks of File Systems):**
    
    - **数据冗余与不一致 (Redundancy & Inconsistency):** 相同数据存储多处，修改一处可能导致不一致。
        
    - **访问困难 (Difficulty in Access):** 需要编写特定程序来检索特定数据。
        
    - **数据隔离 (Data Isolation):** 数据分散在不同格式的文件中。
        
    - **原子性问题 (Atomicity Problems):** 系统崩溃可能导致部分更新（例如转账只扣了钱没存钱）。
        
    - **并发访问异常 (Concurrent Access Anomalies):** 多人同时操作可能导致数据错误（如两人同时读取余额并取款）。
        
    - **安全性问题 (Security Problems):** 难以控制不同用户对不同数据的访问权限。
        

> [!INFO] 通俗解释
> 
> 文件系统就像把钱藏在家里不同的抽屉里，容易丢（原子性差）、容易记错（不一致）、找起来麻烦（访问困难）、家里人同时拿钱会搞乱账目（并发问题）。
> 
> DBMS就像银行，统一管理，安全、准确、支持多人同时操作。

### 1.2 数据抽象与视图 (View of Data)

- **物理层 (Physical Level):** 描述数据实际上是如何存储的（数据结构、文件组织）。
    
- **逻辑层 (Logical Level):** 描述存储了什么数据以及数据间的关系（如表结构）。
    
- **视图层 (View Level):** 仅向特定用户展示数据的特定部分（隐藏细节，保障安全）。
    

> [!NOTE] 物理数据独立性 (Physical Data Independence)
> 
> 修改物理存储结构（如换硬盘、改索引）不需要修改逻辑结构（应用程序不用重写）。这是数据库设计的核心目标之一。

### 1.3 数据库语言

- **DDL (Data Definition Language):** 定义数据库模式（Schema），如 `CREATE TABLE`。DDL 编译器会生成数据字典（Data Dictionary/Metadata）。
    
- **DML (Data Manipulation Language):** 访问和操纵数据，即查询语言（Query Language），如 `SELECT`, `INSERT`。
    

---

## 2. Relational Model (Chapter 2)

### 2.1 关系结构 (Structure)

- **Relation (关系):** 即一张表 (Table)。
    
- **Tuple (元组):** 表中的一行 (Row)。
    
- **Attribute (属性):** 表中的一列 (Column)。
    
- **Domain (域):** 属性允许取值的集合（如整数、字符串）。要求是**原子性 (Atomic)** 的，即不可再分。
    
- **Schema (模式):** 关系的逻辑结构，如 `instructor(ID, name, dept_name, salary)`。
    
- **Instance (实例):**某一时刻数据的具体快照。
    

### 2.2 键 (Keys)

- **超键 (Superkey):** 能唯一标识元组的一个或多个属性的集合。
    
- **候选键 (Candidate Key):** 最小的超键（没有任何真子集是超键）。
    
- **主键 (Primary Key):** 被数据库设计者选中用来主要标识元组的候选键。
    
- **外键 (Foreign Key):** 一个关系中的属性引用另一个关系的主键。
    

> [!INFO] 通俗解释
> 
> - **超键**: 只要能把人区分开的属性组合都是（例如：“身份证号”是，“身份证号+名字”也是）。
>     
> - **候选键**: 最精简的区分方式（去掉“名字”，光靠“身份证号”也够区分，所以“身份证号”是候选键）。
>     
> - **主键**: 官方认证的身份证。
>     
> - **外键**: 在你的成绩单上写着你所属的“班级ID”，这个ID是班级表的主键，用来把成绩单和班级信息连起来。
>     

### 2.3 关系代数 (Relational Algebra)

这是一种过程化查询语言，包含六大基本操作：

1. **选择 (Select, $\sigma$):** 选出满足条件的**行**。即 SQL 中的 `WHERE`。
    
2. **投影 (Project, $\Pi$):** 选出指定的**列**。即 SQL 中的 `SELECT`。
    
3. **并 (Union, $\cup$):** 两个集合合并。
    
4. **集合差 (Set Difference, $-$):** 在表A中但不在表B中的行。
    
5. **笛卡尔积 (Cartesian Product, $\times$):** 表A的每一行与表B的每一行组合。
    
6. **重命名 (Rename, $\rho$):** 给结果表或属性改名。
    

> [!TIP] 扩展操作：自然连接 (Natural Join, $\bowtie$)
> 
> 自动匹配两个表中同名的列，并保留匹配的行。本质是：笛卡尔积 + 选择（同名列相等） + 投影（去重同名列）。

---

## 3. Introduction to SQL (Chapter 3)

### 3.1 基础查询结构

SQL

```
SELECT A1, A2      -- 投影 (Projection)
FROM r1, r2        -- 笛卡尔积 (Cartesian Product)
WHERE P            -- 选择 (Selection)
```

- **Distinct:** `SELECT DISTINCT name` 去除重复。
    
- **String Operations:** `LIKE` 操作符，`%` 匹配任意子串，`_` 匹配任意一个字符。
    
- **Order By:** `ASC` (升序，默认), `DESC` (降序)。
    

### 3.2 集合操作 (Set Operations)

- `UNION`: 并集（自动去重）。`UNION ALL` 保留重复。
    
- `INTERSECT`: 交集。
    
- `EXCEPT`: 差集。
    

### 3.3 聚合函数 (Aggregate Functions)

- 函数：`AVG`, `MIN`, `MAX`, `SUM`, `COUNT`。
    
- **Group By:** 将结果集按某列分组，聚合函数分别作用于每组。
    
- **Having:** 对**分组后**的结果进行筛选（`WHERE` 是对分组前筛选）。
    

> [!EXAMPLE] 例子
> 
> 找出平均工资超过 80000 的部门：
> 
> SQL
> 
> ```
> SELECT dept_name, AVG(salary) 
> FROM instructor 
> GROUP BY dept_name 
> HAVING AVG(salary) > 80000;
> ```

### 3.4 嵌套子查询 (Nested Subqueries)

- **Set Membership:** `IN`, `NOT IN`。
    
- **Set Comparison:** `> SOME` (大于部分), `> ALL` (大于所有)。
    
- **Empty Relations:** `EXISTS` (子查询非空), `NOT EXISTS`。
    
- **Uniqueness:** `UNIQUE` (测试子查询结果是否有重复元组)。
    

### 3.5 数据库修改

- `DELETE FROM table WHERE ...`
    
- `INSERT INTO table VALUES (...)`
    
- `UPDATE table SET col = val WHERE ...`
    
    - 可以使用 `CASE` 语句进行条件更新。
        

---

## 4. Intermediate SQL (Chapter 4)

### 4.1 连接类型 (Join Types)

- **Inner Join:** 只保留匹配的元组。
    
- **Left Outer Join:** 保留左表所有元组，右表不匹配的填 NULL。
    
- **Right Outer Join:** 保留右表所有元组。
    
- **Full Outer Join:** 保留两边所有元组。
    

> [!INFO] 通俗解释
> 
> - **Inner**: 只有男女朋友都有的人才能参加的情侣派对。
>     
> - **Left Outer**: 所有男生都能来，有女朋友的带女朋友，没女朋友的旁边带个空气（NULL）。
>     

### 4.2 视图 (Views)

- `CREATE VIEW v AS <query>`。
    
- **虚表 (Virtual Relation):** 不存储物理数据，只存储查询定义。
    
- **物化视图 (Materialized Views):** 实际存储查询结果，需要定期刷新，用于提升性能。
    

### 4.3 完整性约束 (Integrity Constraints)

- `NOT NULL`: 不能为空。
    
- `UNIQUE`: 值必须唯一（允许 NULL）。
    
- `CHECK(P)`: 必须满足谓词 P（如 `salary > 0`）。
    
- **Referential Integrity (参照完整性):** 外键约束。
    
    - `ON DELETE CASCADE`: 级联删除。如果父表删除了记录，子表引用的记录也自动删除。
        

### 4.4 授权 (Authorization)

- `GRANT <privilege> ON <relation> TO <user>`。
    
- `REVOKE`: 收回权限。
    
- **Roles (角色):** 创建一组权限集合，然后赋给用户（如创建 "Instructor" 角色）。
    

---

## 5. Advanced SQL (Chapter 5)

### 5.1 编程语言访问 SQL

- **JDBC/ODBC:** 应用程序通过 API 连接数据库。
    
    - **SQL Injection (注入攻击):** 永远不要用字符串拼接构建 SQL，要用 `PreparedStatement` (参数化查询) 来防止黑客通过输入恶意代码操作数据库。
        
- **Embedded SQL:** 在宿主语言（如 C）中直接嵌入 SQL。
    

### 5.2 函数与过程 (Functions & Procedures)

- 允许将业务逻辑存储在数据库中。
    
- **Table Functions:** 可以返回一张表的函数。
    

### 5.3 触发器 (Triggers)

- 当数据库发生修改（Insert/Update/Delete）时自动执行的一段代码。
    
- **用途:** 维护复杂的一致性约束、审计日志。
    
- **风险:** 复杂的级联触发可能导致不可预知的后果或性能问题。
    

### 5.4 高级聚合 (Advanced Aggregation)

- **Ranking:** `RANK()`, `DENSE_RANK()` (排名不跳号), `ROW_NUMBER()`。
    
- **Windowing:** 在不压缩行数的情况下进行聚合计算（如移动平均）。
    
    - `OVER (PARTITION BY ... ORDER BY ...)`
        
- **OLAP (Online Analytical Processing):**
    
    - **Pivot/Cross-tab:** 数据透视表。
        
    - **Cube/Rollup:** 多维数据分析。`ROLLUP` 生成层级汇总，`CUBE` 生成所有组合的汇总。
        

---

## 6. ER Model (Chapter 6-3)

### 6.1 基本概念

- **Entity (实体):** 现实世界的对象（如 Student）。
    
- **Entity Set:** 相同类型实体的集合。
    
- **Relationship (联系):** 实体间的关联。
    
- **Attributes:** 简单属性、复合属性（地址拆分为省市区）、多值属性（电话号码）、派生属性（年龄由生日计算）。
    

### 6.2 约束 (Constraints)

- **映射基数 (Mapping Cardinality):**
    
    - **1:1 (One-to-One)**
        
    - **1:N (One-to-Many):** 一个老师指导多个学生。
        
    - **N:1 (Many-to-One):** 多个学生归一个老师。
        
    - **M:N (Many-to-Many):** 学生选课。
        
- **参与度 (Participation):**
    
    - **Total (全参与):** 双线表示。例如每个 Loan 必须属于一个 Customer。
        
    - **Partial (部分参与):** 比如不是每个 Instructor 都是 Advisor。
        

### 6.3 弱实体集 (Weak Entity Sets)

- 没有足够属性形成主键，必须依赖于**强实体集 (Identifying Entity)** 存在。
    
- 用双边矩形表示。
    
- 分辨符 (Discriminator): 结合强实体的主键来唯一标识弱实体（如 Course是强实体，Section是弱实体，Section依靠 sec_id + course_id 区分）。
    

### 6.4 扩展特性

- **Specialization (特化):** 自顶向下（Person -> Student, Employee）。
    
- **Generalization (泛化):** 自底向上。
    
- **Aggregation (聚合):** 将一个关系（及其关联实体）视为一个高层实体，以便参与另一个关系。
    
    - _通俗解释:_ “项目”和“指导老师”是一个关系，现在要给这个关系打分（Evaluation），就需要把它们打包成一个聚合实体，然后再与“评分”建立联系。
        

---

## 7. Normalization (Chapter 7)

### 7.1 为什么需要规范化？

- 避免**冗余**和**更新异常**（Update Anomalies）。
    
- **Lossless Decomposition (无损分解):** 分解后的表通过自然连接能完全还原，不产生伪造元组。核心判定：$R_1 \cap R_2 \rightarrow R_1$ 或 $R_1 \cap R_2 \rightarrow R_2$（公共属性必须是其中一个表的超键）。
    

### 7.2 函数依赖 (Functional Dependencies, FD)

- $X \rightarrow Y$: 如果两个元组在 X 上相同，则在 Y 上也必须相同。
    
- **平凡依赖 (Trivial):** $Y \subseteq X$。
    
- **闭包 (Closure, $F^+$):** 给定 F 能推导出的所有 FD 的集合。使用 **Armstrong公理** (自反律、增广律、传递律)。
    

### 7.3 范式 (Normal Forms)

1. **1NF:** 所有属性都是原子的（不可再分）。
    
2. **2NF:** 在 1NF 基础上，非主属性完全依赖于主键（消除部分依赖）。
    
3. **3NF:** 在 2NF 基础上，消除传递依赖（非主属性不依赖于其他非主属性）。
    
    - 定义：对于所有 $\alpha \rightarrow \beta$，要么是平凡的，要么 $\alpha$ 是超键，要么 $\beta$ 是候选键的一部分。
        
4. **BCNF (Boyce-Codd NF):** 更加严格的 3NF。对于所有 $\alpha \rightarrow \beta$ (非平凡)，$\alpha$ 必须是超键。
    
    - _通俗解释:_ 每个决定因素都必须是候选键。
        
5. **4NF:** 处理**多值依赖 (Multivalued Dependencies, MVD)**。消除非平凡的 MVD（$X \twoheadrightarrow Y$），除非 X 是超键。
    

> [!SUMMARY] 设计目标
> 
> 理想状态是 BCNF + 无损连接 + 依赖保持。但 BCNF 不一定能保持依赖，3NF 总是可以保持依赖且无损。

---

## 14. Indexing (Chapter 14)

### 14.1 基本概念

- **Index:** 加速数据检索的数据结构。
    
- **Search Key:** 用于查找的属性。
    
- **Dense Index (稠密索引):** 每个搜索码值都有一个索引项。
    
- **Sparse Index (稀疏索引):** 只有部分搜索码值有索引项（要求文件按搜索码排序）。
    

### 14.2 B+-Tree Index

- 数据库最常用的索引结构。
    
- **特点:** 平衡树，所有叶子节点在同一层；非叶子节点存索引，叶子节点存指针/数据；叶子节点通过链表相连（支持范围查询）。
    
- **操作:**
    
    - **Insert:** 节点满了就分裂 (Split)，中间值上移。
        
    - **Delete:** 节点空了就合并 (Merge) 或借位。
        
- **优点:** 即使数据量巨大，树的高度也很低（通常3-4层），IO次数少且稳定。
    

### 14.3 Hashing

- **Static Hashing:** 桶 (Bucket) 数量固定。问题：数据增长后会有溢出链，性能下降。
    
- **Dynamic Hashing (Extendable Hashing):** 桶数量随数据增长动态变化。
    

### 14.4 其他索引

- **Bitmap Index:** 适用于基数小（Distinct values少）的列（如性别、状态）。使用位操作（AND/OR）加速多条件查询。
    
- **Spatial Index (空间索引):** 如 **R-Tree**，用于存储多维数据（地图、矩形区域）。
    

---

## 17. Transactions (Chapter 17)

### 17.1 ACID 属性

- **Atomicity (原子性):** 要么全做，要么全不做。
    
- **Consistency (一致性):** 事务前后数据库必须保持一致状态（如转账前后总金额不变）。
    
- **Isolation (隔离性):** 并发事务互不干扰。
    
- **Durability (持久性):** 一旦提交，数据永久保存（即使断电）。
    

### 17.2 调度与可串行化 (Schedules & Serializability)

- **Serial Schedule (串行调度):** 事务一个接一个执行，没有重叠。
    
- **Serializable (可串行化):** 并发执行的结果等于某个串行执行的结果。
    
    - **Conflict Serializability (冲突可串行化):** 如果交换非冲突指令能变成串行调度。
        
    - **测试方法:** 构建优先图 (Precedence Graph)。如果图**无环**，则冲突可串行化。
        
- **Recoverable Schedule (可恢复调度):** 如果 Tj 读了 Ti 写的数据，Ti 必须在 Tj 之前提交。
    
- **Cascadeless Schedule (无级联调度):** 避免因一个事务失败导致后面一连串事务回滚。要求：仅读取已提交的数据。
    

### 17.3 隔离级别 (Isolation Levels)

SQL 定义了四种隔离级别（由弱到强）：

1. **Read Uncommitted:** 允许读未提交数据（脏读）。
    
2. **Read Committed:** 只读已提交数据（防止脏读）。
    
3. **Repeatable Read:** 同一事务内多次读取结果一致（防止不可重复读）。
    
4. **Serializable:** 最高的隔离级别，完全串行化执行（防止幻读）。
    

> [!INFO] 并发控制 (Concurrency Control)
> 
> 为了保证隔离性，通常使用 Locking (锁) 或 Timestamps (时间戳) 协议。这部分将在后续章节（Chapter 16，本复习资料未包含）详细展开，但基础概念在此章引入。