# 关联数据库的设计

所有者: H34V3N

# 一些避免信息重复导致冗余的方案

加入我们设定一个有关学校选课信息管理的数据库，存储着以下内容:

课程（课程ID，课程名称，上课时间，学时，学分，地点）、

学生（学号，姓名，年级，学院）

我们为了方便记录每个学生的选课信息，维护了一个关系：

选课（学生学号，课程ID，课程名称，上课时间，学时，学分，地点）

可见，这个关系保存了每个学生对应其选择的课程，但是这样的数据库是有缺陷的：假如根据学校要求，某个课程的上课时间，地点会在这个学期永久更改，那么对于这个数据库来说，不但需要修改整个”课程“这个关系里，属性“上课时间”，“地点”的值，也要修改”选课“这一关系里，所有和这一节课程有关的元组里，对应属性的值，修改起来不仅很麻烦，如果出现遗漏，还会导致信息保存不统一的严重后果

这种现象就是前文提到过的信息重复，或冗余

## 分解Decomposition

我们依据前文的例子，为了避免这种信息重复，我们可以将这个不完美的“选课”关系分解成两个模式：

学生选课（学号，课程名称）

课程（课程ID，课程名称，上课时间，学时，学分，地点）

吔，这样就不会导致信息重复了

当然，怎样拆分某个关系的属性，拆分成多少关系都是可以的，但是，不恰当的拆分可能会导致属性之间的联系不再紧密，难以体现数据库分析信息的功能，所以，在实际操作中，还需要我们具体情况具体分析。

### 有损分解lossy decompositions和无损分解Lossless Decomposition

在了解具体的分解的操作之后，接下来我们对”课程“这一关系再分解一次

课程表（课程ID，课程名称）
课程信息（课程名称，上课时间，学时，学分，地点，）

如果按照这种分发，则会出现问题：

某个学院的某个课程，分别在两个不同的时段安排了课程，也就是说，相同名称和内容的课程，因为时间不同，是按照两个不同的id，保存在两个元组里面的，在分解课程这个关系后，我们观察课程信息和课程表应该存储的内容，发现相同名称的课程存在两个元组，对于课程信息，一个课程名称对应了两个不同的时间，对于课程表，一个课程名称对应了两个不同的课程ID，检查数据库的人可能会对这种一对多的乱象一头雾水，可见，不恰当的分解方式得到的结果，无法准确呈现出数据对应的事实。我们称这种分解为**有损分解**，不会产生这种问题的分解称为**无损分解**

在实际应用中，我们应该极力避免有损分解的出现

### 无损分解的准确定义

设 **R** 是一个关系模式，且 **R1** 与 **R2** 构成 **R** 的一个分解——即把 **R、R1、R2** 看作属性集合，有 **R = R1 ∪ R2**。若用两个关系模式 **R1** 与 **R2** 取代 **R** **不会丢失信息**，则称该分解为**无损分解**。如果存在某个 **r(R)** 的实例，其中包含的信息在改用 **r1(R1)** 与 **r2(R2)** 的实例来表示时**无法**表达，则发生了**信息丢失**。

就是说，我们将R的内容映射成R1和R2两个内容，再将R2和R1按照原本的规则映射回一个关系，如果得到的关系是R，则是无损的分解，如果得到了一个内容大于R（即R的真超集），则说明分解是有损的

## 规范化理论Normalization Theory

我们会用通用的方法，来将一个模式规范为良好的，不会产生信息重复，又方便检索信息的模式

# 使用函数依赖进行分解Decomposition Using Functional Dependencies

前面提到过，我们使用数据库对现实世界进行建模，所以根据实际情况，这些数据的类型，范围往往拥有限制（如学生ID，姓名等）。如果一个关系的示例满足所有这些现实世界的约束，我们就称这个示例为合法示例，当关系的实例全部合法，那么数据库的实例也合法

## 关系模型中的相关符号的约定

- 一般，我们使用希腊字母（如α）表示属性集，用大写罗马字母表示关系模式，用r（R）表示关系r的模式为R
    
    并不是所有的属性集合都是模式，希腊字母表示的属性集可以不是模式，用大写罗马字母表示的
    
- 我们用K表示属性集的超键，其针对特定的关系模式，我们称K是R的超键
- 我们用小写字母表示关系名，关系名通常有实际意义，不是瞎起的。假设关系名是r，我们用r（R）同时指代关系和其模式
- 若语境明确，我们可以只用关系名r指代实例

## 键和函数依赖Keys and Functional Dependencies

### 超键superkey

一组属性，其组合起来可以标识关系中的一个元组

我们在[介绍关联模型](关联模型/介绍关联模型%2026f05a2041d280fdb4d1e44fd9487bf8.md)时提到过这个概念，现给出其完整定义：

给定关系r（R）若R的子集k满足：在任意合法实例中，任意两个元组t1 t2都满足t1≠ t2,我们就称，K时r（R）的超键，也就是说，在所有实例里，所有元组在属性集K上没有取相同的属性值

### 函数依赖Functional Dependency, FD

函数依赖，是关系模型数据库里的一个约束

对于关系r（R）中的任意实例，若其中一部分元组的α属性都相同，同时β属性也相同，我们就称：这个实力满足函数依赖：α → β

如果整个关系的每一个合法实例都满足函数依赖α → β，则我们称这个函数依赖在整个关系上成立

例：

假设有下面的一个关系

course（course_ID,course_name,instructor,credict）对于一个课程来说（比如高数），我们通常一个课程有多个老师教学，所以对于不同老师教学的相同课程，都要用不同的元组来标记。但是无论是哪个老师教的，我们都确定：只要课还是这个课，那给的学分就是一样的，也就是说，课程名称和学分构成了函数依赖

### 函数依赖的用途

- 检查关系实例是否满足给定的函数依赖集 F。
- 指定合法关系集合的约束，只考虑那些满足 F 的实例。若某关系模式 r(R) 的实例均满足 F，则称 F **在 r(R) 上成立**。
- 当所有的关系都满足这个依赖时，我们称其**平凡依赖**

### 闭包closure

当一组函数依赖在关系上成立时，我们能根据这些依赖推导出新的依赖，我们就称这些可由现有依赖推导出的依赖为**闭包，表示为F⁺**

## 无损分解和函数依赖

我们可以通过函数依赖，来判断分解是不是属于无损分解

假设一个关系集是R，将其分解为R1和R2

R的现有依赖集是F，若其闭包包含下面两种依赖：

- R₁ ∩ R₂ → R₁
- R₁ ∩ R₂ → R₂

则分解是无损的

# 范式Normal Forms

关系数据库模型中含有多种范式，来进行规范

## Boyce-Codd范式BCNF

### 定义

给定一组函数依赖F，如果F⁺中有α→β的函数依赖，当下面的两个条件至少有一个满足时，我们称关系模式R处于BCNF

- α→β是平凡依赖
- alpha是模式R的超键

构成数据库的每一组关系模式都处于BCNF时，我们称整个数据库处于BCNF

### BCNF和依赖保持