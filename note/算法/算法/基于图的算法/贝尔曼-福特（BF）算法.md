迪杰斯特拉算法无法处理边权重存在负的最短路径问题，但是BF算法能够解决
和迪杰斯特拉算法一样，当前点到自己点的距离是0，无法在规定步数内到达的节点距离视为无限
那么我们不断拓宽疆土，从出发点开始，找到到每个点的最短路径
假设我们从s点出发，寻找到其他节点的最小路径
![Pasted image 20251109141245](../../../计网/计网/第四五章——网络层/控制平面/Pasted%20image%2020251109141245.png)
接下来，我们搜索s一步能到达的节点，即a ，e。距离分别是3，4，都小于开始记录的“无限”。所以更新a e的距离，为我们计算的距离
![Pasted image 20251109141327](../../../计网/计网/第四五章——网络层/控制平面/Pasted%20image%2020251109141327.png)
接着，我们寻找s不超过两步能到达的节点，也就是a，e与其一步能到达的节点（b，d）
我们发现，a经过边12到b的距离是15，小于无限，从而把b的距离改为15，但是我们又发现
，e经过边5到b的距离是9，小于15，所以最短的路径是s->e->b，所以替换b的距离为9，以此类推
![Pasted image 20251109141530](../../../计网/计网/第四五章——网络层/控制平面/Pasted%20image%2020251109141530.png)
接着，找s走不到三步就能到达的节点……以此类推
知道这样扩展n（所有节点数） - 1次，此时，我们相当于完成了从出发点开始，计算所有可能的路线到达每个节点的距离，并为每个距离比较出了最小值
此时，如果我们再扩展一次，即计算经过n步之内，到达的节点的最短距离，一共n个节点，经过n步意味着最后一步一定会到达一个之前路过的节点。如果最后回到了s点，而且发现距离变成了负数，比初始的0小，则我们称这个图有**负环**
