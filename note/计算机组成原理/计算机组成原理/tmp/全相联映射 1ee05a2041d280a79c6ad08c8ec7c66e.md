# 全相联映射*

所有者: H34V3N

全相联映射下，主存中的各个数据块都能放置到cache的任意数据块中主存地址和cache数据块地址是一对多的关系，这时，主存的数据块在存储时会存入任意一个cache中空的行，只有cache被填满后，才会发生替换

~~就好像我放东西有任何讲究，哪里有空位就插哪里，反正到头也会把位置填满，完全没有繁文缛节~~

这样的存储方式脱离了任何讲究，不会拘泥于任何对应的规则，好处是有空位就能放，能充分利用cache内存，但坏处是获得对应的位置信息比较复杂，查找成本较高

但是，怎样记录存储的数据的位置呢？

在主存的数据存入cache中，我们还会载入并存储有关位置的标记信息，主要包括有效位，主存块地址，脏数据标志位，淘汰计数等信息，我们把这样的标记信息整合在一起，称为cache行或cache槽，如图

![image.png](全相联映射/image.png)

具体的查找方式如前文cam的读取类似，当你输入位置信息，cache的所有行行比较信息，如果有符合的行，就输出对应行的信息

## 硬件实现：

![image.png](全相联映射/image%201.png)

在这里，我们先了解一下相联存储器的容量：

我们假设这个cache一共有八行，每个块大小四W，假设主存长度是9位，其内地址被划分为（tag，offset）两个部分，偏移量offset用了2位，那么主存块地址tag就是7位 对于这个结构我们发现，offset偏移量正好有两位二进制，表示四个数据，即对应cache某个块里面的四个字中的哪个字

接着，地址块的数据被输入到cache八路并发比较地址值，如果地址在判断过程中比较结果相同且比较值是1，所有行生成输出信号hit，各行的比较结果输出乘=成行选通信号，连接到输出的控制端，控制端根据信号输出对应数据

cpu读取数据的过程

假设目前的cache是空的，cpu需要访问主存中以下位置的数据：

![image.png](全相联映射/image%202.png)

我们以1f为例

将1f变成二进制0000111 11（七位tag和两位offset）

再分别变成十进制就是（7，3）