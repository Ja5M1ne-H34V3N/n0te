## L11: Minimum Spanning Tree (最小生成树)

### 练习：近似树的线性时间算法

> [!question] 题目 (Slide 14)
> 
> 给定一个连通图，其中边数 $m \approx n$（接近树结构），在线性时间内找到最小生成树 (MST)。

> [!check] 答案与思路
> 
> 知识点: #MST #Kruskal #CycleProperty
> 
> 1. 由于 $m \approx n$，图中的环非常少。
>     
> 2. 可以使用 **DFS/BFS** 找到图中所有的环。
>     
> 3. 根据 **Cycle Property (环属性)**，在任何一个环中，权重最大的边一定不在 MST 中。
>     
> 4. 找出所有环中权重最大的边并将其删除，剩下的即为 MST。
>     
> 5. 时间复杂度为 $O(m+n)$，即线性时间。
>     

### 练习：MST 的唯一性

> [!question] 题目 (Slide 22)
> 
> 如何测试 MST 是否唯一？如果所有边权都不相同，MST 是否唯一？

> [!check] 答案与思路
> 
> 知识点: #MST #Uniqueness
> 
> 1. **结论:** 如果所有边的权重都 **互不相同**，则 MST 是 **唯一** 的。
>     
> 2. **测试算法:**
>     
>     - 运行 Kruskal 算法。
>         
>     - 当处理权重为 $w$ 的边时，如果有多条边权重相同，且它们连接的连通分量结构使得选择其中一条并不影响连通性（即都是连接两个不同的分量），则需要检查是否这些边构成了“交换”的可能性。
>         
>     - 更严谨的方法：对于每条不在 MST 中的边 $(u, v)$，如果它的权重等于 MST 中 $u$ 到 $v$ 路径上最大权重边的权重，则 MST 不唯一。
>         

### 练习：动态 MST (Dynamic MST)

> [!question] 题目 (Slide 30)
> 
> 给定图 $G$ 的 MST，当某条边的权重 (1) 减小 或 (2) 增加 时，如何更新 MST？

> [!check] 答案与思路
> 
> 知识点: #MST #DynamicGraph
> 
> 1. **权重减小:**
>     
>     - 如果该边 $(u, v)$ 已经在 MST 中，无需操作。
>         
>     - 如果不在 MST 中，该边与其在 MST 中连接 $u, v$ 的路径形成一个环。根据 Cycle Property，找出该环中权重最大的边。如果原 MST 路径上的某条边权重大于更新后的边，则删除该大边，加入新边。
>         
> 2. **权重增加:**
>     
>     - 如果该边不在 MST 中，无需操作。
>         
>     - 如果该边 $(u, v)$ 在 MST 中，删除它会将树分裂成两个分量。根据 Cut Property，在所有连接这两个分量的“非树边”中，找到权重最小的一条边重新连接这两个分量。
>         

### 练习：单对最小-最大路径 (Single-pair min-max path)

> [!question] 题目 (Slide 34)
> 
> 给定 $s$ 和 $t$，设计一个 $O(m+n)$ 时间的算法找到 $s-t$ 的路径，使得路径上最大边权最小（Bottleneck Path）。

> [!check] 答案与思路
> 
> 知识点: #MST #BottleneckPath #AlgorithmDesign
> 
> - **方法 1 (基于 MST):** 计算 MST（如果是稀疏图或权值已排序，甚至可以是修正的 Prim/Kruskal）。在 MST 上 $s$ 到 $t$ 的路径即为最小-最大路径。
>     
> - **方法 2 (二分查找 + BFS/DFS):** 题目提示使用“二分查找”是针对 $O(m \log W)$ 的思路，但要在线性时间 $O(m+n)$ 内完成，通常假设边权已排序或使用 **中位数查找 (Median Finding)** 算法。
>     
>     - 找到边权的中位数 $w_{med}$。
>         
>     - 仅使用权值 $\le w_{med}$ 的边运行 BFS/DFS。
>         
>     - 如果 $s, t$ 连通，则递归在较小的一半边中找；否则缩把连通分量缩点，在较大的一半边中找。这类似线性时间找第 k 小元素的逻辑。
>         

### 练习：最小权重反馈边集

> [!question] 题目 (Slide 37)
> 
> 描述并分析一个快速算法来计算给定加权图的最小权重反馈边集 (Feedback Edge Set)。(反馈边集是指移除后使图无环的边集合)。注意：这里通常指无向图，如果是无向图，问题等价于最大生成树。

> [!check] 答案与思路
> 
> 知识点: #MST #MaxSpanningTree
> 
> 1. **定义:** 移除边集 $F$ 使图无环 $\iff$ 剩下的边构成一个最大生成森林（对于连通图是最大生成树）。
>     
> 2. **目标:** 要使移除的边权重和最小 $\iff$ 保留的边权重和最大。
>     
> 3. **算法:**
>     
>     - 将所有边权取负（或直接改变比较符号）。
>         
>     - 运行 Kruskal 或 Prim 算法找到 **最大生成树 (Maximum Spanning Tree)**。
>         
>     - 图中所有不在最大生成树中的边，即构成最小权重反馈边集。
>         

---

## L7: Greedy Algorithms 1 (贪心算法 I)

### 练习：加油站问题 (Refueling stops)

> [!question] 题目 (Slide 23)
> 
> 从武汉到北京，沿途有加油站。油箱容量为 $C$。目标是停靠次数最少。

> [!check] 答案与思路
> 
> 知识点: #Greedy
> 
> - **策略:** "Go as far as you can" (能跑多远跑多远)。
>     
> - **算法:** 当到达一个加油站，如果油量不足以到达**再下一个**加油站（或者不足以到达终点），则在此加油。
>     
> - 即：在当前位置能到达的所有加油站中，选择最远的那一个作为下一跳（或者理解为：直到油不够去下一站了，才在当前站加油）。
>     

### 练习：纸牌接龙与 LIS (Solitaire game)

> [!question] 题目 (Slide 26-42)
> 
> 纸牌游戏规则：大牌不能压小牌。求最少堆数。这与最长递增子序列 (LIS) 有什么关系？

> [!check] 答案与思路
> 
> 知识点: #Greedy #LIS #PatienceSorting
> 
> - **策略:** 对于一张新牌，将其放到**最左边**一张能够放置（即牌顶值 $\ge$ 新牌值）的堆上。如果没有这样的堆，则新建一个堆。
>     
> - **关系:** 堆的数量 = 最长递增子序列 (LIS) 的长度。
>     
> - **时间复杂度:** 使用二分查找找到合适的堆，复杂度为 $O(n \log n)$。
>     

### 练习：最长交替子序列 (Longest alternating subsequence, LAS)

> [!question] 题目 (Slide 44)
> 
> 给定数组，在 $O(n)$ 时间内找到最长的交替子序列 (如高-低-高-低...)。

> [!check] 答案与思路
> 
> 知识点: #Greedy #DP
> 
> - **策略:** 贪心策略。寻找所有的“峰”和“谷”。
>     
> - **算法:** 遍历数组，当趋势发生变化（从增变减或从减变增）时，选取转折点。实际上，这等同于计算所有的局部极值点。
>     
> - 例如：如果当前是寻找“高”点，只要数字在上升就继续走，直到数字开始下降，前一个数字就是峰。
>     

### 练习：区间着色 (Interval coloring)

> [!question] 题目 (Slide 45)
> 
> 课程调度：给定讲座的开始和结束时间，求最少需要多少间教室才能安排所有讲座（无冲突）。

> [!check] 答案与思路
> 
> 知识点: #Greedy #IntervalGraph
> 
> - **策略:** 将所有讲座按 **开始时间** 排序。
>     
> - **算法:**
>     
>     - 维护一个优先队列（小顶堆），存储已占用教室的**结束时间**。
>         
>     - 对于每个新讲座：检查堆顶（最早结束的教室）。
>         
>     - 如果 `堆顶结束时间 <= 当前开始时间`，说明该教室已空，弹出堆顶，更新该教室结束时间为当前讲座结束时间，重新入堆。
>         
>     - 否则（所有教室都忙），开设新教室（入堆）。
>         
> - 教室数量即为堆的大小。
>     

### 练习：校车司机分配 (School bus driver assignment)

> [!question] 题目 (Slide 54)
> 
> 有早班和晚班各 $n$ 个，时长不同。如果某司机总时长超过 $D$，则支付加班费。如何分配使加班费总和最小？

> [!check] 答案与思路
> 
> 知识点: #Greedy #RearrangementInequality
> 
> - **策略:** 排序不等式（Rearrangement Inequality）的应用。
>     
> - **算法:**
>     
>     - 将早班时长按 **升序** 排序。
>         
>     - 将晚班时长按 **降序** 排序。
>         
>     - 将最短的早班配对最长的晚班，次短配次长，以此类推。
>         
> - **原理:** 这样可以使最长的总时间“削峰”，从而最小化超出 $D$ 的部分。
>     

### 练习：加权最大早退任务 (Weighted variants of early jobs)

> [!question] 题目 (Slide 62)
> 
> 每个任务有处理时间 $t_i$、截止时间 $d_i$ 和利润 $g_i$。目标是最大化按时完成任务的总利润。
> 
> 变体 1: 所有任务处理时间为单位时间。
> 
> 变体 2: 利润和处理时间呈反比顺序（$g_i > g_j \implies t_i < t_j$）。

> [!check] 答案与思路
> 
> 知识点: #Greedy #Matroid
> 
> - **变体 1 (单位时间):**
>     
>     - 按利润 $g_i$ **降序** 排序。
>         
>     - 贪心地将高利润任务放入其截止时间前的最晚空闲时间槽。如果该时间槽被占，向前寻找，直到时间 0。如果没有空位则放弃。
>         
> - **变体 2:**
>     
>     - 这暗示了某种优势顺序。通常这类变体依然结合截止时间排序（EDF）和优先队列（类似 Moore-Hodgson 算法），但在发生冲突踢出任务时，依据贪心准则踢出“性价比”最低的。
>         

### 练习：火车转运包裹 (Transshipping packages)

> [!question] 题目 (Slide 63)
> 
> 火车从站 1 开到站 $n$，容量 $C$。有若干包裹 $(i, j)$ 需要从 $i$ 站运到 $j$ 站。求最大运送数量。

> [!check] 答案与思路
> 
> 知识点: #Greedy #IntervalScheduling
> 
> - **模型转化:** 这是一个区间调度问题，包裹 $(i, j)$ 看作区间 $[i, j)$。但是有容量限制（类似多重着色或带宽分配，但目标是最大化数量）。
>     
> - **策略:** 按 **卸货站 (destination) $j$** 的升序对包裹进行排序。
>     
> - **算法:**
>     
>     - 遍历排序后的包裹。
>         
>     - 只要在区间 $[i, j)$ 内火车的剩余容量 $>0$，就接受该包裹，并扣减相应区间的容量。
>         
> - **直觉:** 尽早把包裹卸下，腾出空间给后面的包裹。
>     

---

## L6: Dynamic Programming (动态规划)

### 思考题：空间压缩

> [!question] 题目 (Slide 11)
> 
> 如果只需要求 LCS 的长度（不需要重建解），能否将空间复杂度降为 $O(\min(m,n))$？

> [!check] 答案与思路
> 
> 知识点: #DP #SpaceOptimization
> 
> - **答案:** 可以。
>     
> - **方法:** DP 表的计算通常只需要上一行（或上一列）的值来计算当前行。因此可以使用两个数组（当前行和上一行）甚至一个滚动数组来完成计算，空间降为线性。
>     

### 练习：前缀型 DP (Prefix DP)

> [!question] 题目 (Slide 24)
> 
> 列举前缀子问题类型的 DP：
> 
> 1. 切钢条 (Rod cutting)
>     
> 2. 分段最小二乘 (Segmented least squares)
>     
> 3. 最长递增子序列 (LIS)
>     
> 4. 换行问题 (Line breaking)
>     

> [!check] 答案与思路
> 
> 知识点: #DP #PrefixDP
> 
> - 这类问题的状态通常定义为 $OPT(i)$：考虑前 $i$ 个元素的最优解。
>     
> - **LIS 转移:** $DP[i] = 1 + \max(DP[j])$ for $j < i, A[j] < A[i]$。
>     
> - **换行问题:** $DP[i] = \min_{j < i} (DP[j] + penalty(j+1 \dots i))$。
>     

### 练习：前缀对型 DP (Prefix-Pair DP)

> [!question] 题目 (Slide 38)
> 
> 列举前缀对子问题类型的 DP：
> 
> 1. 编辑距离 (Edit distance)
>     
> 2. 最长公共子串 (Longest common substring)
>     
> 3. 0/1 背包变体
>     

> [!check] 答案与思路
> 
> 知识点: #DP #2D_DP
> 
> - 状态定义通常为 $OPT(i, j)$，涉及序列 A 的前 $i$ 个和序列 B 的前 $j$ 个。
>     
> - **编辑距离:** $DP[i][j] = \min(DP[i-1][j]+1, DP[i][j-1]+1, DP[i-1][j-1] + cost)$。
>     

### 练习：区间型 DP (Interval DP)

> [!question] 题目 (Slide 48)
> 
> 列举区间子问题类型的 DP：
> 
> 1. 矩阵链乘 (Matrix-chain multiplication)
>     
> 2. 凸多边形最优三角剖分
>     
> 3. RNA 二级结构
>     
> 4. 最长回文子序列
>     

> [!check] 答案与思路
> 
> 知识点: #DP #IntervalDP
> 
> - 状态定义通常为 $OPT(i, j)$：区间 $[i, j]$ 内的最优解。
>     
> - **矩阵链乘:** $DP[i][j] = \min_{i \le k < j} (DP[i][k] + DP[k+1][j] + cost(i, k, j))$。
>     
> - **计算顺序:** 按区间长度 $len = 1, 2, \dots, n$ 从小到大枚举。
>     

---

## L9: Graph Algorithms (图算法)

### 练习：无环锦标赛 (Acyclic tournament)

> [!question] 题目 (Slide 25)
> 
> 对于一个锦标赛图（每对顶点间恰有一条有向边），证明以下等价性：
> 
> 1. 无环 $\iff$ 无长度为3的环 $\iff$ 传递性 $\iff$ 全序 $\iff$ 唯一的哈密顿路径。
>     

> [!check] 答案与思路
> 
> 知识点: #GraphTheory #TournamentGraph
> 
> - **核心思路:** 锦标赛图如果无环，它定义了一个严格的全序关系。如果有环，必包含一个长度为 3 的环（如果有一个长环，可以通过弦将其缩短，直到长度为3）。
>     
> - **得分序列:** 它的出度序列是唯一的 $0, 1, 2, \dots, n-1$。
>     

### 练习：生命周期一致性 (Consistency in life spans)

> [!question] 题目 (Slide 26)
> 
> 给定事实：(1) $i$ 死于 $j$ 出生前 ($i \to j$)；(2) $i$ 和 $j$ 的生命重叠。判断是否一致。

> [!check] 答案与思路
> 
> 知识点: #Graph #CycleDetection #Reachability
> 
> - **建模:**
>     
>     - 条件 (1) $i$ 在 $j$ 之前，建立有向边 $i \to j$。
>         
>     - 条件 (2) 重叠，意味着既不是 $i$ 在 $j$ 前，也不是 $j$ 在 $i$ 前。
>         
> - **算法:**
>     
>     1. 在由 (1) 构建的图中检测 **环**。如果有环，则不一致（时间倒流）。
>         
>     2. 对于条件 (2) 的每对 $(u, v)$，检查图中是否存在路径 $u \to \dots \to v$ 或 $v \to \dots \to u$。如果存在路径，说明有先后关系，与“重叠”矛盾。
>         
> - **复杂度:** 环检测 $O(V+E)$。不可达性检查可以通过传递闭包或多次遍历实现。对于 $O(V+E)$ 的要求，需要利用拓扑排序后的性质。
>     

### 练习：DAG 中的割点 (Cut vertex in DAG)

> [!question] 题目 (Slide 27)
> 
> 给定单源单汇的 DAG，找出所有割点（删除该点使得 $s$ 无法到达 $t$）。要求线性时间。

> [!check] 答案与思路
> 
> 知识点: #Graph #DominatorTree
> 
> - **定义:** 在 DAG 中，这类点被称为 **必经点 (Dominators)**。
>     
> - **算法:**
>     
>     1. 计算 $s$ 到所有点的拓扑排序。
>         
>     2. 由于是 DAG，支配关系可以通过处理入度和父节点的 LCA 来计算（构建支配树）。
>         
>     3. 更简单的方法（针对单源单汇 DAG）：对于任意节点 $v$，如果 $N(s \to v) \times N(v \to t) = N(s \to t)$（路径计数），则 $v$ 是割点。但路径计数可能溢出。
>         
>     4. **线性几何法:** 对图进行拓扑排序。如果对于某个拓扑序位置 $k$，所有从 $rank < k$ 到 $rank > k$ 的边都必须经过 rank 为 $k$ 的节点，则该节点为割点。或者：计算每个节点能到达的 **最远** 和 **最近** 的拓扑层级，利用瓶颈性质。
>         

### 练习：Prüfer 序列

> [!question] 题目 (Slide 28)
> 
> 树的 Prüfer 编码与解码，要求线性时间 $O(n)$。

> [!check] 答案与思路
> 
> 知识点: #Graph #Tree #PruferSequence
> 
> - **编码:** 每次移除标号最小的叶子，输出其邻居。
>     
>     - $O(n)$ 实现：使用指针维护当前度数为 1 的节点，避免重复搜索。
>         
> - **解码:** 根据序列重建树。
>     
>     - $O(n)$ 实现：计算度数，从左到右扫描序列，匹配当前最小的度数为 1 的节点。
>         

### 练习：法国国旗行走 (French flag walk)

> [!question] 题目 (Slide 46)
> 
> 边有蓝、白、红三色。寻找所有能通过颜色序列“蓝-白-红-蓝-白-红...”到达的节点。

> [!check] 答案与思路
> 
> 知识点: #BFS #StateSpace
> 
> - **建模:** 将每个节点 $u$ 拆分成三个状态：$(u, 0)$ [期待蓝色], $(u, 1)$ [期待白色], $(u, 2)$ [期待红色]。
>     
> - **算法:**
>     
>     - 从 $(start, 0)$ 开始 BFS。
>         
>     - 如果存在边 $u \xrightarrow{Blue} v$，添加状态转移 $(u, 0) \to (v, 1)$。
>         
>     - 如果存在边 $u \xrightarrow{White} v$，添加状态转移 $(u, 1) \to (v, 2)$。
>         
>     - 如果存在边 $u \xrightarrow{Red} v$，添加状态转移 $(u, 2) \to (v, 0)$。
>         
> - **结果:** 所有可达的 $(v, state)$ 对应的 $v$。
>     

### 练习：最短路径计数与节点集合

> [!question] 题目 (Slide 48-49)
> 
> 1. 计算 $s-t$ 最短路径的数量。
>     
> 2. 找出所有位于某条最短 $s-t$ 路径上的边/节点。
>     

> [!check] 答案与思路
> 
> 知识点: #BFS #ShortestPath
> 
> - **计数:** 运行 BFS。记 $N[v]$ 为路径数。$N[v] = \sum N[u]$，其中 $u$ 是 $v$ 的前驱且 $dist(u) = dist(v) - 1$。
>     
> - **找边/节点:**
>     
>     1. 从 $s$ 运行 BFS 得到 $dist_s(v)$。
>         
>     2. 从 $t$ 在反向图 $G^{rev}$ 运行 BFS 得到 $dist_t(v)$。
>         
>     3. 最短路径长度 $L = dist_s(t)$。
>         
>     4. 节点 $v$ 在最短路径上 $\iff dist_s(v) + dist_t(v) = L$。
>         
>     5. 边 $(u, v)$ 在最短路径上 $\iff dist_s(u) + 1 + dist_t(v) = L$。
>         

### 练习：不相交最短路径集合

> [!question] 题目 (Slide 63)
> 
> 找到包含关系上极大 (inclusion-wise maximal) 的边不相交（或点不相交）的最短 $s-t$ 路径集合。

> [!check] 答案与思路
> 
> 知识点: #BFS #Greedy #Flow
> 
> - **核心:** 仅保留属于最短路径的边（即满足 $dist_s(u) + 1 + dist_t(v) = dist_s(t)$ 的边），构成一个 **DAG**。
>     
> - **算法:** 在该 DAG 上找路径。每找到一条路径，就删除路径上的边（或点），直到 $s$ 不可达 $t$。这是一个贪心过程，或者可以看作单位容量的最大流问题。
>     

---

## L10: Shortest Path Trees (最短路径树)

### 练习：近似相等的边权

> [!question] 题目 (Slide 26)
> 
> 如果边权只有 1 和 2，或者是 $[1, 2]$ 区间的小数，如何优化 Dijkstra？

> [!check] 答案与思路
> 
> 知识点: #Dijkstra #BucketQueue
> 
> - **整数 1, 2:** 使用 **Dial's Algorithm** (桶队列) 的变体。只需维护 3 个桶（当前距离 $d$, $d+1$, $d+2$）。或者使用 **Deque (双端队列)**：边权为 1 加到队头（实际上是下一层），边权为 2 加到队尾（再下一层）。复杂度 $O(m+n)$。
>     
> - **区间 [1, 2]:** 如果是浮点数，无法用桶。标准堆 $O(m \log n)$。如果是特定的离散值，可用多级桶。
>     

### 练习：最关键边 (Most Vital Edge)

> [!question] 题目 (Slide 42-44)
> 
> 1. **Vital Edge:** 删除该边会导致 $s-t$ 最短距离增加。
>     
> 2. **Most Vital Edge:** 删除该边导致 $s-t$ 最短距离增加最大。
>     

> [!check] 答案与思路
> 
> 知识点: #ShortestPath #GraphSensitivity
> 
> - **判定 Vital:** 边 $(u, v)$ 是 Vital 的 $\iff$ 所有 $s-t$ 最短路径都经过它。这等价于它在所有最短路径构成的 DAG 的所有割集中。
>     
> - **找 Most Vital:**
>     
>     - 朴素方法：枚举最短路径上的每条边，删除，运行 Dijkstra。复杂度 $O(P \cdot (m+n \log n))$，其中 $P$ 是路径长度。
>         
>     - 因为 Most Vital Edge 一定属于原图的一条最短路径。先求出一条最短路径 $P_{SPT}$。Most Vital Edge 必在 $P_{SPT}$ 上。删除 $P_{SPT}$ 上的每一条边并重新计算最短路，取最大值。
>         

### 思考题：Most Vital Edge 的性质

> [!question] 题目 (Slide 44)
> 
> 判断真假：
> 
> (a) Most vital edge 是 $C_{ij}$ 最大的边。
> 
> (b) 是最短路径上 $C_{ij}$ 最大的边。
> 
> (c) 不在最短路径上的边不可能是 Most vital。
> 
> (d) 网络可能有多条 Most vital edges。

> [!check] 答案与思路
> 
> - (a) **False**. 最大的边可能根本不在最短路径上。
>     
> - (b) **False**. 即使在最短路径上，移除一条权值较小的“瓶颈”边（即没有替代路径的边）可能导致图不连通（距离无穷大），而移除权值最大的边可能有另一条只长一点点的替代路径。
>     
> - (c) **True**. 如果边不在当前的最短路径上，移除它，原最短路径依然存在，距离不变（增加量为0）。
>     
> - (d) **True**. 移除不同的边可能导致相同的最大距离增加。
>