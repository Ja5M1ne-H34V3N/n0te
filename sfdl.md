## L6DP — Dynamic Programming（动态规划）

### 1) 这份 PPT 在讲什么

核心是在教你：**怎么把一个优化/计数问题拆成“子问题”，写出递推式，然后按正确顺序填表**。PPT 用多个经典例子说明子问题的三种常见设计方式：

- **按前缀（prefix）/前缀对（prefix-pair）**：如 LCS、编辑距离、序列对齐等。
    
    L6DP
    
- **按区间（interval）**：如矩阵链乘、回文子序列、括号匹配等。
    
    L6DP
    
- **按容量/预算（knapsack-style）**：如 0-1 背包。
    
    L6DP
    

另外还讲了二维前缀和这种“DP 入门小技巧”。

L6DP

---

### 2) 题目：矩阵前缀和里只要 `max_{i,j} S[i,j]`，能否省空间？

题干在 PPT 上是：如果只需要  
max⁡1≤i,j≤nS[i,j]\max_{1\le i,j\le n} S[i,j]max1≤i,j≤n​S[i,j]，能否把空间从 O(mn)O(mn)O(mn) 降到 O(m∧n)O(m\wedge n)O(m∧n)？

L6DP

**结论：能。**  
二维前缀和通常递推是：

S[i][j]=A[i][j]+S[i−1][j]+S[i][j−1]−S[i−1][j−1]S[i][j]=A[i][j]+S[i-1][j]+S[i][j-1]-S[i-1][j-1]S[i][j]=A[i][j]+S[i−1][j]+S[i][j−1]−S[i−1][j−1]

要算第 i 行时，只依赖：

- 本行的左边 S[i][j−1]S[i][j-1]S[i][j−1]（当前行）
    
- 上一行同列 S[i−1][j]S[i-1][j]S[i−1][j]（上一行）
    
- 上一行左上 S[i−1][j−1]S[i-1][j-1]S[i−1][j−1]（上一行）
    

所以你只需要保留 **上一行数组 prev[1..n]** 和 **当前行数组 cur[1..n]**，边算边维护最大值。

- **空间**：O(n)O(n)O(n)（如果列数是 n）。
    
- 若是 m×nm\times nm×n，你可以“沿着更短的那一维滚动”，做到 **O(min⁡(m,n))O(\min(m,n))O(min(m,n))**，这就是 PPT 说的 O(m∧n)O(m\wedge n)O(m∧n)。
    

---

### 3) Practice：Subproblems by prefix-pair（按“前缀对”设计 DP）

PPT 列了一串典型题（你会在刷题里反复遇到）：

L6DP

  
下面逐个给“能写出来的 DP 状态 + 递推 + 复杂度”。

#### (1) 最大全 1 正方形子矩阵（max-size all-1 square）

**状态**：dp[i][j] = 以 (i,j) 为右下角的、全 1 正方形的最大边长  
**转移**：

- 若 A[i][j]=1：  
    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    
- 否则 dp[i][j]=0  
    **答案**：max(dp[i][j])  
    **复杂度**：O(mn)O(mn)O(mn) 时间，O(n)O(n)O(n) 空间可滚动。
    

> 初学者直觉：要形成更大的正方形，右、下、右下三个方向的“可扩展边长”都得够用，所以取 min。

---

#### (2) 编辑距离（edit distance）

经典三操作：插入/删除/替换。  
**状态**：dp[i][j] = 把 A 的前 i 个字符变成 B 的前 j 个字符的最小代价  
**转移**：

- 删除 A[i]：dp[i-1][j] + 1
    
- 插入 B[j]：dp[i][j-1] + 1
    
- 替换/匹配：dp[i-1][j-1] + (A[i]==B[j]?0:1)  
    取最小。  
    **复杂度**：O(∣A∣∣B∣)O(|A||B|)O(∣A∣∣B∣)。
    

---

#### (3) 最长公共子串（longest common substring）

注意：**子串要连续**，所以不再是 LCS 的 “max(dp[i-1][j], dp[i][j-1])”。  
**状态**：dp[i][j] = 以 A[i] 与 B[j] 结尾的最长公共子串长度  
**转移**：

- 若 A[i]==B[j]：dp[i][j]=dp[i-1][j-1]+1
    
- 否则 dp[i][j]=0  
    **答案**：max(dp[i][j])  
    **复杂度**：O(∣A∣∣B∣)O(|A||B|)O(∣A∣∣B∣)，空间可滚动。
    

---

#### (4) 最长公共递增子序列（LCIS）

PPT点名 LCIS（common + increasing）：

L6DP

  
常用 O(n2)O(n^2)O(n2) 做法（A、B 长度都 ~n）：

**思路**：枚举 A[i]，尝试把它作为公共递增序列的“新末尾”。  
维护一个变量 `best`：表示在扫描 B[j] 时，所有 **B[j] < A[i]** 的位置里，LCIS 的最大长度。

- 如果 A[i]==B[j]：dp[j] = best + 1
    
- 如果 B[j] < A[i]：best = max(best, dp[j])
    

**复杂度**：O(n2)O(n^2)O(n2)，空间 O(n)O(n)O(n)。

> 初学者提示：这题不是二维表“随便 max”，关键是“递增”让你必须记住 **小于当前值的最好结果**。

---

#### (5) 最长凸子序列（longest convex subsequence）

这是更进阶的序列 DP。常见定义：对任意三点 i<j<k，要求

a[j]−a[i]<a[k]−a[j](二阶差分递增)a[j]-a[i] < a[k]-a[j]\quad (\text{二阶差分递增})a[j]−a[i]<a[k]−a[j](二阶差分递增)

等价于 a[i]+a[k]>2a[j]a[i]+a[k] > 2a[j]a[i]+a[k]>2a[j]。

**朴素状态**：dp[j][k] = 以 (j,k) 为最后两个点的最长凸子序列长度  
**转移**：找 i<j 且满足凸性条件 a[i]+a[k]>2a[j]a[i]+a[k] > 2a[j]a[i]+a[k]>2a[j]：  
dp[j][k] = 1 + max(dp[i][j])  
**复杂度**：朴素 O(n3)O(n^3)O(n3)（能写、能过小数据）；想更快需要更复杂的优化（不展开）。

---

#### (6) 背包家族（Knapsack and variants）

PPT把背包作为 DP 典型应用引入：

L6DP

**0-1 背包**

- 状态：dp[w]=容量为 w 的最大价值
    
- 转移（倒序 w）：dp[w]=max(dp[w], dp[w-wi]+vi)
    

**完全背包（可重复取）**：把 w 循环改成正序即可。  
**多重背包**：常见“二进制拆分”把数量限制拆成若干个 0-1 物品。

---

### 4) Practice：Subproblems by intervals（按“区间”设计 DP）

PPT 给的清单：

L6DP

#### (1) 矩阵链乘（matrix-chain multiplication）

**状态**：dp[i][j] = 乘 Ai⋯AjA_i\cdots A_jAi​⋯Aj​ 的最少乘法次数  
**转移**：枚举最后一次断开点 k：  
dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost(i,k,j))  
其中 cost 是维度乘法代价。  
**复杂度**：O(n3)O(n^3)O(n3)。

---

#### (2) 最短三角剖分（shortest triangulation）

多边形顶点 i..j 的最优值：  
dp[i][j] = min_{k} dp[i][k]+dp[k][j]+triangle_cost(i,k,j)  
**复杂度**：O(n3)O(n^3)O(n3)。

---

#### (3) RNA secondary structure

典型区间 DP：  
dp[i][j] = max(

- dp[i][j-1]（j 不配对）
    
- max_{t in [i, j-1]} dp[i][t-1]+dp[t+1][j-1]+1（t 与 j 配对且合法）  
    )
    

---

#### (4) 最长平衡子序列（longest balanced subsequence）

如果是括号串，经典区间 DP：  
dp[i][j] = max(

- dp[i+1][j], dp[i][j-1],
    
- dp[i+1][j-1]+2（若 i 与 j 可匹配）
    
- max_{k} dp[i][k]+dp[k+1][j]  
    )
    

---

#### (5) 最长回文子序列（LPS）

dp[i][j] =

- dp[i+1][j-1]+2（若 s[i]==s[j]）
    
- 否则 max(dp[i+1][j], dp[i][j-1])
    

---

#### (6) CKY parsing（上下文无关文法解析）

**状态**：dp[i][j][A] = span(i..j) 能否由非终结符 A 推导  
**转移**：枚举切分点 k 和产生式 A→BC：  
dp[i][j][A] |= dp[i][k][B] && dp[k+1][j][C]

---

## L7Greedy1 — Greedy Algorithms (I)

### 1) 这份 PPT 在讲什么

主题是“如何证明贪心正确”：

- 交换论证 / 替换论证（replace argument）
    
- 扩展共同前缀（extending common prefix）
    
- 上界匹配（把问题拆成 clique/上界结构）  
    这些在活动选择类问题里反复出现。
    
    L7Greedy1
    

---

### 2) Practice：Fractional Knapsack（分数背包）

题在 PPT：按单位价值（return rate）从大到小贪心装。

L7Greedy1

**算法**：按 vi/wiv_i/w_ivi​/wi​ 降序排序，能装多少装多少，最后一个可能装部分。  
**为什么对（初学者版）**：  
如果你在某个时刻没有选“单位价值最高”的那份，而选了更低的，那么把你选的那一小部分换成更高单位价值的同等重量，价值一定不降（只增不减），所以最优解一定可以调整成“先选最高单位价值”的形状。

---

### 3) Practice：Refueling stops（最少加油次数）

题干：固定路线、油箱容量 C 足够覆盖任意相邻站距离，目标最少停车加油；提示“Truck driver’s algorithm”。

L7Greedy1

**算法（最经典贪心）**：  
每次都开到“再不停就到不了下一站”的临界点，然后在**你能到达的最远站**加油（等价于：从当前站出发，直接跳到最远可达站）。  
**证明直觉**：  
如果你不跳到最远，而是提前在更近的站停了，那你下一次能到的最远范围不会更大，只会“浪费一次停靠机会”，因此不可能比“能跑多远跑多远”更少。

---

### 4) Practice：Longest Alternating Subsequence（LAS，最长交替子序列）

PPT 要求线性时间：

L7Greedy1

这就是著名 **wiggle subsequence**。

**线性 DP/贪心写法**：  
维护两个值：

- up：以“最后一步是上升(+)”结尾的最长长度
    
- down：以“最后一步是下降(-)”结尾的最长长度
    

扫描数组：

- 若 a[i] > a[i-1]：up = down + 1
    
- 若 a[i] < a[i-1]：down = up + 1
    
- 相等：都不变
    

**为什么对**：  
交替只关心“最后一段趋势”，而不需要记住具体取了哪些点；每次出现更好的上升/下降，就能把另一种趋势的最优长度 +1 接上。

---

### 5) Practice：Interval coloring（区间染色=最少教室数）

题干：最少教室安排所有讲座。

L7Greedy1

**结论**：最少教室数 = 任意时刻同时进行的讲座最大数量（最大重叠数）。  
**算法**：按开始时间排序，用小根堆维护“每个教室当前讲座的结束时间”：

- 取最早结束的教室，如果它结束时间 ≤ 当前讲座开始，则复用；否则开新教室（push）。  
    堆的最大尺寸就是答案。
    

---

### 6)（同主题延伸）最小化最大延误（Minimizing Maximum Lateness）

PPT引入该问题：每个项目有处理时间与截止时间。

L7Greedy1

  
**标准答案**：按截止时间从早到晚排序（EDF）。  
**证明模板**：若某最优解里存在相邻两项 i、j 且 d_i > d_j（“逆序”），交换它们不会让最大延误变更坏，于是不断消除逆序，就得到 EDF 顺序。

---

### 7) Practice：School bus driver assignment（校车司机配对）

（这题在同一套贪心练习里：要把两组路线（比如早班/晚班）配对，使“超时/加班”最小。）

L7Greedy1

**经典解法**：  
把一组按升序排，另一组按降序排，然后一一配对。  
**直觉**：你在避免“长+长”产生极大超额，这是著名的“重排不等式/配对极值”型贪心：让大的和小的配，最大值最小。

---

### 8) Practice：Weighted variants of early jobs（带权版本的早结束作业）

PPT专门提示“变成 weighted 后，贪心往往会失败”。

L7Greedy1

**答案**：

- “按最早结束/最短时长/最高权重”等简单贪心都可能错。
    
- 正解通常是 **Weighted Interval Scheduling（加权区间选择）DP**：按结束时间排序，设 p(j) 为与 j 不冲突且最靠右的作业，递推
    
    OPT(j)=max⁡(OPT(j−1),wj+OPT(p(j)))OPT(j)=\max(OPT(j-1), w_j+OPT(p(j)))OPT(j)=max(OPT(j−1),wj​+OPT(p(j)))

这类 DP 的思想与 L6/L10 的“最长路建模”是一致的（L10 里也用区间选择做图建模示例）。

L10SPT

---

### 9) Practice：transshipping packages by train（火车分段运包裹）

题干：线性站点 1..n，列车每段容量 c；有很多包裹从 i 到 j（i<j），每个包裹占 1 单位容量，问如何**最大化运送数量**。

L7Greedy1

**贪心核心**：在任何区间容量受限问题里，要“优先保留更早结束/更早卸货”的包裹。  
**算法（扫描线 + 删除最晚到达者）**：

1. 从站点 1 扫到 n。维护一个数据结构保存“当前在车上的包裹的目的地”。
    
2. 到站 i：把所有从 i 出发的包裹加入。把所有目的地 = i 的包裹卸下（从结构里删掉）。
    
3. 如果此时车上包裹数 > c：不断移除**目的地最远（j 最大）**的包裹，直到 ≤ c。
    

**为什么对**：当容量超了，你必须丢一些。丢“最远目的地”的，能让剩下的包裹更早释放容量，给后面更多包裹机会。  
**复杂度**：用平衡树/堆维护目的地，多次插删是 O(Mlog⁡M)O(M\log M)O(MlogM)（M 为包裹数）。

---

## L8Greedy2 — Greedy Algorithms (II)

### 1) 这份 PPT 在讲什么

目录写了 horse racing、Huffman codes/trees、offline caching。

L6DP

  
其中本 PDF 主要内容是 **horse racing（田忌赛马类）** 与 **Huffman 编码**。

---

### 2) Pre-lecture exercise：Horse racing（赛马最大得分）

题目：两人各 n 匹马，速度已知，要给自己安排出战顺序，使得总得分最大（胜 +1，负 -1）。

L6DP

**经典双指针贪心**：

1. 把你和对手的马都按速度升序排序。
    
2. 维护你方最慢/最快指针 (i_lo, i_hi)，对手 (j_lo, j_hi)。
    
3. 重复 n 次：
    
    - 若你最慢 > 对手最慢：用最慢赢最慢（+1），两边 lo++
        
    - 否则若你最快 > 对手最快：用最快赢最快（+1），两边 hi--
        
    - 否则：你无法赢（或只能打平），就“献祭”你最慢对对手最快（-1 或 0），你 lo++、对手 hi--
        

**初学者解释**：

- 你能赢就尽量用“最省的马”去赢（避免浪费快马）。
    
- 你赢不了时，别让对手的快马白白拿去欺负你的快马——干脆用最慢去吃掉这次必输，把快马留给后面可能赢的局。
    

---

### 3) Huffman codes and trees（哈夫曼编码）

PPT讲了 Huffman 的构造、复杂度、左对齐树等要点。

L6DP

L8Greedy2

**问题背景（新手版）**：  
给定字符出现频率，想要一个**前缀码**（任何码字都不是另一个码字的前缀），并使平均码长最小。

**算法（一定要会背）**：

- 把每个字符当作一棵单节点树，权重=频率
    
- 反复做：取权重最小的两棵树合并成新树（父节点权重=两者之和）
    
- 合并到只剩一棵树，沿边标 0/1 得到码字
    

**为什么正确（入门可理解版）**：  
最优前缀码可以看成一棵二叉树，频率越大越应该靠近根（码字越短）。Huffman 的关键贪心结论是：**频率最小的两个符号，在某个最优解里一定可以被放成最深层的兄弟叶子**。于是你先把它们合并，相当于把问题规模缩小 1，再递归最优。

---

### 4)（练习型问题）狼-羊-菜过河（WGC puzzle）

该题在图算法 PPT 也出现：船一次只能带农夫 + 一个物品，狼不能和羊单独在一起、羊不能和菜单独在一起，问如何过河。

L9Graph

**一条标准可行序列**：

1. 先带羊过去；农夫回来（空船）
    
2. 带狼过去；把羊带回来
    
3. 带菜过去；农夫回来（空船）
    
4. 再带羊过去  
    这样任何时刻都不会出现“狼吃羊/羊吃菜”。
    

**图论视角（为什么 PPT 放在图里）**：  
把每个状态编码成 (农夫/狼/羊/菜 在哪边)，非法状态删掉，然后在合法状态图上做 BFS 找最短路径即可。

L9Graph

---

## L9Graph — Graph Algorithms（图算法：BFS/DFS/拓扑/SCC/归约）

### 1) 这份 PPT 在讲什么

- DAG 与拓扑排序（Kahn 迭代剥源点）
    
    L9Graph
    
- BFS 分层与最短路（无权图）
    
- DFS 与强连通分量（Kosaraju-Sharir）
    
    L9Graph
    
- 图归约（把奇偶、颜色序列等约束变成“扩展状态图”）
    
    L9Graph
    

---

### 2) Practice：输出拓扑序或输出一个环（线性时间）

题干明确写了 Kahn 扩展：

L9Graph

**算法**：

1. 用 Kahn：不断删除入度为 0 的点，输出到序列。
    
2. 若删完了：得到拓扑序。
    
3. 若还剩点但没有入度 0：剩余子图必含环。
    
    - 在线性时间内找环：对剩余子图做一次 DFS，利用“递归栈回边”即可恢复一个环。
        

---

### 3) Practice：Acyclic tournament（锦标赛图等价条件）

题干列了 TFAE：无环 ⇔ 无 3 环 ⇔ 传递 ⇔ 严格全序 ⇔ ……

L9Graph

**关键证明链（新手友好版）**：

- 有环 ⇒ 一定能在 tournament 里找到长度为 3 的有向环（因为任取环上相隔一段的三点，tournament 的“任意两点必有边”会逼出 3 环）。
    
- 无 3 环 ⇒ 方向必可用一个全序表示（否则会形成矛盾三角形）。
    
- 能用全序表示 ⇒ 显然无环、且哈密顿路径唯一（就是这个序）。
    

---

### 4) Practice：Consistency in life spans（寿命事实一致性）

题干：事实要么“i 死在 j 出生前”，要么“i 和 j 寿命重叠”，问是否存在一组人使所有事实同时成立，要求 O(m+n) 级别。

L9Graph

**建模**：把每个人 i 拆成两个事件点：Birth(i)、Death(i)。  
所有事实都能变成“先后约束”：

- Birth(i) < Death(i)（常识约束）
    
- “i 死在 j 出生前” ⇒ Death(i) < Birth(j)
    
- “i 与 j 重叠” ⇒ Birth(i) < Death(j) 且 Birth(j) < Death(i)
    

于是得到一个 **有向约束图**（边表示必须先发生）。  
**结论**：约束**可行 ⇔ 图无环**。

- 无环：拓扑排序后按序号赋时间即可满足所有严格先后关系。
    
- 有环：产生“必须先于自己”的矛盾，必不一致。
    

**算法**：建图 + 拓扑排序检测环，线性时间。

---

### 5) Practice：Cut vertex in DAG（DAG 割点）

题干给了一个非常好用的判定：在任意拓扑序里，v 是割点当且仅当不存在跨越它的边 (u,w) 满足 u < v < w。

L9Graph

**线性算法（思路）**：

1. 先拓扑排序，得到每点位置 pos[v]。
    
2. 对每条边 (u,w)，它“覆盖”区间 (pos[u], pos[w]) 的内部点。
    
3. 如果某点 v（非 s,t）从未被任何边跨越覆盖，则删掉 v 会让路径被“卡断”，它就是割点。
    

实现上用差分/前缀计数做区间覆盖即可做到 O(m+n)O(m+n)O(m+n)。

---

### 6) Practice：Prüfer code 编解码

题干：编码、解码时间要求（并挑战更快）。

L9Graph

**编码（O(n log n)）**：

- 维护每点度数 + 小根堆保存当前所有叶子
    
- 重复 n-2 次：取最小叶子 x，输出其邻居 y；删掉 x，更新 y 度数，若 y 变叶子则入堆
    

**解码（O(n log n)）**：

- 初始化 degree[v] = 1 + code 中 v 出现次数
    
- 把所有 degree=1 的点进小根堆
    
- 依次读 code[i]=y：弹出最小叶子 x，连边 (x,y)，degree[y]--，若变 1 则入堆
    
- 最后剩两叶子相连
    

想做到 O(n)（挑战）：若标签是 1..n，可用“指针扫描下一个最小叶子”替代堆（实现更繁琐）。

---

### 7) 应用题：Shortest even/odd walk（最短偶/奇长度 walk）

题干在 PPT：找最短偶数（或奇数）长度的 s→t walk。

L9Graph

**标准归约**：把每个节点复制成 (v,0) 与 (v,1) 两个“奇偶状态”，每走一条边就翻转奇偶。

- 最短偶 walk ⇔ 最短路 (s,0) → (t,0)
    
- 最短奇 walk ⇔ 最短路 (s,0) → (t,1)
    

---

### 8) Practice：French flag walk（三色循环边序列可达性）

题干：边颜色蓝白红循环，找从给定点可通过此类 walk 到达的所有点。

L9Graph

**归约模板**：把状态扩成 (v, state)：

- state=0 期待蓝边，1 期待白边，2 期待红边
    
- 若从 v 走一条“符合期待颜色”的边到 u，则到 (u,(state+1)%3)  
    在 3|V| 个状态点上做 BFS/DFS，最后把任意 state 下可达的 v 汇总即可。  
    **复杂度**：O(m+n)O(m+n)O(m+n)。
    

---

### 9) Practice：Shortest cycle（最短环）

题干：有向图、无向图分别找最短环。

L9Graph

**无权图常见做法（可直接写）**：

- **无向**：对每个源点 s 做 BFS；当遇到一条边 (u,v) 且 v 已访问且 v≠parent[u]，得到一个环长 dist[u]+dist[v]+1；取最小。
    
- **有向**：对每个 s 做 BFS 求 dist_s[*]；对每条回到 s 的边 (v→s)，候选环长 dist_s[v]+1；取最小。  
    复杂度 O(n(m+n))O(n(m+n))O(n(m+n))。若图很稀疏/规模中等够用；更快算法属于进阶主题。
    

---

### 10) Practice：Counting shortest paths（最短路条数）

题干：无向图，从源点到每个点的最短路径条数。

L9Graph

**算法**：

1. BFS 得 dist[v]
    
2. 按 dist 从小到大处理：
    
    - ways[s]=1
        
    - ways[v]=Σ ways[u]，对所有边 (u,v) 满足 dist[u]=dist[v]-1  
        **复杂度**：O(m+n)O(m+n)O(m+n)。
        

---

### 11) Practice：哪些点/边在某条最短 s-t 路径上？

题干：找所有在某条最短 s-t 路径上的点/边。

L9Graph

**算法**：

- BFS/最短路得 d_s[v]（s 到 v）
    
- BFS/最短路得 d_t[v]（v 到 t，或从 t 反向跑）  
    令 D=d_s[t]
    
- 点 v 在某条最短路上 ⇔ d_s[v]+d_t[v]=D
    
- 有向边 (u→v) 在某条最短路上 ⇔ d_s[u]+w(u,v)+d_t[v]=D（无权时 w=1）
    

---

### 12) Practice：Core vertices（能到达所有点的“核心点”）

题干：线性时间找所有 core vertex；并给出判定与 SCC meta 图有关。

L9Graph

**结论**：存在 core vertex ⇔ SCC 凝聚图（meta graph）只有一个源分量。  
**算法**：

1. Kosaraju 求 SCC（线性）
    
    L9Graph
    
2. 建 meta DAG，统计每个分量入度
    
3. 若入度=0 的分量恰好一个，则该分量内所有点都是 core；否则无 core。
    

---

### 13) Practice：找“包含意义上的极大”不相交最短 s-t 路径集

题干：在线性时间内找

- 极大（非最大）**边不相交**最短路集合
    
- 极大（非最大）**内部点不相交**最短路集合
    
    L9Graph
    

**通用做法（极大就够，不追求最大）**：

1. 先构造“最短路 DAG”：只保留满足 dist 层数递增的边（无权：dist[v]=dist[u]+1）。
    
2. 然后重复：
    
    - 在当前 DAG 里用 DFS 找到任意一条 s→t 路径
        
    - 找到后，把该路径上的 **边**删掉（做边不相交）
        
    - 或删掉路径的 **内部点及其 incident edges**（做点不相交）  
        直到找不到 s→t 路径为止。
        

因为每条边/点最多被访问与删除常数次，总体线性时间，且结果是“再也加不进任何新路径”的极大集。

---

## L10SPT — Shortest Paths（最短路径树/最短路算法）

### 1) 这份 PPT 在讲什么

按三种设定给最短路算法：DAG、非负边、无负环。

L10SPT

- DAG：拓扑序 DP（push/pull 两种写法）
    
    L10SPT
    
- 非负边：Dijkstra（优先队列实现与正确性不变式）
    
    L10SPT
    
- 无负环：Bellman–Ford、负环检测；以及 Floyd–Warshall 做 APSP（并提到 APSP 次立方是开放问题）
    
    L10SPT
    
    L10SPT
    

---

### 2) Practice：almost equal weights（几乎相等的权重）

题干：若边权 **要么 1 或 2**，或 **都在 [1,2]**，给出线性时间算法；提示 bucket queue。

L10SPT

**(A) 权重 ∈ {1,2}：Dial’s algorithm（桶式 Dijkstra）**

- 用桶 buckets[d] 存放当前距离= d 的点
    
- 因为每次松弛只会让距离 +1 或 +2，所以你按 d 从小到大扫描桶即可
    
- 这里最大边权 C=2，是常数，所以时间 O(m+n)O(m+n)O(m+n)。
    

**(B) 权重 ∈ [1,2]：桶宽取 1 的单调桶队列**

- 用 floor(dist) 作为桶编号
    
- 当你弹出最小 dist 的点 u 后，任何邻居 v 的新 dist 至多落在当前桶或后 1 个桶（因为加的边权 <2）
    
- 同样可以线性扫描桶并完成 Dijkstra 的“ExtractMin”效果  
    直觉：权重区间很窄 ⇒ “最小候选距离”移动得很平滑 ⇒ 不需要 log 级别的堆。
    

---

### 3) vital edge（删掉会让最短 s-t 距离变大的边）

PPT给了一个 O(m) 思路：先求 tight edges，再做可达性与一次很小的 max-flow 检测。

L10SPT

**初学者版解释**：

1. 先求 d_s[_] 与 d_t[_]，最短距离 D=d_s[t]
    
2. 边 (u,v) 是 tight 当且仅当 d_s[u]+w(u,v)+d_t[v]=D（它可能出现在某条最短路上）
    
3. 只在 tight 子图里讨论“最短路的结构”：如果存在两条边不相交的最短路，那么删掉任意一条边都不至于让最短距离变大
    
4. 通过把 tight 子图变成一个容量网络、最多两次增广判断 max-flow 是否 >1，可以判定是否存在 vital arc，并进一步定位（PPT给的是线性时间实现路径）。
    
    L10SPT
    

---

### 4) most vital edge（使最短距离增加最多的 vital edge）

题干：设存在 vital arc，设计算法并分析时间。

L10SPT

**直接可写的算法（够课程作业级别）**：

1. 先用上一题方法找出所有 vital edges（候选集 V）。
    
2. 对每条 e ∈ V：运行一次 Dijkstra/最短路在 G-e 上求新的 dist'(t)。
    
3. 取使 dist'(t) 最大的那条 e。
    

**时间**：O(∣V∣⋅(mlog⁡n))O(|V|\cdot (m\log n))O(∣V∣⋅(mlogn))（用堆的 Dijkstra）。

> 想更快需要“replacement paths”系列算法，属于更进阶内容；这份 PPT 没展开就不硬编。

---

### 5) 证明/反例题：关于 most vital arc 的 (a)-(d)

题目原文在 PPT：

L10SPT

我按“真/假 + 理由/反例”给结论（注意：这里的 cijc_{ij}cij​/CijC_{ij}Cij​ 都可理解成边的长度/代价符号）。

**(a) “most vital 一定是 Cij 最大的边” —— 假**  
反例：存在一条非常长的边，但它根本不在任何最短 s-t 路径上，删不删都不影响最短距离，更不可能 most vital。

**(b) “most vital 一定是某条最短路上长度最大的边” —— 假**  
反例构造：最短路由两条边组成，长度分别 100 和 1，总长 101；

- 删长度 100 的边，还有一条备选路长 102（增加 1）
    
- 删长度 1 的边，只能走备选路长 1000（增加 899）  
    则 most vital 是长度 1 的那条，不是“最短路上最长的边”。
    

**(c) “不属于任何最短路的边不可能是 most vital” —— 真**  
理由：如果边 e 不在任何最短路上，那么原本至少有一条最短路完全不使用 e；删掉 e 后这条路仍存在，最短距离不会变大，所以 e 不是 vital，更不可能 most vital。

**(d) “可能有多个 most vital” —— 真**  
例子：最短路唯一且包含两条边 e1、e2；删掉 e1 或 e2 后都只能走同一条长度相同的绕路，使最短距离增加相同的最大值，则 e1、e2 都是 most vital。

---

## L11MST — Minimum Spanning Trees（最小生成树）

### 1) 这份 PPT 在讲什么

围绕 MST 的“切分性质（cut property）/交换性质”解释 Kruskal、Prim、Reverse-delete 等算法为何正确，并提到“只要边的相对顺序一致，Kruskal 的 MST 集合一致”等。

L11MST

---

### 2) Practice：m = n + k（近似树）时线性时间求 MST

题意：边数比树多 k 条，要求线性级别（通常默认 k 很小）。

L7Greedy1

**思路**：  
先取任意一棵生成树 T（例如 DFS 树）。额外的每条非树边 e=(u,v) 加入 T 会形成**唯一环**；为了保持最小，总应该删掉该环上**最重**的边（如果它比 e 重）。

- 对每条额外边做一次“找路径上最大边”并可能替换。
    
- 若 k 是常数：每次在树上 DFS 找 u-v 路径最大边，总代价 O(kn)=O(n)O(kn)=O(n)O(kn)=O(n)。
    
- 若要对任意 k 更稳健：可用 LCA + 倍增维护路径最大边做到 O((n+k)log⁡n)O((n+k)\log n)O((n+k)logn)。
    

---

### 3) Practice：Dynamic MST（单边权重变化如何更新 MST）

题干：某条边权重变大或变小，如何更新 MST。

L7Greedy1

**(A) 边 e 变小**

- 若 e 已在 MST：MST 不会变差（仍是 MST）。
    
- 若 e 不在 MST：把 e 加入 MST 会形成环；若 e 比环上最大边更轻，则用 e 替换那条最大边。
    

**(B) 边 e 变大**

- 若 e 不在 MST：无影响。
    
- 若 e 在 MST：删掉 e 后树被分成两块，必须找一条跨越这两块的最轻边来补上（这就是 cut property 的直接应用）。  
    朴素扫描所有边是 O(m)O(m)O(m)；用动态树结构可更快（进阶）。
    

---

### 4) Practice：Single-pair min-max path（单对点的“最小化最大边”路径）

题干：找 s→t 路径，使路径上最大边权尽可能小。

L7Greedy1

**结论（非常重要）**：MST 上 s 到 t 的唯一路径就是最优的 min-max（瓶颈最小）路径。  
**为什么**：MST 对任意 cut 都选最轻边，保证任意两点间的路径瓶颈被压到最低（属于“最小瓶颈生成树”性质）。

**算法**：先求 MST（Kruskal/Prim），再在 MST 上取 s-t 路径的最大边。

---

### 5) Practice：Maximum spacing k-clustering（最大间距 k 聚类）

题干：最大化聚类间距的 k 聚类。

L7Greedy1

**标准 Kruskal 停止法**：

- 边按权重升序排序
    
- 并查集合并，直到剩下 k 个连通块时停止
    
- 这时下一条将要连接两个不同簇的最小边权，就是最大间距（spacing）
    

---

### 6) Practice：Minimum-weight feedback edge set（最小权反馈边集）

题干：删掉最小总权重的一组边，使图无环。

L7Greedy1

**关键等价**：  
“删边使无环” ⇔ “保留一片最大权重的生成森林”。  
所以：

- 先求 **最大生成森林**（把 Kruskal 的排序改成按权重降序）
    
- 输出 **不在该森林里的所有边**，它们的总权重最小。
    

---

### 7) （补充：PPT里也提到）MST 是否唯一

PPT 提示：边权全不同 ⇒ MST 唯一。

L11MST

  
更一般的判定：若存在等权导致“可交换边”（同一 cut 上有并列最小边），则可能不唯一；可用 Kruskal 分块处理等权边并检查是否出现多种可选连接方式（PPT也提到 batch/block 处理）