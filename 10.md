# 第 10 讲：最短路径（Shortest Paths）

## 核心知识点

### 1. 概述（Overview）

#### 1.1 核心概念

- **单源最短路径（SSSP）**：给定有向图\(D=(V, A; \ell)\)（\(\ell\)为边权重函数），求源点s到所有节点v的最短路径长度\(d(v)\)（\(d(s)=0\)）；
- **全源最短路径（APSP）**：求所有节点对\((i,j)\)的最短路径；
- **单对最短路径（SPSP）**：求单个节点对\((s,t)\)的最短路径；
- **最短回路（Shortest Circuit）**：图中长度最短的环。

#### 1.2 关键性质与原理

- **最优子路径性质**：任意最短路径的子路径，也是其端点间的最短路径；
- **贝尔曼原理（Bellman’s Principle）**：无负环（NC，权重和为负的环）时，最优子路径性质成立，且任意\(s-t\)通路中必含\(s-t\)最短路径（可移除回路）；
- **贝尔曼方程（Bellman’s Equation）**：无负环时，最短路径长度满足：
    
    \(d(s) = 0\)
    
    \(d(v) = \min_{(u,v) \in A} \{d(u) + \ell(u,v)\} \quad (\forall v \neq s)\)
- **最短路径树（SPT）**：以s为根的生成树，每条树路径都是对应端点的最短路径；
    - 紧边集\(A_0 = \{(u,v) \in A \mid d(v) = d(u) + \ell(u,v)\}\)；
    - 性质：T是 SPT ⇨ \(T \subseteq A_0\)（可线性时间从d还原 SPT）。

#### 1.3 三类场景的 SPT 算法对比

|场景|算法|时间复杂度|核心逻辑|
|---|---|---|---|
|无环（DAG）|拓扑排序 + 松弛|\(O(m+n)\)|按拓扑序遍历节点，松弛所有出边|
|非负权边（无 NC）|迪杰斯特拉算法（Dijkstra）|二叉堆：\(O(m\log n)\)；斐波那契堆：\(O(m + n\log n)\)|按距离递增扩展 SPT，优先选择距离最小的节点|
|无负环（允许负权边）|贝尔曼 - 福特算法（Bellman-Ford）|\(O(mn)\)|迭代松弛所有边，检测负环|

### 2. DAG 中的 SPT（CLRS 22.2）

#### 2.1 核心逻辑

- 动态规划思路：利用 DAG 的拓扑序，确保松弛边\((u,v)\)时，\(d(u)\)已为\(s-u\)的最短路径长度；
- 最长路径树（Longest-Path Tree）：翻转边权重（\(\ell' = -\ell\)），将最长路径问题转化为最短路径问题，递推公式改为：
    
    \(d(v) = \max_{(u,v) \in A} \{d(u) + \ell(u,v)\} \quad (\forall v \neq s)\)

#### 2.2 两种实现方式

|方式|逻辑|伪代码核心片段|
|---|---|---|
|拉取（Pull，惰性）|遍历节点，拉取前驱节点的最短路径|`for u按拓扑序 do; for each (u,v) ∈ A do; d(v) = min(d(v), d(u)+ℓ(u,v));`|
|推送（Push，主动）|遍历节点，推送更新后继节点|`for u按拓扑序 do; for each (u,v) ∈ A do; if d(u)+ℓ(u,v) < d(v) then d(v) = d(u)+ℓ(u,v);`|

- 时间 / 空间复杂度：均为\(O(m+n)\)。

### 3. 非负权有向图中的 SPT（CLRS 22.3）

#### 3.1 迪杰斯特拉算法（Dijkstra’s Method）

- 核心直觉：树扩展法，按 “到s的距离” 递增顺序将节点加入 SPT（T），未加入的节点构成候选集Q；
- 关键 invariant：已加入T的节点，其最短路径长度已确定（\(p(u) = d(u)\)）。

#### 3.2 优先队列实现

plaintext

```plaintext
// 初始化
for all v ∈ V do; d(v) = ∞; p(v) = null;
d(s) = 0; priority_queue Q ← {s};  // 按d(v)优先级排序

while Q非空 do
  u ← ExtractMin(Q);  // 选择距离最小的节点
  for each (u,v) ∈ A do
    if d(v) > d(u) + ℓ(u,v) then  // 松弛操作
      old_d = d(v);
      d(v) = d(u) + ℓ(u,v);
      p(v) = u;
      if old_d == ∞ then Insert(Q, v);
      else DecreaseKey(Q, v);
return d, p;
```

#### 3.3 注意事项

- 算法失效场景：图中存在负权边（即使是 DAG），会导致已加入T的节点距离被低估，无法更新；
- 优先队列选择：
    - 稠密图（\(m \approx n^2\)）：用数组实现优先队列，总复杂度\(O(n^2)\)；
    - 稀疏图（\(m \approx n\)）：用二叉堆，总复杂度\(O(m\log n)\)。

### 4. 无负环有向图中的 SPT（CLRS 22.1）

#### 4.1 贝尔曼 - 福特算法（Bellman-Ford Algorithm）

- **子问题定义**：\(d_k(v)\) = 用不超过k条边的\(s-v\)最短通路长度；
- 递推公式：
    
    \(d_0(s) = 0, \quad d_0(v) = ∞ \quad (v ≠ s)\)
    
    \(d_k(v) = \min\left\{d_{k-1}(v), \min_{(u,v) \in A} \{d_{k-1}(u) + ℓ(u,v)\}\right\}\)
- 单调性：\(d_{k-1}(v) ≥ d_k(v)\)（通路长度不会因允许更多边而增加）。

#### 4.2 负环检测（NC Detection）

- 核心结论：无负环 ⇨ \(d_{n-1}(v) = d_n(v)\)（n为节点数）；
    - 原因：n 个节点的最短路径最多含\(n-1\)条边（无环），若\(d_n(v) < d_{n-1}(v)\)，则存在含负环的通路；
- 负环查找：找到v使\(d_{n-1}(v) < d_n(v)\)，回溯v的前驱链，直至找到重复节点，构成负环。

#### 4.3 实现与应用

- 线性空间实现：用两个数组p（存储\(d_k\)）和\(p'\)（存储\(d_{k-1}\)），空间复杂度\(O(n)\)；
- 应用：
    - 互联网路由（分布式更新，“谣言路由”）；
    - 套利机会检测（货币汇率建模为图，负环对应套利）。

### 5. 全源最短路径（APSP，CLRS 23.2-3）

#### 5.1 弗洛伊德 - 沃夏尔算法（Floyd-Warshall Algorithm）

- **子问题定义**：\(d_k(i,j)\) = 仅用节点\(1..k\)作为中间节点的\(i-j\)最短路径长度；
- 递推公式：
    - 基础情况（\(k=0\)）：\(d_0(i,i)=0\)；\(d_0(i,j)=ℓ(i,j)\)（若\((i,j)∈A\)）；否则\(d_0(i,j)=∞\)；
    - 递归情况（\(k>0\)）：\(d_k(i,j) = \min\{d_{k-1}(i,j), d_{k-1}(i,k) + d_{k-1}(k,j)\}\)；
- 原地实现：空间复杂度\(O(n^2)\)，时间复杂度\(O(n^3)\)；
- 现状：最快已知算法时间复杂度为\(O(n^3 / \log^{100}n)\)，是否存在\(O(n^{3-\varepsilon})\)算法为开放问题。

## 练习题及答案

### 1. 几乎等权重边的最短路径（Practice: almost equal weights，Ex 22.3-9、22.3-12）

#### 问题描述

若所有边权重满足以下条件之一，设计线性时间的 SSSP 算法：

- 边权重仅为 1 或 2；
- 边权重 ∈ [1,2]。

#### 答案

- 核心思路：用**桶队列（Bucket Queue）** 替代优先队列，利用权重范围小的特性；
- 步骤：
    1. 初始化桶队列：按距离划分桶（如权重 1/2 时，桶为\(0,1,2,...,L_{max}\)，\(L_{max}\)为最大可能距离）；
    2. 松弛边时，将节点放入对应距离的桶中；
    3. 按距离递增顺序遍历桶，处理桶内节点，无需排序；
- 时间复杂度：\(O(m+n)\)（每个节点 / 边仅处理一次，桶操作为常数时间）。

### 2. 关键边（Vital Edge，41 题）

#### 问题描述

关键边定义：移除该边后，\(s-t\)最短路径长度增加。设计算法找到所有关键边，要求\(O(m)\)时间。

#### 答案

- 算法步骤：
    1. 计算s到所有节点的最短距离\(d_s\)，t到所有节点的最短距离\(d_t\)（反向图上的 SSSP）；
    2. 提取紧边集\(A_0 = \{(u,v) \in A \mid d_s(v) = d_s(u) + ℓ(u,v)\}\)（所有最短路径必含于\(A_0\)）；
    3. 构建子图\(G_0 = (V, A_0)\)，仅保留紧边；
    4. 在\(G_0\)中计算s到t的最大流（边容量为 1）；
    5. 判定：若最大流 > 1，则无关键边；否则，所有位于最小割中的边为关键边；
- 时间复杂度：\(O(m)\)（SSSP + 最大流（两次 BFS））。

### 3. 最关键边（Most Vital Edge，44 题）

#### 问题描述

最关键边定义：移除该边后，\(s-t\)最短路径长度增加最多。设计算法找到最关键边，并分析时间复杂度。

#### 答案

- 算法步骤：
    1. 计算原图中\(s-t\)的最短路径长度\(L = d_s(t)\)；
    2. 遍历所有紧边\(e=(u,v) \in A_0\)（非紧边移除不影响最短路径）：
        - 临时移除e，重新计算\(s-t\)的最短路径长度\(L_e\)；
        - 记录增量\(\Delta_e = L_e - L\)（若t不可达，\(\Delta_e = ∞\)）；
    3. 选择\(\Delta_e\)最大的边作为最关键边；
- 时间复杂度：\(O(m(m+n))\)（遍历\(O(m)\)条紧边，每条边移除后需\(O(m+n)\)时间重新计算 SSSP）。

### 4. 最关键边的判断题（Most Vital Edge，45 题）

#### 问题描述

假设图为有向图，边权重为正，存在关键边。判断以下命题真伪，需证明或给出反例：

(a) 最关键边是权重最大的边（\(ℓ_{ij}\)最大）；

(b) 最关键边是某条\(s-t\)最短路径上权重最大的边；

(c) 不位于任何\(s-t\)最短路径上的边，不可能是最关键边；

(d) 图中可能存在多条最关键边。

#### 答案

- (a) 假；反例：权重最大的边不在任何最短路径上，移除后不影响最短路径长度，增量为 0，不可能是最关键边；
- (b) 假；反例：最短路径\(s→a→b→t\)（权重 1+2+1=4），另一条路径\(s→c→t\)（权重 3+3=6）；边\((a,b)\)权重 2（最短路径上最大），移除后最短路径变为\(s→c→t\)（长度 6），增量 2；若存在边\((s,a)\)权重 1（最短路径上），移除后无其他路径可达t，增量为∞，比 (a,b) 更关键；
- (c) 真；证明：非紧边不在任何最短路径上，移除后最短路径长度不变（\(\Delta_e=0\)），而关键边的\(\Delta_e>0\)，故不可能是最关键边；
- (d) 真；示例：两条不相交的\(s-t\)最短路径（长度 L），每条路径上各有一条边，移除后最短路径长度均变为 L+Δ（Δ 相同），则这两条边均为最关键边。

### 5. 套利机会检测（Application: Arbitrage Opportunity）

#### 问题描述

给定 n 种货币及两两之间的汇率，判断是否存在套利机会（如 1 美元→欧元→英镑→美元，最终金额增加）。

#### 答案

- 建模思路：
    1. 构建有向图\(G=(V, A)\)，节点为货币，边\((i,j)\)权重为\(-\log(r_{ij})\)（\(r_{ij}\)为货币 i 到 j 的汇率）；
    2. 套利机会等价于图中存在负环（沿负环循环，总权重和为负，对应汇率乘积 > 1）；
- 算法：
    1. 任选源节点（如货币 1），运行贝尔曼 - 福特算法；
    2. 若检测到负环，则存在套利机会；否则无；
- 关键：汇率的对数转换将乘法问题转化为加法问题，负环对应套利




## 一、Practice: almost equal weights（Ex 22.3-9、22.3-12，CLRS）

### 问题描述

若所有边权重满足以下条件之一，设计线性时间（\(O(m+n)\)）的单源最短路径（SSSP）算法：

1. 边权重仅为 1 或 2；
2. 边权重 ∈ [1,2]（实数）。
    
    （提示：用桶队列（Bucket Queue）替代优先队列）

### 详细答案

#### （1）核心思路

边权重范围极小（仅 1-2 或连续区间 [1,2]），桶队列可按 “距离” 分层存储节点，无需排序，实现线性时间松弛。

- 桶队列：用数组（桶）存储节点，桶索引对应 “当前到源点的距离”，节点按距离入桶，按索引顺序处理，确保线性时间。

#### （2）实现步骤（边权为 1 或 2）

1. **初始化**
    
    - \(d[v] = ∞\)（所有节点距离），\(d[s] = 0\)（源点）；
    - 桶队列bucket：数组，索引为距离值，元素为该距离的节点列表；
    - 将s加入\(bucket[0]\)；
    - \(current\_dist = 0\)（当前处理的距离层）。
2. **桶队列处理与松弛**
    

plaintext

```plaintext
while current_dist < max_possible_dist:
  while bucket[current_dist]非空:
    u ← 取出bucket[current_dist]的一个节点;
    for each (u, v) ∈ E:
      weight = ℓ(u,v)  // 1或2
      if d[v] > d[u] + weight:
        if d[v] != ∞:
          从bucket[d[v]]中删除v;  // 更新距离，移出原桶
        d[v] = d[u] + weight;
        将v加入bucket[d[v]];  // 加入新距离桶
  current_dist += 1;
return d;
```

3. **边权 ∈ [1,2] 的扩展**

- 桶队列按 “距离整数部分” 分层，每个桶存储距离∈[k, k+1) 的节点；
- 处理时按 k 递增顺序，每个节点仅处理一次，松弛边后按新距离入桶，仍保持线性时间。

#### （3）正确性证明

- 桶队列按距离递增处理节点，确保节点出桶时\(d[u]\)已为最短距离（类似 Dijkstra 的贪心选择）；
- 边权范围小，桶数为\(O(D)\)（D 为最大距离），但因边权≥1，\(D ≤ 2(n-1)\)，桶数线性，总操作线性。

#### （4）时间复杂度

- 桶队列操作：\(O(n+m)\)（每个节点入桶 / 出桶各一次，每条边松弛一次）；
- 总复杂度：\(O(m+n)\)。

#### （5）示例

- 图：\(s→a(1), s→b(2), a→c(1), b→c(2)\)；
- 桶队列处理：
    - \(current_dist=0\)：处理s，松弛后a入桶 1，b入桶 2；
    - \(current_dist=1\)：处理a，松弛后c入桶 2；
    - \(current_dist=2\)：处理b和c，无新松弛；
- 距离：\(d[s]=0, d[a]=1, d[b]=2, d[c]=2\)。

## 二、Practice: vital edge（41 题）

### 问题描述

关键边（Vital Edge）定义：移除该边后，\(s-t\)的最短距离增加。设计算法找到所有关键边，要求\(O(m)\)时间。

### 详细答案

#### （1）核心思路

- 紧边集：所有最短路径必含于紧边集\(A_0 = \{(u,v) ∈ A | d(v) = d(u) + ℓ(u,v)\}\)（d为s到各节点的最短距离）；
- 子图\(G_0 = (V, A_0)\)：仅含紧边，关键边必在\(G_0\)中；
- 最大流判定：\(G_0\)中\(s-t\)的最大流（边容量为 1）若 > 1，则无关键边；否则，最小割中的边为关键边。

#### （2）实现步骤

1. **计算最短距离与紧边集**
    
    - 用 Dijkstra（非负权）或 Bellman-Ford（允许负权）计算\(d[s][v]\)（s到v）和\(d[t][v]\)（t到v，反向图 BFS/DFS）；
    - 紧边判定：\((u,v) ∈ A_0 \Leftrightarrow d[s][u] + ℓ(u,v) + d[t][v] = d[s][t]\)。
2. **构建子图\(G_0\)**
    
    - 节点：原节点；边：仅紧边\(A_0\)。
3. **计算\(G_0\)中\(s-t\)的最大流**
    
    - 用 Ford-Fulkerson 算法（BFS 实现，Edmonds-Karp），边容量为 1；
    - 因\(G_0\)是 DAG（无负环，紧边构成的图无环），最大流计算可优化至\(O(m)\)。
4. **关键边判定**
    
    - 若最大流 > 1：无关键边（存在多条边不相交的最短路径）；
    - 若最大流 = 1：找到所有最小割（\(S-T\)，\(s∈S, t∈T\)），割集中的边即为关键边。

#### （3）正确性证明

- 关键边必为紧边：非紧边不在任何最短路径上，移除不影响最短距离；
- 最大流 = 1：仅一条边不相交的最短路径，该路径上的边为最小割，移除后路径断裂，最短距离增加。

#### （4）时间复杂度

- 最短距离计算：\(O(m+n)\)；
- 紧边筛选：\(O(m)\)；
- 最大流计算：\(O(m)\)（DAG 优化）；
- 总复杂度：\(O(m)\)。

#### （5）示例

- 图：\(s→a→t\)（边权 1），\(s→b→a\)（边权 1）；
- 紧边集：\(s→a, a→t, s→b, b→a\)；
- 最大流：2（\(s→a→t\)和\(s→b→a→t\)），无关键边；
- 若移除\(b→a\)，最大流 = 1，\(s→a\)和\(a→t\)为关键边。

## 三、Practice: most vital edge（44 题）

### 问题描述

最关键边（Most Vital Edge）定义：移除该边后，\(s-t\)的最短距离增加最多。设计算法找到最关键边，并分析时间复杂度。

### 详细答案

#### （1）核心思路

- 仅紧边可能是最关键边（非紧边移除无影响）；
- 遍历所有紧边，移除后重新计算\(s-t\)的最短距离，记录增量\(\Delta_e = L_e - L\)（L为原最短距离，\(L_e\)为移除后距离）；
- 选择\(\Delta_e\)最大的边（若t不可达，\(\Delta_e = ∞\)）。

#### （2）实现步骤

1. **预处理**
    
    - 计算原最短距离\(L = d[s][t]\)，筛选紧边集\(A_0\)；
    - 若\(A_0\)为空：无最关键边（t原不可达）。
2. **遍历紧边，计算增量**
    

plaintext

```plaintext
max_delta = -∞;
most_vital_edge = null;
for each e = (u, v) ∈ A_0:
  临时移除e；
  重新计算s-t的最短距离L_e；
  delta = L_e - L；
  恢复e；
  if delta > max_delta:
    max_delta = delta；
    most_vital_edge = e；
return most_vital_edge；
```

3. **优化：减少重复计算**

- 对\(G_0\)（紧边子图）预处理所有节点对的最短距离，避免重复 BFS/DFS；
- 但因\(G_0\)是 DAG，预处理时间\(O(nm)\)，适用于小图。

#### （3）正确性证明

- 非紧边移除后\(L_e = L\)，增量为 0，不可能是最关键边；
- 紧边移除后，最短路径需绕行非紧边，增量最大的即为最关键边。

#### （4）时间复杂度

- 遍历紧边：\(O(m)\)（紧边数≤m）；
- 每次移除后计算 SSSP：\(O(m+n)\)；
- 总复杂度：\(O(m(m+n))\)。

#### （5）示例

- 图：\(s→a→t\)（边权 1），\(s→b→t\)（边权 3）；
- 原最短距离\(L=2\)；
- 紧边：\(s→a, a→t\)；
- 移除\(s→a\)：\(L_e=4\)，\(\Delta=2\)；
- 移除\(a→t\)：\(L_e=4\)，\(\Delta=2\)；
- 最关键边：\(s→a\)或\(a→t\)（增量相同）。

## 四、Practice: most vital edge 的判断题（45 题）

### 问题描述

假设图为有向图，边权重为正，存在关键边。判断以下命题真伪，需证明或给出反例：

(a) 最关键边是权重最大的边（\(\ell_{ij}\)最大）；

(b) 最关键边是某条\(s-t\)最短路径上权重最大的边；

(c) 不位于任何\(s-t\)最短路径上的边，不可能是最关键边；

(d) 图中可能存在多条最关键边。

### 详细答案

#### （a）命题：假

- 反例：图\(s→a→t\)（边权\(s→a=1, a→t=1\)），\(s→b→t\)（边权\(s→b=5, b→t=5\)）；
- 权重最大的边是\(s→b\)和\(b→t\)（权重 5），但它们不在最短路径上，移除后最短距离仍为 2，增量为 0；
- 最关键边是\(s→a\)或\(a→t\)，权重 1，移除后增量为 8（\(L_e=10\)）；
- 结论：最大权重边未必是最关键边。

#### （b）命题：假

- 反例：图\(s→a→b→t\)（边权\(1+2+1=4\)），\(s→c→t\)（边权\(3+3=6\)）；
- 最短路径上权重最大的边是\(a→b\)（2）；
- 移除\(a→b\)：最短路径变为\(s→c→t\)，\(L_e=6\)，增量 = 2；
- 移除\(s→a\)：最短路径变为\(s→c→t\)，\(L_e=6\)，增量 = 2；
- 另有反例：图\(s→a→t\)（1+3=4），\(s→b→a→t\)（1+1+3=5），\(s→d→t\)（5+5=10）；
- 最短路径上最大边是\(a→t\)（3），移除后增量 = 6（\(L_e=10\)）；
- 若添加边\(a→c→t\)（1+1=2），最短路径变为\(s→a→c→t\)（1+1+1=3），最大边是 1，移除\(s→a\)后增量 = 7（\(L_e=10\)），仍大于最大边的增量；
- 结论：最短路径上最大权重边未必是最关键边。

#### （c）命题：真

- 证明：不位于任何最短路径上的边为非紧边（\((u,v) ∉ A_0\)）；
- 移除非紧边后，所有最短路径仍存在（因最短路径仅含紧边），故\(L_e = L\)，增量 = 0；
- 最关键边的增量 > 0，故非紧边不可能是最关键边。

#### （d）命题：真

- 示例：图\(s→a→t\)（1+1=2），\(s→b→t\)（1+1=2）；
- 紧边：\(s→a, a→t, s→b, b→t\)；
- 移除\(s→a\)：\(L_e=2\)（仍有\(s→b→t\)），增量 = 0？不，修正示例：图\(s→a→t\)（1+2=3），\(s→b→a→t\)（1+1+2=4）；
- 紧边：\(s→a, a→t, s→b, b→a\)；
- 移除\(s→a\)：\(L_e=4\)，增量 = 1；
- 移除\(a→t\)：\(L_e=4\)，增量 = 1；
- 两条边增量相同，均为最关键边；
- 结论：图中可存在多条最关键边。

## 五、Application: Arbitrage opportunity（34 题）

### 问题描述

给定 n 种货币及两两之间的汇率，判断是否存在套利机会（如 1 美元→欧元→英镑→美元，最终金额增加）。

### 详细答案

#### （1）核心思路

- 建模为负环检测：汇率乘积 > 1 等价于对数和 < 0，将汇率转换为负对数权重，套利机会等价于图中存在负环；
- 用 Bellman-Ford 算法检测负环（因货币数量 n，最多 n-1 步松弛，第 n 步仍可松弛则存在负环）。

#### （2）实现步骤

1. **图建模**
    
    - 节点：每种货币（共 n 个）；
    - 边：若货币 i 到 j 的汇率为\(r_{ij}\)（1 单位 i 换\(r_{ij}\)单位 j），则边\(i→j\)的权重为\(-\ln(r_{ij})\)（乘积 > 1 ⇨ 权重和 < 0）。
2. **Bellman-Ford 检测负环**
    

plaintext

```plaintext
// 初始化
d[v] = ∞;
d[s] = 0;  // 任选源点s（如货币1）

// 松弛n-1次
for i from 1 to n-1:
  for each (u, v) ∈ E:
    if d[v] > d[u] + ℓ(u,v):
      d[v] = d[u] + ℓ(u,v);
      parent[v] = u;

// 检测负环
has_arbitrage = false;
for each (u, v) ∈ E:
  if d[v] > d[u] + ℓ(u,v):
    // 存在负环，回溯找到环
    has_arbitrage = true;
    // 回溯parent数组，找到环路径
    break;

return has_arbitrage;
```

3. **优化：Floyd-Warshall 检测所有负环**

- 因需检测任意货币的套利，Floyd-Warshall 可计算所有节点对的最短路径，检测是否存在\(d[i][i] < 0\)（自环负权，即套利）；
- 时间复杂度\(O(n^3)\)，适用于 n 较小的场景（货币种类通常较少）。

#### （3）正确性证明

- 套利机会 ⇨ 存在货币循环\(i_1→i_2→...→i_k→i_1\)，汇率乘积\(r_{i_1i_2}×...×r_{i_ki_1} > 1\)；
- 取对数：\(\ln(r_{i_1i_2}) + ... + \ln(r_{i_ki_1}) > 0\) ⇨ 权重和\(-(\ln(r_{i_1i_2}) + ...) < 0\) ⇨ 存在负环。

#### （4）时间复杂度

- Bellman-Ford：\(O(nm)\)（n 为货币数，m 为汇率对数）；
- Floyd-Warshall：\(O(n^3)\)；
- 实际应用中 n≤100，\(O(n^3)\)可行。

#### （5）示例

- 货币：美元（USD）、欧元（EUR）、英镑（GBP）；
- 汇率：USD→EUR=0.9，EUR→GBP=0.8，GBP→USD=1.4；
- 权重：USD→EUR=-ln (0.9)≈0.105，EUR→GBP=-ln (0.8)≈0.223，GBP→USD=-ln (1.4)≈-0.336；
- 循环权重和：0.105+0.223-0.336≈-0.008 < 0 ⇨ 存在套利；
- 套利路径：USD→EUR→GBP→USD，1×0.9×0.8×1.4=1.008 > 1。

## 六、Application: Single-duty crew scheduling（24 题）

### 问题描述

需安排司机覆盖 9am-5pm（共 8 小时，9-10、10-11、...、4-5，共 8 个时段），每个班次的时间区间和成本如下：

|班次|时间区间|成本|
|---|---|---|
|1|9-10|30|
|2|9-11|18|
|3|10-11|21|
|4|12-15|38|
|5|12-17|20|
|6|14-17|22|
|7|13-16|22|
|8|16-17|9|
|目标：找到覆盖所有时段的最小成本班次组合。|||

### 详细答案

#### （1）核心思路

- 建模为 DAG 的最短路径：节点为时间点（9、10、11、12、13、14、15、16、17），边为班次（从开始时间到结束时间，权重为成本）；
- 源点为 9，汇点为 17，找 9→17 的最短路径，路径上的边即为最小成本班次组合。

#### （2）实现步骤

1. **DAG 建模**
    
    - 节点：时间点\(t_0=9, t_1=10, ..., t_8=17\)（共 9 个节点）；
    - 边：对每个班次，若时间区间为\([a,b]\)，则添加边\(t_i→t_j\)（\(t_i=a, t_j=b\)），权重为班次成本；
    - 补充零成本边：\(t_i→t_{i+1}\)（覆盖单个时段，无对应班次时使用，成本 0）。
2. **拓扑排序 + 松弛（DAG 的 SSSP）**
    

plaintext

```plaintext
// 拓扑排序：按时间递增顺序（t0→t1→...→t8）
top_order = [9,10,11,12,13,14,15,16,17];

// 初始化距离
d[t] = ∞;
d[9] = 0;

// 按拓扑序松弛边
for t in top_order:
  for each (t, t') ∈ E:
    if d[t'] > d[t] + cost(t→t'):
      d[t'] = d[t] + cost(t→t');
      parent[t'] = t;  // 记录班次

// 回溯找到班次组合
path = [];
current = 17;
while current != 9:
  prev = parent[current];
  path.append(班次(prev→current));
  current = prev;
path.reverse();

return d[17], path;
```

3. **优化：合并零成本边**

- 零成本边仅用于填充无班次的时段，可直接在松弛时忽略，仅处理实际班次，最后检查是否覆盖所有时段。

#### （3）正确性证明

- DAG 无环，拓扑序松弛确保最短路径正确；
- 路径覆盖所有时段：从 9 到 17 的路径必经过所有中间时间点，对应班次覆盖所有时段；
- 最短路径对应最小成本。

#### （4）时间复杂度

- 节点数：9，边数：8（班次）+8（零成本）=16；
- 拓扑排序：\(O(n)\)（已按时间排序）；
- 松弛：\(O(m)\)；
- 总复杂度：\(O(n+m) = O(1)\)（规模极小）。

#### （5）示例计算

- 拓扑序：9→10→11→12→13→14→15→16→17；
- 松弛过程：
    - \(d[9]=0\)；
    - 边 9→10（成本 30）：\(d[10]=30\)；边 9→11（成本 18）：\(d[11]=18\)；
    - 边 10→11（成本 21）：\(d[11] = min(18, 30+21)=18\)；
    - 边 12→15（38）、12→17（20）：\(d[15]=38\)，\(d[17]=20\)；
    - 边 14→17（22）：\(d[17] = min(20, d[14]+22)\)；
    - 边 16→17（9）：\(d[17] = min(20, d[16]+9)\)；
- 最终\(d[17]=18+20=38\)？修正：实际最优组合为班次 2（9-11，18）+ 班次 5（12-17，20），覆盖 9-11、12-17，中间 11-12 用零成本边，总成本 18+20=38；
- 或班次 2（18）+ 班次 7（13-16，22）+ 班次 8（16-17，9）：18+22+9=49，高于 38；
- 最优解：成本 38，班次组合为 [9-11, 12-17]。