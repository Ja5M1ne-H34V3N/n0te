# 基础图算法（Elementary Graph Algorithms）

## 核心知识点

### 1. 图的基本概念（Graphs）

#### 1.1 定义与分类

- **有向图（Directed Graph）**：\(G=(V, E)\)，边为有序对\((u, v)\)（从u指向v），核心术语：入度（in-degree）、出度（out-degree）；
- **无向图（Undirected Graph）**：边为无序对，满足对称性（\((u, v) \in E \Leftrightarrow (v, u) \in E\)），核心术语：度（degree）；
- 本质：二元关系的可视化表示，适用于描述节点间的关联（如课程依赖、航线网络）。

#### 1.2 图的基本表示

|表示方法|有向图实现|无向图实现|空间复杂度|适用场景|
|---|---|---|---|---|
|邻接表（Adjacency List）|节点索引数组，存储**出邻居**列表|节点索引数组，存储**所有邻居**列表|\(O(m+n)\)|稀疏图（\(m \ll n^2\)）|
|邻接矩阵（Adjacency Matrix）|\(n \times n\) 0-1 矩阵，\(A[u][v]=1\) 表示有边\((u, v)\)|\(n \times n\) 对称 0-1 矩阵，\(A[u][v]=1\) 表示有边\((u, v)\)|\(O(n^2)\)|稠密图（\(m \approx n^2\)）|

#### 1.3 关键性质与术语

- **度数性质**：
    - 有向图：所有节点的出度之和 = 边数 = 所有节点的入度之和；
    - 无向图（握手定理）：所有节点的度之和 = \(2 \times\) 边数；
- **路径相关术语**：
    - 通路（Walk）：沿边的任意遍历（可重复节点 / 边）；
    - 迹（Trail）：无重复边的通路（必有限）；
    - 路径（Path）：无重复节点的通路（必有限）；
    - 环（Cycle/Circuit）：起点 = 终点的路径（无重复节点 / 边）；
- **连通性**：
    - 无向图连通：任意两节点间存在路径；
    - 有向图强连通：任意两节点\(u, v\)，均存在\(u \to v\)和\(v \to u\)的路径。

### 2. 拓扑排序（Topological Sorting in DAG）

#### 2.1 核心概念

- **有向无环图（DAG）**：无环的有向图，必存在至少一个**源点**（入度为 0）和一个**汇点**（出度为 0）；
- **拓扑序**：节点排序满足 “对任意边\((u, v)\)，u在排序中位于v之前”；
- 核心性质：图有拓扑序 **当且仅当** 图是 DAG。

#### 2.2 Kahn 算法（Kahn 1962，线性时间）

- 核心逻辑：迭代移除源点，更新邻居节点入度，直至所有节点移除（得拓扑序）或无源点（存在环）。
- 伪代码：

plaintext

```plaintext
// 初始化
L ← 空列表（存储拓扑序）;
S ← 所有入度为0的节点;
indegree[v] ← 节点v的初始入度;

while S非空 do
  u ← 从S中取出一个节点;
  L ← L ∪ {u};
  for 每个(u, v) ∈ E do
    indegree[v] ← indegree[v] - 1;  // 移除边(u, v)
    if indegree[v] == 0 then
      S ← S ∪ {v};

// 结果判断
if L包含所有节点 then return L（拓扑序）;
else return 图中存在环（从剩余节点回溯查找）;
```

- 时间复杂度：\(O(m+n)\)。

#### 2.3 扩展应用：环检测

- 若 Kahn 算法终止后，L未包含所有节点，则剩余节点构成环，可通过 “父节点回溯” 线性时间找到环。

### 3. 广度优先搜索（Breadth-First Search，BFS）

#### 3.1 核心思想

- **分层探索**：从源点s出发，按 “距离递增” 顺序访问节点，形成层状划分（\(V_0=\{s\}, V_1, V_2, ...\)）；
- 距离定义：\(V_i\)中的节点到s的距离（最短路径长度）恰好为i；
- 数据结构：队列（FIFO），保证分层访问顺序。

#### 3.2 算法实现

plaintext

```plaintext
BFS(s):
  for 所有v ∈ V do
    color[v] ← 白色（未访问）;
    distance[v] ← ∞;
    parent[v] ← null;
  color[s] ← 灰色（访问中）;
  distance[s] ← 0;
  queue ← {s};
  while queue非空 do
    u ← dequeue(queue);
    for 每个(u, v) ∈ E do
      if color[v] == 白色 then  // 未访问节点（孤儿节点）
        color[v] ← 灰色;
        distance[v] ← distance[u] + 1;
        parent[v] ← u;
        enqueue(queue);
    color[u] ← 黑色（访问完成）;
return distance, parent;
```

- 时间复杂度：\(O(m+n)\)；
- 衍生结构：**最短路径树（SPT）**，以s为根，树路径即为节点到s的最短路径。

#### 3.3 边的分类（有向图 / 无向图）

|图类型|边的类型|定义|
|---|---|---|
|有向图|树边（Tree Edge）|访问v时的边\((u, v)\)（\(parent[v]=u\)）|
||前向边（Forward Edge）|从\(V_i\)到\(V_j\)（\(j > i+1\)）的非树边|
||侧向边（Side Edge）|同一层\(V_i\)内的边|
||回边（Back Edge）|从\(V_i\)到\(V_j\)（\(j < i\)）的边（含环）|
|无向图|树边（Tree Edge）|访问v时的边\((u, v)\)|
||交叉边（Cross Edge）|不同子树间的边（必为相邻层）|

#### 3.4 典型应用

1. **连通性检测**：
    - 无向图：BFS 访问所有节点 → 连通；
    - 有向图强连通：两次 BFS（原 graph + 反向 graph），均访问所有节点 → 强连通；
2. **二分图检测**：BFS 分层染色，若相邻节点颜色相同 → 非二分图（等价于无奇数环）；
3. **泛洪填充（Flood Fill）**：图像中连通像素的颜色替换（节点 = 像素，边 = 相邻像素）；
4. **最短奇偶路径**：构造奇偶状态图\(G'\)（每个节点拆分为\((v,0)\)和\((v,1)\)），BFS 找最短偶 / 奇长度路径。

### 4. 深度优先搜索（Depth-First Search，DFS）

#### 4.1 核心思想

- **深度探索**：从源点s出发，沿一条路径尽可能深入，无法前进时回溯；
- **探索区间**：记录每个节点的访问时间\(on(v)\)（首次访问）和完成时间\(off(v)\)（探索完所有邻居），形成区间\(I(v)=[on(v), off(v)]\)；
- 数据结构：栈（递归或显式栈）。

#### 4.2 节点排序

- 前序（Pre-order）：按\(on(v)\)递增排序；
- 后序（Post-order）：按\(off(v)\)递增排序；
- 逆后序（Reverse Post-order）：按\(off(v)\)递减排序（DAG 的逆后序即为拓扑序）。

#### 4.3 递归实现

plaintext

```plaintext
clock ← 0;
DFS(G):
  for 所有v ∈ V do
    parent[v] ← null;
    color[v] ← 白色;
  for 所有v ∈ V do
    if color[v] == 白色 then
      VISIT(v);
return parent, on, off;

VISIT(u):
  color[u] ← 灰色（开始访问）;
  clock ← clock + 1;
  on[u] ← clock;
  for 每个(u, v) ∈ E do
    if color[v] == 白色 then
      parent[v] ← u;
      VISIT(v);
  color[u] ← 黑色（访问完成）;
  clock ← clock + 1;
  off[u] ← clock;
```

- 时间复杂度：\(O(m+n)\)。

#### 4.4 关键不变性质

1. 父子节点的探索区间嵌套：若u是v的父节点，则\(I(v) \subseteq I(u)\)；
2. 不同树的探索区间不相交：若u和v属于不同 DFS 树，则\(I(u) \cap I(v) = \emptyset\)；
3. 边的时间性质：对任意边\((u, v)\)，\(on(v) < off(u)\)。

#### 4.5 典型应用

1. **连通分量求解**：
    - 无向图：重复 DFS/BFS，每次访问的节点集为一个连通分量；
    - 有向图强连通分量（Kosaraju-Sharir 算法）：
        1. 对G执行 DFS，记录逆后序；
        2. 对反向图\(G^{rev}\)按逆后序执行 DFS，每次访问的节点集为一个强连通分量；
        3. 时间复杂度：\(O(m+n)\)；
2. **环检测**：DFS 中遇到回边 → 存在环；
3. **拓扑排序**：DAG 的 DFS 逆后序即为拓扑序。

## 练习题及答案

### 1. 无环竞赛图（Acyclic Tournament，Practice 24）

#### 问题描述

竞赛图T（任意两节点间有且仅有一条边），证明以下命题等价（TFAE）：

1. T是无环的；
2. T不含长度为 3 的环；
3. T是传递的（若有\(u \to v\)和\(v \to w\)，则有\(u \to w\)）；
4. T是严格全序（存在拓扑序，且任意两节点的边方向与拓扑序一致）；
5. 得分序列（出度集合）为\(\{0, 1, 2, ..., n-1\}\)；
6. T恰好有一条哈密顿路径（经过所有节点的路径）。

#### 答案

- 核心逻辑：竞赛图的无环性等价于传递性，进而推导其他性质：
    1. \(1 \Rightarrow 2\)：无环 → 自然无 3 环；
    2. \(2 \Rightarrow 3\)：反证，若不传递（\(u \to v, v \to w\)但\(w \to u\)），则构成 3 环，矛盾；
    3. \(3 \Rightarrow 4\)：传递竞赛图的拓扑序即为严格全序（边方向与排序一致）；
    4. \(4 \Rightarrow 5\)：拓扑序中第i个节点的出度为\(n-i\)，得分序列为\(\{0,1,...,n-1\}\)；
    5. \(5 \Rightarrow 6\)：按得分递增排序，形成唯一哈密顿路径；
    6. \(6 \Rightarrow 1\)：哈密顿路径存在且唯一，无环（否则存在多条哈密顿路径）。

### 2. 寿命一致性检查（Consistency in Life Spans，Practice 25）

#### 问题描述

给定n个人\(P_1..P_n\)的m个事实：

- 类型 1：\(P_i\)在\(P_j\)出生前死亡（\(P_i \prec P_j\)）；
- 类型 2：\(P_i\)和\(P_j\)的寿命重叠（无先后关系）；
    
    目标：判断这些事实是否内部一致（存在满足所有事实的寿命安排），要求\(O(n+m)\)时间。

#### 答案

- 算法思路：构造有向图 + 拓扑排序，检测是否存在环：
    1. 构造有向图G：
        - 对类型 1 事实\(P_i \prec P_j\)，添加边\(P_i \to P_j\)（表示\(P_i\)的时间在\(P_j\)之前）；
        - 对类型 2 事实（重叠），不添加边（无先后约束）；
    2. 执行 Kahn 算法：
        - 若存在拓扑序 → 事实一致（按拓扑序安排寿命，类型 1 满足先后，类型 2 可重叠）；
        - 若存在环 → 事实矛盾（如\(P_i \prec P_j, P_j \prec P_k, P_k \prec P_i\)，无法安排寿命）。
- 时间复杂度：\(O(n+m)\)（图构造 + 拓扑排序）。

### 3. DAG 的割点（Cut Vertex in DAG，Practice 26）

#### 问题描述

给定 DAG\(G=(V, E)\)（唯一源点s，唯一汇点t），割点v定义为 “删除v后，t不可达于s”。设计线性时间算法找出所有割点。

#### 答案

- 核心观察：割点是\(s \to t\)所有路径的必经节点（即支配点，Dominator）；
- 算法步骤：
    1. 对 DAG 执行拓扑排序，得到节点顺序\(v_1=s, v_2, ..., v_n=t\)；
    2. 计算每个节点v的 “可达前驱集”\(R(v)\)（所有能到达v的节点）：
        - 初始化\(R(s) = \{s\}\)；
        - 按拓扑序遍历节点，对v的每个入边\((u, v)\)，\(R(v) = R(v) \cup R(u)\)；
    3. 割点判定：对\(v \in V \setminus \{s, t\}\)，若\(R(t) \setminus R(v) = \emptyset\)（删除v后，t无可达前驱），则v是割点；
- 优化：用位运算或差集快速计算\(R(v)\)，时间复杂度\(O(m+n)\)。

### 4. 普吕弗编码（Prüfer Code of a Labeled Tree，Practice 27）

#### 问题描述

带标签树T的普吕弗编码\(P=(p_1, p_2, ..., p_{n-2})\)，编码规则：迭代删除 “最小叶子节点”，记录其邻居标签，直至剩余 2 个节点。示例：树节点\(1-7\)，编码过程删除叶子 2、3、6，编码为\([1,7,5]\)。

- 问题 1：设计\(O(n\log n)\)编码算法，挑战\(O(n)\)；
- 问题 2：设计\(O(n\log n)\)解码算法，挑战\(O(n)\)。

#### 答案

##### （1）编码算法（\(O(n\log n)\)）

1. 用优先队列（最小堆）维护所有叶子节点（度为 1 的节点）；
2. 初始化：计算所有节点的度，将度为 1 的节点加入堆；
3. 迭代\(n-2\)次：
    - 取出堆顶（最小叶子\(v_i\)）；
    - 找到\(v_i\)的邻居u，记录\(p_i = u\)；
    - 节点u的度减 1，若度变为 1，加入堆；
4. 输出编码\(P=(p_1,...,p_{n-2})\)；

- 优化至\(O(n)\)：用链表维护叶子节点，避免堆操作。

##### （2）解码算法（\(O(n\log n)\)）

1. 初始化：
    - 统计编码中每个节点的出现次数\(cnt[u]\)（节点u的度 = \(cnt[u] + 1\)）；
    - 用优先队列维护度为 1 的节点（初始为编码中未出现的节点，或出现次数为 0 且度为 1 的节点）；
2. 迭代\(n-2\)次：
    - 取出堆顶（最小叶子v）；
    - 编码第i位\(p_i = u\)，添加边\((v, u)\)；
    - \(cnt[u]\)减 1，节点u的度减 1，若度变为 1，加入堆；
3. 最后，将剩余两个度为 1 的节点连边，得到树T；

- 优化至\(O(n)\)：用数组维护节点度和出现次数，线性遍历找最小叶子。

### 5. 法国国旗路径（French Flag Walk，Practice 45）

#### 问题描述

有向图G的边颜色为蓝（B）、白（W）、红（R），法国国旗路径定义为 “边颜色序列按 B→W→R→B→W→R... 循环”。找到从给定节点出发，所有可通过法国国旗路径到达的节点。

#### 答案

- 核心思路：状态扩展（节点 + 当前颜色状态），BFS 遍历所有合法状态；
- 算法步骤：
    1. 定义状态\((v, c)\)，其中v为节点，\(c \in \{B, W, R, \emptyset\}\)（\(\emptyset\)表示未走任何边）；
    2. 初始状态：\((s, \emptyset)\)（起点，未走边，下一条边可为 B）；
    3. BFS 规则：
        - 若当前状态为\((v, \emptyset)\)，下一条边可走 B，转移至\((u, B)\)（\(v \to u\)为蓝边）；
        - 若当前状态为\((v, B)\)，下一条边可走 W，转移至\((u, W)\)（\(v \to u\)为白边）；
        - 若当前状态为\((v, W)\)，下一条边可走 R，转移至\((u, R)\)（\(v \to u\)为红边）；
        - 若当前状态为\((v, R)\)，下一条边可走 B，转移至\((u, B)\)（\(v \to u\)为蓝边）；
    4. 收集所有可达状态中的节点，即为结果；
- 时间复杂度：\(O(m+n)\)（状态数为4n，边数为m）。

### 6. 最短环（Shortest Cycle，Practice 46）

#### 问题描述

分别为有向图和无向图，找到最短环的长度。

#### 答案

##### （1）无向图最短环

- 算法：对每个节点s执行 BFS，记录s到各节点的距离\(d[v]\)：
    - 当访问边\((u, v)\)且v已访问（非父节点），则环长为\(d[u] + d[v] + 1\)；
    - 遍历所有节点，记录最小环长；
- 时间复杂度：\(O(n(m+n))\)（稠密图最优）；
- 优化：对稀疏图，可提前终止 BFS（环长超过当前最小环长时）。

##### （2）有向图最短环

- 算法：对每个节点s执行 BFS，记录s到各节点的距离\(d[v]\)：
    - 当访问边\((u, v)\)且\(v = s\)，则环长为\(d[u] + 1\)；
    - 当访问边\((u, v)\)且v已访问（\(d[v] \neq \infty\)），则环长为\(d[u] + 1 + d'[v]\)（\(d'[v]\)为v到s的距离，可提前预处理）；
- 时间复杂度：\(O(n(m+n))\)。

### 7. 最短路径计数（Counting Shortest Paths，Practice 47）

#### 问题描述

无向连通图G，源点s，\(f(v)\)为\(s \to v\)的最短路径数。设计线性时间算法计算所有\(f(v)\)。

#### 答案

- 算法思路：BFS 分层 + 计数递推；
- 步骤：
    1. 执行 BFS，得到各节点到s的最短距离\(d[v]\)；
    2. 初始化：\(f(s) = 1\)，其他\(f(v) = 0\)；
    3. 按 BFS 分层顺序（距离递增）遍历节点：
        - 对节点v的每个邻居u，若\(d[v] = d[u] + 1\)（u是v的最短路径前驱），则\(f(v) += f(u)\)；
- 时间复杂度：\(O(m+n)\)（BFS + 一次遍历）。

### 8. 最短 s-t 路径上的边 / 节点（Practice 48）

#### 问题描述

有向图G，源点s，汇点t，找到所有位于某条最短\(s \to t\)路径上的边和节点。

#### 答案

- 算法步骤：
    1. 正向 BFS/DFS：计算s到所有节点的最短距离\(d_s[v]\)；
    2. 反向 BFS/DFS（构造反向图\(G^{rev}\)）：计算t到所有节点的最短距离\(d_t[v]\)（即原 graph 中v到t的最短距离）；
    3. 最短路径长度\(L = d_s[t]\)；
    4. 节点判定：节点v在最短路径上 **当且仅当** \(d_s[v] + d_t[v] = L\)；
    5. 边判定：边\((u, v)\)在最短路径上 **当且仅当** \(d_s[u] + 1 + d_t[v] = L\)（假设边权为 1，若边权为w，则改为\(d_s[u] + w + d_t[v] = L\)）；
- 时间复杂度：\(O(m+n)\)（两次 BFS/DFS）。

### 9. 核心顶点（Core Vertices，Practice 61）

#### 问题描述

有向图G，核心顶点v定义为 “所有节点均可从v到达”。设计线性时间算法找到所有核心顶点。

#### 答案

- 核心观察：所有核心顶点必属于同一个强连通分量（SCC），且该 SCC 是 condensation 图（强连通分量缩点后的 DAG）的汇点；
- 算法步骤：
    1. 用 Kosaraju 算法找到所有强连通分量（SCC），构造 condensation 图\(G_{cond}\)（每个节点代表一个 SCC）；
    2. 找到\(G_{cond}\)的汇点 SCC（出度为 0 的 SCC）；
    3. 验证：若汇点 SCC 的节点能到达所有其他节点（即\(G_{cond}\)只有一个汇点 SCC），则该 SCC 的所有节点为核心顶点；否则无核心顶点；
- 时间复杂度：\(O(m+n)\)（强连通分量求解 + condensation 图构造 + 验证）。

### 10. 最大不相交最短 s-t 路径（Practice 62）

#### 问题描述

有向图G，源点s，汇点t，找到 “包含关系极大” 的边不相交 / 内部节点不相交最短\(s \to t\)路径（无需最大数量，只需无法添加更多不相交路径），要求线性时间。

#### 答案

##### （1）边不相交最短路径

- 算法步骤：
    1. 计算s到所有节点的最短距离\(d_s[v]\)，t到所有节点的最短距离\(d_t[v]\)，最短路径长度\(L = d_s[t]\)；
    2. 保留最短路径子图\(G_{sp}\)：仅包含满足\(d_s[u] + 1 + d_t[v] = L\)的边\((u, v)\)；
    3. 在\(G_{sp}\)中用 DFS/BFS 找\(s \to t\)路径，标记路径上的边为 “已使用”，重复直至无路径；
    4. 得到的路径集合即为极大边不相交最短路径。

##### （2）内部节点不相交最短路径

- 算法步骤：
    1. 构造分层图：按最短距离\(d_s[v]\)将节点分为\(Level 0=\{s\}, Level 1, ..., Level L=\{t\}\)；
    2. 保留分层边：仅保留从Level i到\(Level i+1\)的边（属于最短路径）；
    3. 在分层图中用 DFS/BFS 找\(s \to t\)路径，标记路径上的内部节点为 “已使用”，重复直至无路径；
    4. 得到的路径集合即为极大内部节点不相交最短路径。
- 时间复杂度：\(O(m+n)\)（最短距离计算 + 路径查找）。




## 一、Practice 24：Acyclic Tournament（无环竞赛图）

### 问题描述

竞赛图T（任意两节点间有且仅有一条边），证明以下命题等价（TFAE）：

1. T是无环的；
2. T不含长度为 3 的环；
3. T是传递的（若有u→v和v→w，则有u→w）；
4. T是严格全序（存在拓扑序，且任意两节点的边方向与拓扑序一致）；
5. 得分序列（出度集合）为{0,1,2,...,n−1}；
6. T恰好有一条哈密顿路径（经过所有节点的路径）。

### 详细答案

#### （1）核心思路：命题间的循环推导（1→2→3→4→5→6→1）

通过 “反证法 + 构造法” 证明相邻命题等价，形成逻辑闭环。

#### （2）分步证明

##### 1→2：无环→不含 3 环

- 反证：若T含 3 环u→v,v→w,w→u，则T存在环，与 “无环” 矛盾，故命题 2 成立。

##### 2→3：不含 3 环→传递性

- 反证：假设T不传递，即存在u→v,v→w但w→u，则u,v,w构成 3 环，与命题 2 矛盾，故传递性成立。

##### 3→4：传递性→严格全序

- 构造拓扑序：按任意节点顺序遍历，若u→v则u在v前。因传递性，边方向与排序一致，无环，故为严格全序。

##### 4→5：严格全序→得分序列为{0,1,...,n−1}

- 设拓扑序为v1​,v2​,...,vn​，由严格全序性质，vi​指向所有vj​（j>i），故出度为n−i，得分序列为{0,1,...,n−1}。

##### 5→6：得分序列为{0,1,...,n−1}→恰好一条哈密顿路径

- 构造路径：按得分递增排序节点（出度）（出度）（出度）。因vi​出度为i−1，必指向vi+1​,...,vn​，故路径v1​→v2​→...→vn​是唯一哈密顿路径。

##### 6→1：恰好一条哈密顿路径→无环

- 反证：若T有环，则环中节点可形成两条不同哈密顿路径（顺时针 / 逆时针），与 “恰好一条” 矛盾，故无环。

#### （3）结论

六个命题等价，无环竞赛图的核心特性是 “传递性” 和 “严格全序”。

## 二、Practice 25：Consistency in Life Spans（寿命一致性检查）

### 问题描述

给定n个人P1​..Pn​的m个事实：

- 类型 1：Pi​在Pj​出生前死亡（Pi​≺Pj​）；
- 类型 2：Pi​和Pj​的寿命重叠（无先后关系）；
    
    目标：判断事实是否内部一致（存在满足所有事实的寿命安排），要求O(n+m)时间。

### 详细答案

#### （1）核心思路：构造有向图 + 拓扑排序，检测环

- 类型 1 事实转化为有向边（先后约束），类型 2 无约束；
- 若图存在拓扑序→事实一致；若存在环→事实矛盾。

#### （2）实现步骤

1. **构造有向图G=(V,E)**
    
    - 节点：每个人P1​..Pn​；
    - 边：对类型 1 事实Pi​≺Pj​，添加边Pi​→Pj​（表示Pi​的时间在Pj​前）。
2. **执行 Kahn 算法（拓扑排序）**
    
    plaintext
    
    ```plaintext
    // 初始化
    L ← 空列表（拓扑序）;
    S ← 所有入度为0的节点;
    indegree[v] ← 节点v的初始入度;
    
    while S非空 do
      u ← 取出S中一个节点;
      L ← L ∪ {u};
      for each (u, v) ∈ E do
        indegree[v] ← indegree[v]-1;
        if indegree[v] == 0 then
          S ← S ∪ {v};
    
    // 判定
    if |L| == n then return 一致;
    else return 矛盾（存在环）;
    ```
    

#### （3）正确性证明

- 一致→拓扑序存在：按拓扑序安排寿命，类型 1 的先后约束满足，类型 2 可重叠；
- 矛盾→环存在：如Pi​≺Pj​,Pj​≺Pk​,Pk​≺Pi​，无法安排寿命。

#### （4）时间复杂度

- 图构造：O(m)；
- 拓扑排序：O(n+m)；
- 总复杂度：O(n+m)。

#### （5）示例

- 事实：P1≺P2,P2≺P3,P1≺P3→图无环，拓扑序[P1,P2,P3]→一致；
- 事实：P1≺P2,P2≺P3,P3≺P1→图有环→矛盾。

## 三、Practice 26：Cut Vertex in DAG（DAG 的割点）

### 问题描述

给定 DAGG=(V,E)（唯一源点s，唯一汇点t），割点v定义为 “删除v后，t不可达于s”。设计线性时间算法找出所有割点。

### 详细答案

#### （1）核心思路：割点 = 所有s→t路径的必经节点（支配点）

利用拓扑排序和 “可达前驱集” 判定必经节点。

#### （2）实现步骤

1. **拓扑排序**：对 DAG 执行 Kahn 算法，得到拓扑序v1​=s,v2​,...,vn​=t。
    
2. **计算可达前驱集R(v)**
    
    - 定义：R(v)是所有能到达v的节点集合；
    - 初始化：R(s)={s}；
    - 按拓扑序递推：对v的每个入边(u,v)，R(v)=R(v)∪R(u)（用位运算或哈希集高效合并）。
3. **割点判定**
    
    - 对v∈V∖{s,t}，若R(t)∖R(v)=∅（删除v后，t无可达前驱），则v是割点。

#### （3）优化：高效计算R(v)

- 用位掩码存储R(v)（适用于n≤64），合并操作O(1)；
- 对大数据量，用差集标记，避免存储完整集合。

#### （4）时间复杂度

- 拓扑排序：O(n+m)；
- 可达前驱集计算：O(n+m)；
- 总复杂度：O(n+m)。

#### （5）示例

DAG：s→a→t,s→b→a→拓扑序[s,b,a,t]；

- R(s)={s},R(b)={s,b},R(a)={s,b,a},R(t)={s,b,a,t}；
- 判定：a的R(t)∖R(a)={t}∖{s,b,a,t}=∅→a是割点；b的R(t)∖R(b)={a,t}=∅→非割点。

## 四、Practice 27：Prüfer Code of a Labeled Tree（普吕弗编码）

### 问题描述

带标签树T的普吕弗编码P=(p1​,p2​,...,pn−2​)：迭代删除 “最小叶子节点”，记录其邻居标签，直至剩余 2 个节点。要求：

- Q1：编码（O(nlogn)时间，挑战O(n)）；
- Q2：解码（O(nlogn)时间，挑战O(n)）。

### 详细答案

#### （1）Q1：编码算法

##### 方法 1：O(nlogn)（优先队列）

plaintext

```plaintext
// 初始化
degree[v] ← 节点v的度;
min_heap ← 所有度为1的节点（叶子）;
P ← 空列表;

for i from 1 to n-2 do
  v ← ExtractMin(min_heap);  // 最小叶子
  u ← v的邻居;
  P.append(u);  // 记录邻居标签
  degree[u] ← degree[u]-1;
  if degree[u] == 1 then
    Insert(min_heap, u);  // u变为叶子

return P;
```

##### 方法 2：O(n)（链表 + 指针）

- 用数组记录每个节点的前驱 / 后继（维护叶子链表）；
- 用指针指向当前最小叶子，删除后快速找到下一个最小叶子，避免堆操作。

#### （2）Q2：解码算法

##### 方法 1：O(nlogn)（优先队列）

plaintext

```plaintext
// 初始化
cnt[u] ← 编码中u的出现次数;
degree[u] ← cnt[u] + 1;  // 节点u的度=出现次数+1
min_heap ← 所有度为1的节点;
edges ← 空列表;

for i from 1 to n-2 do
  v ← ExtractMin(min_heap);  // 最小叶子
  u ← P[i];  // 编码中的邻居
  edges.append((v,u));
  degree[u] ← degree[u]-1;
  if degree[u] == 1 then
    Insert(min_heap, u);

// 连接最后两个叶子
v1 ← ExtractMin(min_heap);
v2 ← ExtractMin(min_heap);
edges.append((v1,v2));

return edges;
```

##### 方法 2：O(n)（数组 + 指针）

- 用数组维护节点度和出现次数；
- 用链表存储叶子节点，快速找到最小叶子，无需堆排序。

#### （3）示例

- 树节点1−7，删除叶子顺序2,3,6→编码[1,7,5]；
- 解码：编码[1,7,5]→cnt=[0,2,0,1,0,1,0]→degree=[0,3,1,2,1,2,1]→逐步连接得到原树。

#### （4）时间复杂度

- O(nlogn)：优先队列操作主导；
- O(n)：链表 + 指针，线性遍历无排序。

## 五、Practice 45：French Flag Walk（法国国旗路径）

### 问题描述

有向图G的边颜色为蓝（B）、白（W）、红（R），法国国旗路径定义为 “边颜色序列按 B→W→R→B→W→R... 循环”。找到从给定节点出发，所有可通过法国国旗路径到达的节点。

### 详细答案

#### （1）核心思路：状态扩展 + BFS

- 定义状态(v,c)：v为当前节点，c∈{B,W,R}为下一条边需满足的颜色（初始状态(s,B)，第一条边需为 B）；
- 按颜色循环规则转移状态，BFS 遍历所有可达状态。

#### （2）实现步骤

1. **状态定义**
    
    - 初始状态：(s,B)（从s出发，第一条边需为 B）；
    - 转移规则：
        - 若当前状态(v,B)，下一条边为 W→状态(u,W)；
        - 若当前状态(v,W)，下一条边为 R→状态(u,R)；
        - 若当前状态(v,R)，下一条边为 B→状态(u,B)。
2. **BFS 遍历**
    

plaintext

```plaintext
// 初始化
visited ← 二维数组（visited[v][c]表示状态(v,c)是否访问）;
queue ← [(s, B)];
visited[s][B] ← true;
result ← {s};  // 初始节点可达

while queue非空 do
  (v, next_color) ← Dequeue(queue);
  for each (v, u) ∈ E do
    edge_color ← 边(v,u)的颜色;
    if edge_color != next_color then
      continue;
    // 确定下一个状态的目标颜色
    if next_color == B then
      new_color ← W;
    elif next_color == W then
      new_color ← R;
    else  // R
      new_color ← B;
    if not visited[u][new_color] then
      visited[u][new_color] ← true;
      result.add(u);
      Enqueue(queue, (u, new_color));

return result;
```

#### （3）时间复杂度

- 状态数：3n（每个节点 3 种颜色状态）；
- 边遍历：O(m)；
- 总复杂度：O(n+m)。

#### （4）示例

- 图：sB​aW​bR​cB​d；
- 可达节点：s,a,b,c,d；
- 状态转移：(s,B)→(a,W)→(b,R)→(c,B)→(d,W)。

## 六、Practice 46：Shortest Cycle（最短环）

### 问题描述

分别为有向图和无向图，找到最短环的长度。

### 详细答案

#### （1）无向图最短环

##### 核心思路：对每个节点 BFS，记录距离，遇回边计算环长

plaintext

```plaintext
min_cycle ← ∞;
for each s ∈ V do
  distance[v] ← ∞;
  parent[v] ← null;
  queue ← [s];
  distance[s] ← 0;
  while queue非空 do
    u ← Dequeue(queue);
    for each (u, v) ∈ E do
      if v == parent[u] then
        continue;  // 跳过父节点
      if distance[v] == ∞ then
        distance[v] ← distance[u] + 1;
        parent[v] ← u;
        Enqueue(queue, v);
      else
        // 找到环：s→u→v→s的路径
        cycle_len ← distance[u] + distance[v] + 1;
        if cycle_len < min_cycle then
          min_cycle ← cycle_len;

return min_cycle if min_cycle != ∞ else 无环;
```

- 时间复杂度：O(n(n+m))（稠密图最优）；
- 优化：环长超过当前最小环时，提前终止 BFS。

#### （2）有向图最短环

##### 核心思路：对每个节点 BFS，检测 “回到起点” 或 “已访问节点”

plaintext

```plaintext
min_cycle ← ∞;
for each s ∈ V do
  distance[v] ← ∞;
  queue ← [s];
  distance[s] ← 0;
  while queue非空 do
    u ← Dequeue(queue);
    for each (u, v) ∈ E do
      if v == s then
        // 环：s→u→s
        cycle_len ← distance[u] + 1;
        if cycle_len < min_cycle then
          min_cycle ← cycle_len;
      elif distance[v] == ∞ then
        distance[v] ← distance[u] + 1;
        Enqueue(queue, v);
      else
        // 环：s→v→...→u→v
        cycle_len ← distance[u] + 1 + distance'[v];  // distance'[v]为v到s的距离
        if cycle_len < min_cycle then
          min_cycle ← cycle_len;

return min_cycle if min_cycle != ∞ else 无环;
```

- 时间复杂度：O(n(n+m))；
- 优化：预处理每个节点到起点的距离，避免重复计算。

#### （3）示例

- 无向图：1−2−3−1→环长 3；
- 有向图：1→2→3→1→环长 3。

## 七、Practice 47：Counting Shortest Paths（最短路径计数）

### 问题描述

无向连通图G，源点s，f(v)为s→v的最短路径数。设计线性时间算法计算所有f(v)。

### 详细答案

#### （1）核心思路：BFS 分层 + 递推计数

- BFS 保证按距离递增访问节点，最短路径仅来自前一层节点；
- 递推公式：f(v)=∑f(u)（u是v的前一层邻居，即distance[v]=distance[u]+1）。

#### （2）实现步骤

plaintext

```plaintext
// 初始化
distance[v] ← ∞;
f(v) ← 0;
queue ← [s];
distance[s] ← 0;
f(s) ← 1;

while queue非空 do
  u ← Dequeue(queue);
  for each (u, v) ∈ E do
    if distance[v] == ∞ then
      distance[v] ← distance[u] + 1;
      f(v) ← f(u);
      Enqueue(queue, v);
    elif distance[v] == distance[u] + 1 then
      f(v) ← f(v) + f(u);  // 累加前一层邻居的路径数

return f;
```

#### （3）正确性证明

- BFS 分层确保distance[v]是最短距离；
- 最短路径仅能从距离为distance[v]−1的节点到达，故累加这些节点的路径数即为f(v)。

#### （4）时间复杂度

- BFS：O(n+m)；
- 递推计数：O(m)；
- 总复杂度：O(n+m)。

#### （5）示例

- 图：s−1−3,s−2−3；
- BFS 分层：s（distance=0）→1,2（distance=1）→3（distance=2）；
- 计数：f(s)=1,f(1)=1,f(2)=1,f(3)=f(1)+f(2)=2。

## 八、Practice 48：Finding All Edges/Nodes on Shortest s-t Paths（最短 s-t 路径上的边 / 节点）

### 问题描述

有向图G，源点s，汇点t，找到所有位于某条最短s→t路径上的边和节点。

### 详细答案

#### （1）核心思路：双向 BFS + 距离判定

- 正向 BFS：计算s到所有节点的最短距离ds​[v]；
- 反向 BFS：计算t到所有节点的最短距离dt​[v]（即原 graph 中v到t的最短距离）；
- 最短路径长度L=ds​[t]。

#### （2）判定规则

1. **节点判定**：节点v在最短路径上⇔ds​[v]+dt​[v]=L；
2. **边判定**：边(u,v)在最短路径上⇔ds​[u]+ℓ(u,v)+dt​[v]=L（ℓ(u,v)为边权，默认 1）。

#### （3）实现步骤

1. **正向 BFS**：计算ds​[v]；
2. **构造反向图Grev**：将所有边反向；
3. **反向 BFS**：计算dt​[v]；
4. **判定节点和边**：
    
    plaintext
    
    ```plaintext
    L ← d_s[t];
    shortest_nodes ← {v | d_s[v] + d_t[v] == L};
    shortest_edges ← {(u,v) | (u,v) ∈ E and d_s[u] + 1 + d_t[v] == L};
    ```
    

#### （4）时间复杂度

- 双向 BFS：O(n+m)；
- 判定：O(n+m)；
- 总复杂度：O(n+m)。

#### （5）示例

- 图：s→a→t,s→b→a→t，边权 1；
- 正向 BFS：ds​[s]=0,ds​[a]=1,ds​[b]=1,ds​[t]=2；
- 反向 BFS：dt​[t]=0,dt​[a]=1,dt​[b]=2,dt​[s]=∞；
- 最短节点：s,a,t（ds​[v]+dt​[v]=2）；
- 最短边：(s,a),(a,t)（ds​[u]+1+dt​[v]=2）。

## 九、Practice 61：Core Vertices（核心顶点）

### 问题描述

有向图G，核心顶点v定义为 “所有节点均可从v到达”。设计线性时间算法找到所有核心顶点。

### 详细答案

#### （1）核心思路：强连通分量（SCC）+ Condensation 图的汇点

- 核心顶点必属于同一个 SCC（强连通分量），且该 SCC 是 Condensation 图（SCC 缩点后的 DAG）的汇点（出度 0）；
- 汇点 SCC 的节点能到达所有其他节点（因 Condensation 图无环）。

#### （2）实现步骤

1. **求所有 SCC**：用 Kosaraju 算法（O(n+m)）；
    
    plaintext
    
    ```plaintext
    // Kosaraju算法
    1. 对G执行DFS，记录逆后序；
    2. 对反向图G^{rev}按逆后序执行DFS，每个DFS树为一个SCC；
    ```
    
2. **构造 Condensation 图Gcond​**
    
    - 节点：每个 SCC 为一个节点；
    - 边：若 SCCC1和C2存在边(u,v)∈E（u∈C1,v∈C2），则添加边C1→C2。
3. **找到汇点 SCC**：出度为 0 的 SCC；
    
4. **验证与输出**：若汇点 SCC 唯一，则其所有节点为核心顶点；否则无核心顶点。
    

#### （3）正确性证明

- 汇点 SCC 无出边，Condensation 图无环，故汇点 SCC 的节点能到达所有其他 SCC；
- 强连通分量内节点互达，故汇点 SCC 的所有节点能到达所有节点。

#### （4）时间复杂度

- SCC 求解：O(n+m)；
- Condensation 图构造：O(n+m)；
- 汇点查找：O(n)；
- 总复杂度：O(n+m)。

#### （5）示例

- 图：a→b→c,b→a,c→d；
- SCC：{a,b},{c},{d}；
- Condensation 图：{a,b}→{c}→{d}；
- 汇点 SCC：{d}→核心顶点：d（所有节点均可从d到达？不，示例修正：图应为a→b→c,b→a,d→a→SCC{a,b},{c},{d}→Condensation 图{d}→{a,b}→{c}→汇点 SCC{c}→核心顶点：c。

## 十、Practice 62：Maximal Collection of Disjoint Shortest s-t Paths（最大不相交最短 s-t 路径）

### 问题描述

有向图G，源点s，汇点t，找到 “包含关系极大” 的：

1. 边不相交最短 s-t 路径；
2. 内部节点不相交最短 s-t 路径；
    
    要求线性时间。

### 详细答案

#### （1）边不相交最短路径

##### 核心思路：最短路径子图 + DFS/BFS 找路径，标记边

1. **构造最短路径子图Gsp​**：仅保留满足ds​[u]+1+dt​[v]=L的边(u,v)（L=ds​[t]）；
2. **迭代找路径**：
    
    plaintext
    
    ```plaintext
    paths ← 空列表;
    while 存在s→t路径 in G_{sp} do
      path ← DFS/BFS找到的s→t路径;
      paths.append(path);
      删除path上的所有边（标记为已使用）;
    return paths;
    ```
    

#### （2）内部节点不相交最短路径

##### 核心思路：分层图 + DFS/BFS 找路径，标记节点

1. **构造分层图**：按ds​[v]将节点分为Level0={s},Level1,...,LevelL={t}；
2. **保留分层边**：仅保留从Leveli到Leveli+1的边；
3. **迭代找路径**：
    
    plaintext
    
    ```plaintext
    paths ← 空列表;
    while 存在s→t路径 in 分层图 do
      path ← DFS/BFS找到的s→t路径;
      paths.append(path);
      删除path上的内部节点（s和t除外）;
    return paths;
    ```
    

#### （3）“包含关系极大” 说明

- 无需找到最大数量的路径，只需无法添加更多不相交路径即可，迭代至无路径为止。

#### （4）时间复杂度

- 最短路径子图 / 分层图构造：O(n+m)；
- 路径查找：O(n+m)（每次查找线性时间，路径数≤n）；
- 总复杂度：O(n+m)。

#### （5）示例

- 边不相交：s→a→t,s→b→t→删除边后无更多路径，路径集为极大；
- 节点不相交：s→a→t,s→b→c→t→删除内部节点a,b,c后无更多路径，路径集为极大。