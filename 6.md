# 第 6 讲：动态规划（Dynamic Programming）

## 核心知识点

### 1. 定义

将大问题分解为**相互重叠的子问题**，通过逐步构建子问题的解，最终得到大问题的最优解（本质是 “智能递归”）。

### 2. 核心特性

- **重叠子问题**：子问题重复出现，可通过记忆化（MEMO）或自底向上计算避免重复求解。
- **最优子结构**：大问题的最优解包含子问题的最优解，需刻画子问题分辨率并按拓扑序计算。

### 3. 子问题类型及核心算法

#### 3.1 重叠子问题（Overlapping Subproblems）

- 核心示例：一维前缀 / 后缀的**最小 / 最大 / 和**
    - 前缀最小值递推：MinL[1]=A[1]，MinL[i]=min{MinL[i−1],A[i]}
    - 同理可推导前缀最大值（MaxL）、前缀和（SumL）及后缀对应指标（MinR,MaxR,SumR）

#### 3.2 基于前缀的子问题（Subproblems by Prefix）

##### （1）带权区间调度（Weighted Interval Selection）

- 问题：n 个任务（sj​开始时间、fj​结束时间、vj​权重），选无重叠任务使总权重最大。
- 关键步骤：
    1. 按结束时间排序：f1​≤f2​≤⋯≤fn​
    2. 定义p[j]=max{i<j∣fi​≤sj​}（与 j 兼容的最后一个任务）
    3. 递推公式：
        
        opt[j]={0max{opt[j−1],opt[p[j]]+vj​}​j=0j≥1​
    4. 时间复杂度：O(nlogn)（排序 + 计算p[j]）

##### （2）硬币找零（Change-making）

- 问题：n 种面额（d[1]=1），凑目标金额 T，使硬币数量最少。
- 递推公式：
    
    c[t]={01+min{c[t−d[k]]∣1≤k≤n,d[k]≤t}​t=0t≥1​
- 时间复杂度：Θ(nT)（伪多项式时间，决策版为 NP 完全）

#### 3.3 基于前缀对的子问题（Subproblems by Prefix-Pair）

##### （1）矩阵前缀和（Prefix Sums of Matrices）

- 定义：S[i,j]=sum of A[1..i,1..j]（矩阵 A 的左上角 i×j 子矩阵和）
- 递推公式：
    - 第 1 行 / 第 1 列：一维前缀和
    - i>1且j>1：S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+A[i,j]
- 时间 / 空间复杂度：O(mn)（可优化至O(min(m,n))，仅求最大前缀和时）

##### （2）最长公共子序列（LCS）

- 问题：求两个字符串x[1..m]和y[1..n]的最长公共子序列（不要求连续）。
- 子问题定义：C[i,j] = x[1..i]与y[1..j]的 LCS 长度
- 递推公式：
    
    C[i,j]=⎩⎨⎧​01+C[i−1,j−1]max{C[i−1,j],C[i,j−1]}​i=0或j=0xi​=yj​xi​=yj​​
- 还原 LCS：从C[m,n]回溯，匹配则记录字符并同时左移，否则向值相等的方向移动（时间O(m+n)）
- 时间 / 空间复杂度：Θ(mn)

##### （3）背包问题（Knapsack Problem）

- 问题：n 个物品（wi​重量、vi​价值），背包容量W，选物品使总价值最大（0-1 背包）。
- 子问题定义：M[i,w] = 前 i 个物品在重量限制 w 下的最大价值
- 递推公式：
    
    M[i,w]=⎩⎨⎧​0M[i−1,w]max{M[i−1,w],M[i−1,w−wi​]+vi​}​i=0或w=0wi​>wwi​≤w​
- 时间复杂度：Θ(nW)（伪多项式时间，决策版为 NP 完全）

#### 3.4 基于区间的子问题（Subproblems by Intervals）

##### 最优二叉搜索树（Optimal BST）

- 问题：给定节点搜索频率f[1..n]，构建 BST 使总代价∑i=1n​[depthT​(i)+1]f[i]最小。
- 子问题定义：c[i,j] = 区间[i+1..j]上最优 BST 的代价
- 递推公式：
    
    c[i,j]={0∑k=i+1j​f[k]+minr=i+1j​{c[i,r−1]+c[r,j]}​i=ji<j​
- 时间复杂度：O(n3)（通过 Knuth 优化可降至O(n2)，利用行 / 列单调性）

### 4. 实现要点

- 计算顺序：优先初始化边界（第 1 行 / 列），再按**行优先 / 列优先**或**区间长度递增**顺序计算。
- 空间优化：可通过滚动数组将二维空间（如 LCS、背包）优化为一维。
- 解的还原：需记录子问题最优解的决策路径（如 LCS 的回溯、最优 BST 的根节点r[i,j]）。

## 练习题及答案

### 1. 基于前缀的子问题练习

#### 练习 1：钢条切割（Unbounded Knapsack，CLRS 14.1）

- 问题：钢条长度为 n，各长度段价格p[1..n]，切割钢条使总价值最大（可重复切割）。
- 答案：
1. 初始化`dp[0...n]`数组，`dp[0]=0`，其余为`-∞`；
2. 按长度递增计算`dp[i]`（`i从1到n`）：
    
    plaintext
    
    ```plaintext
    for i from 1 to n:
        for j from 1 to i:
            if dp[i-j] + p[j] > dp[i]:
                dp[i] = dp[i-j] + p[j]
    return dp[n]
    ```
    
3. 优化（无界背包特性）：可将内循环改为`j从1到n`，但`i-j≥0`时才更新，逻辑一致
#### 练习 2：分段最小二乘法（KT 6.3）

- 问题：给定平面点`(x₁,y₁),(x₂,y₂),…,(xₙ,yₙ)`（`x`递增），将点分段拟合为直线，每个线段的误差为 “点到直线的平方和”，总代价 =“各线段误差之和 + 分段数 × 惩罚系数 C”，求最小总代价。
- 答案：
##### 预处理：计算线段误差

对任意区间`[j..i]`（`1≤j≤i≤n`），预处理`err[j][i]`表示 “拟合点`j`到`i`的直线的误差平方和”：

- 直线方程：设直线为`y = ax + b`，通过最小二乘法计算`a`和`b`：
    - `sum_x = ∑x_k (j≤k≤i)`，`sum_y = ∑y_k`，`sum_xy = ∑x_k y_k`，`sum_x² = ∑x_k²`，`m = i-j+1`；
    - `a = (m·sum_xy - sum_x·sum_y) / (m·sum_x² - sum_x²)`（分母非零时）；
    - `b = (sum_y - a·sum_x)/m`；
    - `err[j][i] = ∑(y_k - (a x_k + b))²`（`j≤k≤i`）。

##### （2）子问题定义

设`dp[i]`表示 “前`i`个点的最小总代价”，目标是`dp[n]`。

##### （3）递推公式

- 边界：`dp[0] = 0`（0 个点，代价为 0）；
- 递推：`dp[i] = min{ dp[j-1] + err[j][i] + C | 1≤j≤i }`（前`j-1`个点的最小代价 + 第`j`到`i`个点的误差 + 1 次分段的惩罚`C`）。

##### （4）时间复杂度

- 预处理误差：`O(n³)`（枚举所有`j≤i`，计算误差需`O(i-j+1)`）；
- 动态规划：`O(n²)`（枚举`i`和`j`）；
- 总复杂度：`O(n³)`（可通过数学优化将误差计算降至`O(1)`，总复杂度`O(n²)`）。
#### 练习 3：最长递增子序列（LIS，Ex 14.4-6）
给定数组`[8,3,6,5,2,9]`，求最长严格递增子序列（可不连续）

##### （1）方法 1：动态规划（O (n²)）

###### 子问题定义

`dp[i]`表示 “以第`i`个元素结尾的 LIS 长度”，目标是`max(dp[1..n])`。

###### 递推公式

- 边界：`dp[i] = 1`（每个元素自身为长度 1 的 LIS）；
- 递推：对`j < i`，若`A[j] < A[i]`，则`dp[i] = max(dp[i], dp[j]+1)`。

###### 示例计算（数组`[8,3,6,5,2,9]`）

- `dp[1] = 1`（8）；
- `dp[2] = 1`（3，无`j<2`满足`A[j]<3`）；
- `dp[3] = max(dp[3], dp[2]+1)=2`（6>3）；
- `dp[4] = max(dp[4], dp[2]+1)=2`（5>3）；
- `dp[5] = 1`（2，无`j<5`满足`A[j]<2`）；
- `dp[6] = max(dp[6], dp[2]+1, dp[3]+1, dp[4]+1, dp[5]+1)=4`（9>3,6,5,2）；
- 结果：LIS 长度为 3（如`[3,6,9]`或`[3,5,9]`）。

##### （2）方法 2：贪心 + 二分查找（O (nlogn)，文档隐含思路）

###### 核心逻辑

维护数组`tails`，`tails[k]`表示 “长度为`k+1`的 LIS 的最小末尾元素”，遍历数组时：

- 若`A[i] > tails[-1]`：追加到`tails`（LIS 长度 + 1）；
- 否则：二分查找`tails`中第一个≥`A[i]`的位置，替换为`A[i]`（优化末尾元素，为后续元素留空间）。

###### 示例计算（数组`[8,3,6,5,2,9]`）

- 8 → `tails=[8]`；
- 3 < 8 → 替换 8 为 3 → `tails=[3]`；
- 6 > 3 → 追加 → `tails=[3,6]`；
- 5 < 6 → 替换 6 为 5 → `tails=[3,5]`；
- 2 < 3 → 替换 3 为 2 → `tails=[2,5]`；
- 9 > 5 → 追加 → `tails=[2,5,9]`

#### 练习 4：行分割（Problem 14-4）

- 问题：将文本分行，使总惩罚最小（惩罚为行剩余空间的平方和）。
- 答案：
##### （1）预处理：计算行剩余空间惩罚

对任意`1≤i≤j≤n`，计算`cost[i][j]`：

- 若`sum(l[i..j]) + (j-i) > L`：`cost[i][j] = ∞`（无法放入一行）；
- 否则：`cost[i][j] = (L - (sum(l[i..j]) + (j-i)))²`（剩余空间平方）。

##### （2）子问题定义

设`dp[j]`表示 “前`j`个单词的最小总惩罚”，目标是`dp[n]`。

##### （3）递推公式

- 边界：`dp[0] = 0`（0 个单词，惩罚 0）；
- 递推：`dp[j] = min{ dp[i-1] + cost[i][j] | 1≤i≤j }`（前`i-1`个单词的惩罚 + 第`i`到`j`个单词的惩罚）。

##### （4）实现优化

- 前缀和优化：预计算`sum_l[i] = ∑l[1..i]`，则`sum(l[i..j]) = sum_l[j] - sum_l[i-1]`，快速判断`cost[i][j]`是否为`∞`；
- 时间复杂度：`O(n²)`（枚举`j`和`i`）。

#### 练习 5：DAG 中的最短 / 最长路径

- 问题：给定带权 DAG，求源点到所有节点的最短 / 最长路径。
- 答案：
    ##### （1）核心思路

利用 DAG 的拓扑序：按拓扑序遍历节点，确保处理节点`u`时，所有能到达`u`的节点已处理，可安全 “松弛” 边。

##### （2）最短路径（边权可负）

###### 子问题定义

`d[v]`表示 “`s`到`v`的最短路径长度”，目标是`d[所有v]`。

###### 实现步骤

1. 对 DAG 进行拓扑排序，得到节点顺序`v₁, v₂, ..., vₙ`（`v₁=s`）；
2. 初始化`d[s] = 0`，其余`d[v] = ∞`；
3. 按拓扑序遍历节点`u`：
    
    plaintext
    
    ```plaintext
    for u in 拓扑序:
        for each (u, v) ∈ E:
            if d[v] > d[u] + ℓ(u,v):
                d[v] = d[u] + ℓ(u,v)
                parent[v] = u  # 记录路径
    ```
    

##### （3）最长路径（边权可正可负）

###### 子问题定义

`d[v]`表示 “`s`到`v`的最长路径长度”，目标是`d[所有v]`。

###### 实现步骤

1. 对 DAG 进行拓扑排序；
2. 初始化`d[s] = 0`，其余`d[v] = -∞`；
3. 按拓扑序遍历节点`u`，松弛时取`max`：
    
    plaintext
    
    ```plaintext
    for u in 拓扑序:
        for each (u, v) ∈ E:
            if d[v] < d[u] + ℓ(u,v):
                d[v] = d[u] + ℓ(u,v)
                parent[v] = u
    ```
    

##### （4）时间复杂度

- 拓扑排序：`O(n+m)`；
- 松弛操作：`O(m)`；
- 总复杂度：`O(n+m)`（线性时间）。

### 2. 基于前缀对的子问题练习

#### 练习 1：最大全 1 子方阵（Maximum size all-1 square sub-matrix）

- 问题：给定 0-1 矩阵，求最大的全 1 子方阵边长。
- 答案：
    ##### （1）子问题定义

设`dp[i][j]`表示 “以`(i,j)`为右下角的全 1 子方阵的最大边长”，目标是`max(dp[i][j])`。

##### （2）递推公式

- 边界：若`A[i][j] = 1`，则`dp[i][1] = 1`（第 1 列）、`dp[1][j] = 1`（第 1 行）；若`A[i][j] = 0`，则`dp[i][j] = 0`；
- 递推（`i>1`且`j>1`且`A[i][j] = 1`）：`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`（依赖左上、上、左三个方向的最小边长，确保形成方阵）。

##### （3）示例（文档矩阵片段）

对矩阵：

plaintext

```plaintext
1 1 1 1
1 1 1 0
1 1 1 0
```

- `dp[1][1..4] = [1,1,1,1]`；
- `dp[2][1] = 1`，`dp[2][2] = min(1,1,1)+1=2`，`dp[2][3] = min(1,2,2)+1=2`，`dp[2][4] = 0`；
- `dp[3][1] = 1`，`dp[3][2] = min(2,1,1)+1=2`，`dp[3][3] = min(2,2,2)+1=3`，`dp[3][4] = 0`；
- 结果：最大边长为 3。

##### （4）时间 / 空间复杂度

- 时间：`O(mn)`（遍历矩阵一次）；
- 空间：`O(mn)`（可优化为`O(n)`，用一维数组滚动更新）。

#### 练习 2：编辑距离（Problem 14-5）

- 问题：求两个字符串的最小编辑次数（插入、删除、替换）。
- 答案：
##### 1）子问题定义

设`dp[i][j]`表示 “将`x[1..i]`转换为`y[1..j]`的最小编辑次数”，目标是`dp[m][n]`。

##### （2）递推公式

- 边界：
    - `dp[i][0] = i`（`x`到空串，需`i`次删除）；
    - `dp[0][j] = j`（空串到`y`，需`j`次插入）；
- 递推（`i>0`且`j>0`）：
    - 若`x[i] == y[j]`：`dp[i][j] = dp[i-1][j-1]`（无需操作）；
    - 否则：`dp[i][j] = min( dp[i-1][j] + 1, # 删除x[i] dp[i][j-1] + 1, # 插入y[j] dp[i-1][j-1] + 1 # 替换x[i]为y[j] )`。

##### （3）示例（`x="kitten"`，`y="sitting"`）

- `dp[0][*] = 0,1,2,3,4,5,6`；
- `dp[*][0] = 0,1,2,3,4,5,6`；
- `dp[1][1]`（k→s）：`min(1+1,1+1,0+1)=1`；
- ... 最终`dp[6][7] = 3`（k→s、e→i、插入 g）。

##### （4）时间 / 空间复杂度

- 时间：`O(mn)`（遍历所有`i,j`）；
- 空间：`O(mn)`（可优化为`O(min(m,n))`，用一维数组）。

#### 练习 3：最长公共子串（Longest common substring）

- 问题：求两个字符串的最长连续公共子串。
- 答案：
    - 子问题：dp[i][j] = 以x[i]和y[j]结尾的最长公共子串长度
    - 递推：dp[i][j]=dp[i−1][j−1]+1（若x[i]=y[j]），否则dp[i][j]=0
    - 结果：遍历dp数组取最大值

#### 练习 4：最长公共递增子序列（LCIS）

- 问题：求数组[3,4,9,1]和[5,3,8,9,10,2,1]的 LCIS。
- 答案：
#####   1）子问题定义

设`dp[j]`表示 “以`y[j]`结尾的 LCIS 长度”，`prev[j]`记录 “LCIS 的前一个元素在`y`中的索引”（用于还原路径）。

##### （2）实现思路

1. 遍历`x`的每个元素`x[i]`；
2. 维护辅助变量`max_len`（当前遍历中，`y[j] < x[i]`的最大`dp[j]`）；
3. 遍历`y`的每个元素`y[j]`：
    - 若`x[i] == y[j]`：`dp[j] = max_len + 1`，`prev[j] = 对应max_len的索引`；
    - 若`y[j] < x[i]`且`dp[j] > max_len`：更新`max_len = dp[j]`。

##### （3）示例（`x=[3,4,9,1,5,3,8,9,10,2,1]`，`y=[1,3,4,5,8,9,10,2]`）

- 遍历`x[1]=3`：`y[j]=3`时，`max_len=0`（`y[1]=1<3`，`dp[1]=0`），`dp[2]=1`；
- 遍历`x[2]=4`：`y[j]=4`时，`max_len=1`（`y[2]=3<4`，`dp[2]=1`），`dp[3]=2`；
- 遍历`x[3]=9`：`y[j]=9`时，`max_len=2`（`y[3]=4<9`，`dp[3]=2`），`dp[6]=3`；
- 遍历`x[5]=5`：`y[j]=5`时，`max_len=2`（`y[3]=4<5`，`dp[3]=2`），`dp[4]=3`；
- ... 最终`max(dp)=4`（如`[3,4,5,8,9,10]`修正：实际 LCIS 长度为 5，需完整遍历）。

##### （4）时间复杂度

- `O(mn)`（`m`为`x`长度，`n`为`y`长度）。

#### 练习 5：最长凸子序列（Longest convex subsequence）

- 问题：求数组[3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,7]的最长凸子序列。
##### （1）子问题定义

设`dp[i][j]`表示 “以`A[i], A[j]`（`i<j`）结尾的最长凸子序列长度”，初始`dp[i][j] = 2`（仅两个元素，凸性无意义，长度为 2）。

##### （2）递推公式

对`k > j`，若`2A[j] < A[i] + A[k]`（满足凸性），则`dp[j][k] = max(dp[j][k], dp[i][j] + 1)`。

##### （3）实现步骤

1. 初始化`dp[i][j] = 2`（所有`i<j`）；
2. 按`k`递增遍历（`k从3到n`）：
    - 按`j`递减遍历（`j从k-1到2`）：
        - 遍历`i`（`i从j-1到1`）：
            - 若`2*A[j] < A[i] + A[k]`，则`dp[j][k] = max(dp[j][k], dp[i][j]+1)`；
3. 结果：`max(dp[i][j])`（若`max<3`，则最长凸子序列长度为 2）。

##### （4）示例（数组片段`[3,1,4,1,5,9]`）

- `dp[1][2] = 2`（3,1），`dp[1][3] = 2`（3,4），`dp[2][3] = 2`（1,4）；
- `k=4`（A[4]=1）：`j=3`（4），`i=1`（3）：`2*4=8 > 3+1=4`，不满足；`j=2`（1），`i=1`（3）：`2*1=2 < 3+1=4`，`dp[2][4] = 3`；
- 最终最长凸子序列长度为 3（如`[3,1,4]`）。

##### （5）时间复杂度

- `O(n³)`（枚举`k,j,i`），可优化至`O(n²)`（利用凸性的单调性）。
#### 练习 6：背包变体（Knapsack variants）

- 问题：包括有界背包、多重背包、二维背包等。
##### （1）0-1 背包（基础，文档 33-36 页）

- 子问题：`M[i][w]`= 前`i`个物品在重量`w`下的最大价值；
- 递推：`M[i][w] = max(M[i-1][w], M[i-1][w-w[i]]+v[i])`（选或不选第`i`个物品）；
- 时间：`O(nW)`（`W`为背包容量）。

##### （2）有界背包（物品`i`最多选`c[i]`次）

- 转化为 0-1 背包：将物品`i`拆分为`log c[i]`个 “二进制物品”（如`c[i]=5`拆为 1+2+2），总物品数`O(n log c[i])`；
- 递推：同 0-1 背包，时间`O(nW log c[i])`。

##### （3）多重背包（物品可选无限次）

- 子问题：`dp[w]`= 重量`w`下的最大价值；
- 递推：`dp[w] = max(dp[w], dp[w-w[i]]+v[i])`（`w从w[i]到W`）；
- 时间：`O(nW)`。

##### （4）二维背包（重量`w`+ 体积`v`）

- 子问题：`dp[w][v]`= 重量`w`、体积`v`下的最大价值；
- 递推：`dp[w][v] = max(dp[w][v], dp[w-w[i]][v-v[i]]+v[i])`；
- 时间：`O(nWV)`（`V`为体积上限）。

### 3. 基于区间的子问题练习

#### 练习 1：矩阵链乘法（Matrix-chain multiplication，CLRS 14.2）

- 问题：给定矩阵链A1​A2​...An​，求最优括号化方案使乘法次数最少。
##### （1）子问题定义

设`m[i][j]`表示 “矩阵链`AᵢAᵢ₊₁…Aⱼ`的最小乘法次数”，目标是`m[1][n]`；`s[i][j]`记录 “最优分割点`k`”（`i≤k<j`）。

##### （2）递推公式

- 边界：`m[i][i] = 0`（单个矩阵，无乘法）；
- 递推（`j > i`）：`m[i][j] = min{ m[i][k] + m[k+1][j] + p[i-1]p[k]p[j] | i≤k<j }`（分割为`Aᵢ…Aₖ`和`Aₖ₊₁…Aⱼ`，乘法次数为两部分之和 + 合并次数）。

##### （3）示例（矩阵链`A₁(10×100), A₂(100×5), A₃(5×50)`）

- `m[1][2] = 10×100×5 = 5000`；
- `m[2][3] = 100×5×50 = 25000`；
- `m[1][3] = min(m[1][1]+m[2][3]+10×10×50, m[1][2]+m[3][3]+10×100×50) = min(0+25000+5000, 5000+0+50000) = 30000`；
- 结果：最小乘法次数 30000，分割点`k=1`（`(A₁(A₂A₃)`）。

##### （4）时间复杂度

- 时间：`O(n³)`（枚举`长度l`、`i`、`k`）；
- 空间：`O(n²)`（存储`m`和`s`）。

#### 练习 2：凸多边形最短三角剖分（Shortest triangulation of a convex polygon）

- 问题：将凸多边形用对角线分割为三角形，使对角线总长度最短。
##### （1）子问题定义

设`dp[i][j]`表示 “凸多边形`vᵢvᵢ₊₁…vⱼ`的最短剖分长度”，目标是`dp[1][n]`。

##### （2）递推公式

- 边界：`dp[i][i+1] = 0`（两个顶点，无对角线）；
- 递推（`j > i+1`）：`dp[i][j] = min{ dp[i][k] + dp[k][j] + |vᵢvₖ| + |vₖvⱼ| | i<k<j }`（选择对角线`vᵢvₖ`和`vₖvⱼ`，剖分为`vᵢ…vₖ`、`vₖ…vⱼ`和三角形`vᵢvₖvⱼ`）。

##### （3）实现步骤

1. 按区间长度`l = j-i`递增计算（`l从2到n-1`）；
2. 枚举`i`（`i从1到n-l`），`j = i+l`；
3. 枚举`k`（`i<k<j`），计算`dp[i][j]`；
4. 结果：`dp[1][n]`。

##### （4）时间复杂度

- `O(n³)`（枚举`l,i,k`）。

#### 练习 3：RNA 二级结构（RNA Secondary Structure，KT6.5）

- 问题：给定 RNA 序列，预测无交叉的碱基配对结构（最大化配对数）。
##### （1）子问题定义

设`dp[i][j]`表示 “RNA 序列`i`到`j`的最大配对数”，目标是`dp[1][n]`。

##### （2）递推公式

- 边界：`dp[i][j] = 0`（`i≥j`）；
- 递推（`j > i`）：
    - 情况 1：`j`不与任何碱基配对 → `dp[i][j] = dp[i][j-1]`；
    - 情况 2：`j`与`k`（`i≤k<j`）配对（若`A[k]`与`A[j]`互补） → `dp[i][j] = max(dp[i][j], dp[i][k-1] + dp[k+1][j-1] + 1)`；
- 合并：`dp[i][j] = max(情况1, 情况2)`。

##### （3）实现步骤

1. 按区间长度`l = j-i`递增计算（`l从1到n-1`）；
2. 枚举`i`（`i从1到n-l`），`j = i+l`；
3. 初始化`dp[i][j] = dp[i][j-1]`；
4. 枚举`k`（`i≤k<j`），若`A[k]`与`A[j]`互补，更新`dp[i][j]`；
5. 结果：`dp[1][n]`。

##### （4）时间复杂度

- `O(n³)`（枚举`l,i,k`）。

#### 练习 4：最长平衡子序列（Longest balanced subsequence）

- 问题：求字符串[()][]())[()()]()的最长平衡括号子序列。
##### 1）子问题定义

设`dp[i][j]`表示 “区间`i`到`j`的最长平衡子序列长度”，目标是`dp[1][n]`。

##### （2）递推公式

- 边界：`dp[i][j] = 0`（`i≥j`）；
- 递推（`j > i`）：
    - 若`s[i]`与`s[j]`匹配（`s[i]='('`且`s[j]=')'`）：`dp[i][j] = dp[i+1][j-1] + 2`；
    - 否则：`dp[i][j] = max(dp[i][k], dp[k+1][j] | i≤k<j)`（分割为两个区间）；
- 合并：`dp[i][j] = max(匹配情况, 分割情况)`。

##### （3）示例（`[()][]())[()()]()`）

- 区间`1-2`（`()`）：`dp[1][2] = 2`；
- 区间`3-4`（`[]`，视为`()`）：`dp[3][4] = 2`；
- 区间`1-4`：`dp[1][4] = dp[1][2] + dp[3][4] = 4`；
- 最终`dp[1][14] = 12`（完整平衡子序列如`()[]()()()()`）。

##### （4）时间复杂度

- `O(n²)`（枚举`i,j`，分割情况可优化为`O(1)`）。
#### 练习 5：最长回文子序列（Longest palindromic subsequence，Problem 14-2）

- 问题：求数组[3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,7]的最长回文子序列。
##### （1）子问题定义

设`dp[i][j]`表示 “区间`i`到`j`的最长回文子序列长度”，目标是`dp[1][n]`。

##### （2）递推公式

- 边界：`dp[i][i] = 1`（单个元素，回文长度 1）；`dp[i][j] = 0`（`i>j`）；
- 递推（`j > i`）：
    - 若`A[i] == A[j]`：`dp[i][j] = dp[i+1][j-1] + 2`（两端元素加入回文）；
    - 否则：`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`（取左或右区间的最大值）。

##### （3）示例（数组片段`[3,1,4,1,5]`）

- `dp[1][5]`：`A[1]=3 != A[5]=5` → `max(dp[2][5], dp[1][4])`；
- `dp[2][5]`：`A[2]=1 != A[5]=5` → `max(dp[3][5], dp[2][4])`；
- `dp[2][4]`：`A[2]=1 == A[4]=1` → `dp[3][3] + 2 = 1+2=3`；
- 结果：`dp[1][5] = 3`（如`[1,4,1]`）。

##### （4）时间复杂度

- 时间：`O(n²)`；
- 空间：`O(n²)`（可优化为`O(n)`）。
#### 练习 6：上下文无关文法的 CKY 解析算法（CKY parsing algorithm）

- 问题：给定上下文无关文法和字符串，判断是否可解析（CYK 算法）。
##### （1）乔姆斯基范式（CNF）准备

将文法转换为 CNF：

- 消除 ε 产生式（如`A→ε`）；
- 消除单元产生式（如`A→B`）；
- 所有产生式变为`A→BC`（两个非终结符）或`A→a`（单个终结符）。

##### （2）子问题定义

设`dp[i][j][A]`表示 “字符串`x[i..j]`可由非终结符`A`推导”（布尔值），目标是`dp[1][n][S]`（`S`为文法开始符号）。

##### （3）实现步骤

1. 初始化（长度为 1 的子串）：
    - 对`i从1到n`，若存在产生式`A→x[i]`，则`dp[i][i][A] = true`；
2. 按子串长度`l从2到n`递增计算：
    - 枚举`i从1到n-l+1`，`j = i+l-1`；
    - 枚举分割点`k从i到j-1`；
    - 对所有产生式`A→BC`，若`dp[i][k][B] && dp[k+1][j][C]`，则`dp[i][j][A] = true`；
3. 结果：若`dp[1][n][S] = true`，则字符串可推导；否则不可。

##### （4）时间复杂度

- 时间：`O(n³·|G|)`（`|G|`为文法中非终结符数量）；
- 空间：`O(n²·|G|)`。

### 4. 具体应用问题练习

#### 练习 1：带权区间调度（Ex 15.1-5）

- 问题：任务$a(、b(、c(、d(、e(、f(、g(、h(，时间轴[0,2,4,5,6,7,8,9,10,11,14]$，求最大权重子集。
- 答案：
    - 排序后任务：$b(0-2,、a(2-4,、c(4-6,、d(5-7,、e(6-9,、f(7-11,、g(9-14,、h(10-11,$7)
    - 计算p[j]：p[1]=0,p[2]=0,p[3]=1,p[4]=1,p[5]=3,p[6]=4,p[7]=5,p[8]=6
    - 最优解：opt[8]=19（任务b+c+e+g或b+c+f+g）

#### 练习 2：硬币找零（Problem 15-1）

- 问题：美国邮政面额[1,10,21,34,70,100,350,1225,1500]，凑T=140美分。
- 答案：最优解为70+70（2 枚硬币），递推计算c[140]=2。

#### 练习 3：最长公共子序列（LCS，Section 14.4）

- 问题：字符串x="ocurrance"、y="Occurrence"，求 LCS 和 SCS。
- 答案：
    - LCS："ocurrnce"（长度 7）
    - SCS："occurreance"（长度 10）
    - 关系：∣LCS∣+∣SCS∣=m+n（7+10=8+9）

#### 练习 4：最优二叉搜索树（Section 14.5）

- 问题：搜索频率f=[3,2,8,1,5,4]（节点 1-6），求最优 BST。
- 答案：
    - 最小代价c[0,6]=47
    - 最优根节点：r[0,6]=5，左子树[1−4]（根 3），右子树[6]（根 6）

### 5. 课前练习（Next time 预习：贪心算法）

#### 练习：赛马问题（Horse racing）

- 问题：给定两个排序数组a[1..n]≤a[2..n]≤⋯≤a[n]和b[1..n]≤b[2..n]≤⋯≤b[n]，找排列σ使得分∑i=1n​sign(b[σ(i)]−a[i])最大。
- 答案（贪心策略）：
    1. 若a[1]>b[1]：σ(1)=1（a[1]配对b[1]）
    2. 若a[n]>b[n]：σ(n)=n（a[n]配对b[n]）
    3. 若a[1]≤b[1]且a[n]≤b[n]：σ(1)=n（a[1]配对b[n]）
    4. 递归处理剩余子数组，时间复杂度O(n)