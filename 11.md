# 第 11 讲：最小生成树（Minimum Spanning Tree, MST）

## 核心知识点

### 1. MST 的定义与基本性质

- **定义**：给定连通图\(G=(V, E; \ell)\)（\(\ell\)为边权重函数），生成树\(T \subseteq E\)满足：① 包含所有节点（\(|T|=n-1\)，\(n=|V|\)）；② 连通无环；③ 总边权\(\sum_{e \in T} \ell(e)\)最小。
- **核心特性**：MST 的最优性由 “贪心选择 + 安全添加 / 删除” 保证，无负权边时贪心策略必最优。

### 2. 三种贪心算法（核心重点）

#### 2.1 算法对比表

|算法|核心逻辑|安全依据|时间复杂度|适用场景|
|---|---|---|---|---|
|Prim 算法（树扩展法）|从单节点树T开始，每次选 “离开T的权重最小边”，将节点加入T|安全添加|数组：\(O(n^2)\)；二叉堆：\(O(m\log n)\)；斐波那契堆：\(O(m + n\log n)\)|稠密图（\(m \approx n^2\)）|
|Kruskal 算法（森林合并法）|按边权递增排序，依次添加边，仅当边连接两个不同树分量时保留（避免环）|安全添加|排序\(O(m\log m)\) + 并查集\(O(m\alpha(n))\)（\(\alpha\)为阿克曼函数逆）|稀疏图（\(m \approx n\)）|
|反向删除法（Reverse-delete）|按边权递减排序，依次删除边，仅当删除后图仍连通时保留（删除环中最大边）|安全删除|\(O((m\log n)(\log\log n)^3)\)|理论研究，实际少用|

#### 2.2 关键概念（正确性证明基础）

- **安全添加（Safe Accept）**：若森林F含于某 MST，e是 “离开F某分量的最小边”，则\(F \cup \{e\}\)仍含于某 MST。
    
    证明：设 MSTT含F但不含e，T中e端点的路径必含 “离开该分量的边f”，\(\ell(e) \leq \ell(f)\)，则\(T - f + e\)是含\(F \cup \{e\}\)的 MST。
- **安全删除（Safe Reject）**：若f是环C中权重最大的边，则存在 MST 不含f。
    
    证明：设 MSTT含f，删除f后T分为两分量，\(C - f\)中必含跨分量边e，\(\ell(e) \leq \ell(f)\)，则\(T - f + e\)是不含f的 MST。

#### 2.3 实现细节

##### （1）Prim 算法（优先队列版）

plaintext

```plaintext
// 初始化
for all v ∈ V do; c(v) = ∞; in_T(v) = false;
r = 任意根节点; c(r) = 0;
priority_queue Q ← V;  // 按c(v)（节点到T的最小边权）排序
T = ∅;

while Q非空 do
  u ← ExtractMin(Q);  // 选离T最近的节点
  in_T(u) = true;
  if u ≠ r then T = T ∪ {e(u)};  // e(u)是u到T的最小边
  for each (u, v) ∈ E do
    if not in_T(v) and ℓ(u,v) < c(v) then
      c(v) = ℓ(u,v);
      e(v) = (u,v);
      DecreaseKey(Q, v);  // 更新优先级
return T;
```

##### （2）Kruskal 算法（并查集优化）

plaintext

```plaintext
// 初始化
sort E in ascending order of ℓ(e);  // 边权递增排序
DSU dsu(V);  // 并查集（维护树分量）
T = ∅;

for each e = (u, v) ∈ E in sorted order do
  if dsu.find(u) ≠ dsu.find(v) then  // 连接不同分量
    T = T ∪ {e};
    dsu.union(u, v);  // 合并分量
    if |T| == n-1 then break;  // MST已生成
return T;
```

- 并查集优化：按 “分量大小” 合并（大分量吞小分量），每个节点根更新次数≤\(\log n\)，总时间近线性。

### 3. MST 的关键衍生概念

#### 3.1 边的分类（基于 Kruskal 批量处理）

|边类型|定义|判定方法|
|---|---|---|
|关键边（Critical）|所有 MST 必含的边|边是某 “基本割” 中唯一最小边（删除后 MST 总权增加）|
|伪关键边（Pseudo-critical）|部分 MST 含、部分不含的边|边是某环中最小边，但存在其他环中最小边可替代|
|无用边（Useless）|所有 MST 都不含的边|边是某环中权重严格大于其他边，或不连接任何两个分量（排序后从未被选中）|

#### 3.2 基本割与基本回路

- **基本割（Fundamental Cut）**：对 MSTT的边e，删除e后T分为两分量，跨两分量的边集为基本割，e是该割中最小边。
- **基本回路（Fundamental Circuit）**：对非树边f，\(T \cup \{f\}\)形成唯一环，f是该环中最大边。

#### 3.3 MST 验证（TFAE）

对任意生成树T，以下命题等价：

1. T是 MST；
2. 每条树边\(e \in T\)是其基本割中的最小边；
3. 每条非树边\(f \notin T\)是其基本回路中的最大边。

### 4. MST 的核心应用

1. **全对最小最大路径**：MST 中任意\(u-v\)路径，是所有\(u-v\)路径中 “最大边权重最小” 的路径（最小最大路径）；最大生成树对应 “最小边权重最大”（最宽路径）。
2. **最大间隔 k 聚类**：删除 MST 中权重最大的\(k-1\)条边，得到k个分量，该聚类的 “间隔”（不同组节点最小距离）最大，间隔 = 第\(k-1\)条被删边的权重。
3. **无环化（反馈边集）**：MST 的补集\(E - T\)是 “最小权重反馈边集”（删除后图无环，总权最小）。

## 练习题及答案

### 1. 近树的线性时间 MST（Practice 13）

#### 问题描述

给定连通图\(G=(V, E; \ell)\)，满足\(|E|=|V|+6\)（近树，边数仅比树多 6），设计线性时间（\(O(m)\)）的 MST 算法。

#### 答案

- 核心思路：利用 Kruskal 算法，结合近树的稀疏特性，简化排序和并查集操作：
    1. 用 “桶排序” 替代快排：因边数仅比树多 6，边权重复率高，桶排序可线性时间完成；
    2. 并查集优化：近树中分量合并次数少，路径压缩 + 按大小合并的并查集操作近似线性；
    3. 终止条件：当收集到\(n-1\)条边时立即终止，无需遍历所有边。
- 时间复杂度：\(O(m)\)（桶排序\(O(m)\) + 并查集\(O(m\alpha(n)) \approx O(m)\)）。

### 2. 单对最小最大路径（Practice 33）

#### 问题描述

给定连通图G和节点对\((s,t)\)，设计\(O(m)\)时间算法，找到\(s-t\)的 “最小最大路径”（路径中最大边权重最小）。

#### 答案

- 核心依据：MST 中\(s-t\)路径即为最小最大路径；
- 算法步骤：
    1. 构建 G 的 MST（用 Kruskal 或 Prim 算法，近线性时间）；
    2. 在 MST 中找\(s-t\)的唯一路径（BFS 或 DFS，\(O(n)\)时间）；
- 时间复杂度：\(O(m)\)（MST 构建近线性 + 路径查找线性）；
- 证明：设 MST 中\(s-t\)路径的最大边为e，任何其他\(s-t\)路径必含跨e基本割的边f，\(\ell(f) \geq \ell(e)\)，故 MST 路径的最大边最小。

### 3. 动态 MST（Practice 29）

#### 问题描述

给定图G的 MSTT，当某条边e的权重：① 减小；② 增大时，设计算法更新 MST。

#### 答案

##### （1）边权减小（\(\ell(e) \downarrow\)）

- 情况 1：\(e \in T\) → MST 仍为T（边权减小仅使总权更小，不影响树结构）；
- 情况 2：\(e \notin T\) → \(T \cup \{e\}\)形成唯一环，删除环中权重最大的边（原树边），得到新 MST；
- 时间复杂度：\(O(n)\)（找环 + 删最大边）。

##### （2）边权增大（\(\ell(e) \uparrow\)）

- 情况 1：\(e \notin T\) → MST 仍为T（边权增大不影响原 MST 的最优性）；
- 情况 2：\(e \in T\) → 删除e后T分为两分量，在 G 中找跨两分量的权重最小边f，新 MST 为\(T - e + f\)；
- 时间复杂度：\(O(m)\)（找跨分量最小边，可提前预处理基本割）。

### 4. 最小权重反馈边集（Practice 36）

#### 问题描述

反馈边集（Feedback Edge Set）：删除后图无环的边集。给定边加权图，求总权重最小的反馈边集。

#### 答案

- 核心结论：最小权重反馈边集 = \(E - MST\)（MST 的补集）；
- 证明：
    1. 无环性：MST 无环，\(E - T\)包含所有环的边，删除后图为 MST，无环；
    2. 最小权重：MST 是总权最小的生成树，\(E - T\)是总权最大的非树边集？不，反证：设存在更小反馈边集F，则\(E - F\)是生成树且总权\(< T\)，与 MST 的最优性矛盾；
- 算法步骤：
    1. 构建 MSTT；
    2. 输出\(E - T\)；
- 时间复杂度：同 MST 构建（\(O(m\log n)\)）。

### 5. MST 唯一性检验（Practice 21）

#### 问题描述

给定图G，判断其 MST 是否唯一。

#### 答案

- 判定方法：
    1. 若图中存在某环，环中含多条权重相同的最小边 → MST 不唯一（可替换边）；
    2. 若所有边权互不相同 → MST 唯一（贪心选择唯一）；
    3. 用 Kruskal 算法：排序时对权重相同的边按 “是否形成环” 检验，若存在权重相同的边可替换树边 → 不唯一；
- 时间复杂度：\(O(m\log m)\)（排序 + 并查集检验）。

### 6. 最大间隔 k 聚类（Practice 34-35）

#### 问题描述

将节点分为k个非空组，“间隔” 定义为不同组节点对的最小距离，求间隔最大的 k 聚类。

#### 答案

- 算法步骤：
    1. 构建图G的 MST（边权为节点间距离）；
    2. 删除 MST 中权重最大的\(k-1\)条边，得到k个树分量；
- 间隔大小：第\(k-1\)条被删边的权重（\(d^*\)）；
- 证明：设任意其他 k 聚类C，若某两组含 MST 同一分量的节点，其路径必含跨分量边e，\(\ell(e) \leq d^*\)，故C的间隔≤\(d^*\)；
- 应用场景：聚类分析（如用户分群、数据分组），最大化组间距离。

### 7. Kruskal 批量处理的边分类（Practice 22-23）

#### 问题描述

将边按权重分块（同权重为一块），用 Kruskal 批量处理，证明：① 所有 MST 的边权排序相同；② 分类边为关键边、伪关键边、无用边。

#### 答案

##### （1）边权排序相同

- 证明：Kruskal 批量处理时，每块边仅连接前一块形成的分量，MST 的边权由块的顺序决定，与块内边的顺序无关，故所有 MST 的边权排序一致。

##### （2）边分类判定

- 关键边：某块中唯一跨某分量的边，所有 MST 必含；
- 伪关键边：某块中存在多条跨同一分量的边，部分 MST 含、部分不含；
- 无用边：某块中不跨任何分量（已连通），所有 MST 都不含；
- 算法：用 Kruskal 批量处理，记录每块边的连接情况，按跨分量唯一性分类。


## 一、Practice: Linear-time algorithm on near-trees（第 13 页）

### 问题描述

给定连通图G=(V,E;ℓ)，满足∣E∣=∣V∣+6（近树，边数仅比生成树多 6 条），设计线性时间（O(m)，m=∣E∣）的 MST 算法。

### 详细答案

#### （1）核心思路

近树的核心特性是「边数极少（m=n+6，n=∣V∣），冗余边仅 7 条」，常规 Kruskal 的瓶颈是排序（O(mlogm)），通过以下三点优化消除非线性瓶颈，实现线性时间：

1. **桶排序替代快排**：利用近树边权重复率高的特性，非比较类排序实现线性排序；
2. **并查集优化**：路径压缩 + 按大小合并，操作近似线性时间；
3. **提前终止**：收集到n−1条有效边（生成树）即停止，跳过冗余边。

#### （2）实现步骤

1. **桶排序优化边排序（线性时间）**
    
    - 遍历边集 1 次，获取边权最小值minw​和最大值maxw​，桶数量为maxw​−minw​+1；
    - 遍历边集 2 次，将每条边按权值放入对应桶（索引w−minw​）；
    - 按权值递增顺序遍历所有桶，取出边形成有序边集（无需比较，线性时间）。
    - 关键依据：近树边数少（n+6），边权取值范围窄、重复率高，桶数量远小于m，总排序时间O(m)。
2. **并查集优化（近似线性时间）**
    
    - 数据结构：`root[v]`记录节点v所在分量的根，`size[v]`记录分量大小；
    - 操作优化：
        - `find(v)`：路径压缩（查找时直接将节点指向根，扁平化结构）；
        - `union(u, v)`：按大小合并（小分量根指向大分量根，减少后续查找层数）。
    - 关键依据：每个节点的根更新次数≤logn，总并查集操作时间O(mα(n))（α为阿克曼函数逆，近似常数）。
3. **提前终止遍历（减少无效操作）**
    
    - 初始化 MST 边集T=∅；
    - 按桶排序后的顺序遍历边：
        - 若u和v分属不同分量，添加边到T，合并分量；
        - 若∣T∣=n−1，立即终止（已形成生成树，且是 MST）。
    - 关键依据：Kruskal 算法的 “安全添加” 性质，按权值递增选边，前n−1条有效边必为 MST。

#### （3）正确性证明

1. **排序正确性**：桶排序按权值分桶，取出顺序与权值递增一致，等价于快排结果；
2. **MST 正确性**：Kruskal 算法的核心是 “安全添加”—— 每条添加的边是跨分量的最小边，近树场景下优化后仍满足该性质，故T是 MST；
3. **线性时间正确性**：桶排序O(m) + 并查集O(mα(n)) + 提前终止O(m)，总时间O(m)。

#### （4）时间复杂度

- 总复杂度：O(m)（线性时间）；
- 空间复杂度：O(m+n)（桶存储边 + 并查集数组）。

#### （5）示例

- 输入：n=100，m=106（100+6），边权范围[1,20]；
- 桶排序：桶数量 20，遍历边 2 次完成排序；
- 并查集：合并操作约 100 次，路径压缩后每次操作近似常数时间；
- 提前终止：收集 99 条边后停止，跳过剩余 7 条冗余边；
- 输出：MST 边集，时间复杂度O(106)=O(m)。

## 二、Practice: MST 唯一性检验（第 21 页，Only edge ordering matters for Kruskal’s method）

### 问题描述

给定图G=(V,E;ℓ)，判断其 MST 是否唯一。文档核心结论：

1. 若所有边权互不相同，则 MST 唯一；
2. 若存在边权相等的边，且某环中含多条权值最小的边，则 MST 不唯一；
3. Kruskal 算法中，通过 “tie-breaking”（权值相等时的选择顺序），可生成任意 MST。

### 详细答案

#### （1）核心思路

MST 唯一的充要条件：**对任意环C，环中权值最小的边唯一**（无多条等权最小边）。

本质是 Kruskal 算法中，每次 “跨分量选最小边” 时，选择唯一，无替代边，最终 MST 唯一。

#### （2）实现步骤

1. **边排序与预处理**
    
    - 按边权递增排序，权值相等的边按任意顺序排列（记录同权边组）；
    - 初始化并查集，用于跟踪分量连接状态。
2. **遍历边，检验唯一性**
    
    - 按排序顺序遍历边，对每一组同权边（权值w）：
        - 先标记该组边连接的 “分量对”（(root(u),root(v))），不实际合并；
        - 若同一 “分量对” 被该组中多条边覆盖（即多条同权边可连接同一对分量），则存在替代边，MST 不唯一；
        - 否则，合并该组边对应的分量，继续遍历。
    - 若所有同权边组均无重复 “分量对”，且边权全不同时，MST 唯一。
3. **简化判定（工程实现）**
    
    - 若所有边权互不相同 → MST 唯一；
    - 否则，遍历所有环，检查是否存在环中多条最小边 → 存在则不唯一，否则唯一。

#### （3）正确性证明

- 充分性（边权全不同 → 唯一）：Kruskal 每次跨分量的最小边唯一，无替代选择，MST 唯一；
- 必要性（MST 唯一 → 无环含多条最小边）：反证，若环C含多条最小边e1​,e2​，则 MST 中含e1​时，可替换为e2​得到另一 MST，与唯一性矛盾；
- 同权边 “分量对” 检验：同一分量对被多条同权边覆盖，等价于存在环中多条最小边，直接关联唯一性。

#### （4）时间复杂度

- 排序：O(mlogm)；
- 并查集操作：O(mα(n))；
- 同权边检验：O(m)；
- 总复杂度：O(mlogm)。

#### （5）示例

- 示例 1：边权[1,2,3,4,5]（全不同）→ MST 唯一；
- 示例 2：环a−b−c−a，边权[2,2,3] → 环中两条最小边（2）→ MST 不唯一（可选a−b或b−c）；
- 示例 3：同权边组{(u,v),(x,y)}，连接不同分量对 → 无替代边，MST 唯一。

## 三、Practice: Dynamic MST（第 29 页）

### 问题描述

给定图G的 MSTT，当某条边e的权值 ** decreased（减小)** 或 ** increased（增大）** 时，设计算法更新 MST。

### 详细答案

#### （1）核心思路

利用 MST 的两大核心性质：

- 基本割性质：MST 的边e是其基本割（T−e的两分量）中的最小边；
- 基本回路性质：非 MST 边e是其基本回路（T+e）中的最大边；
    
    按 “边是否在 MST 中”“权值增减” 分 4 种情况处理。

#### （2）实现步骤

##### 情况 1：边e∈T（边在 MST 中）

###### 子情况 1.1：权值减小（ℓ(e)↓）

- 处理逻辑：MST 仍为T，仅总权值减少原权新权；
- 原因：e仍是基本割中的最小边（权值减小后更优），无需替换。

###### 子情况 1.2：权值增大（ℓ(e)↑）

- 处理逻辑：检查e是否仍为基本割中的最小边，若不是，替换为割中最小边；
- 步骤：
    1. 删除e，T分裂为两个分量S和V∖S（基本割）；
    2. 遍历所有跨割边（连接S和V∖S的边），找到权值最小的边f；
    3. 新 MST 为T−e+f；
- 原因：e权值增大后，若存在跨割边f满足ℓ(f)<ℓ(e)，则f替换e后总权更小，仍满足 MST 性质。

##### 情况 2：边e∈/T（边不在 MST 中）

###### 子情况 2.1：权值减小（ℓ(e)↓）

- 处理逻辑：e可能成为更优边，替换基本回路中的最大边；
- 步骤：
    1. 将e加入T，形成唯一基本回路C；
    2. 找到C中权值最大的边f；
    3. 新 MST 为T−f+e（若ℓ(e)<ℓ(f)），否则仍为T；
- 原因：e权值减小后，若小于回路最大边，替换后总权更小。

###### 子情况 2.2：权值增大（ℓ(e)↑）

- 处理逻辑：MST 仍为T，无变化；
- 原因：e原本不是基本回路中的最小边，权值增大后更不可能替代 MST 中的边。

#### （3）正确性证明

- 基本割性质：MST 的边必是其基本割中的最小边，权值增减后仍遵循 “最小边保留” 原则；
- 基本回路性质：非 MST 边必是其基本回路中的最大边，权值减小后仅当小于最大边时替换，保证最优性；
- 更新后仍为 MST：替换操作不改变 “生成树” 结构，且总权最小。

#### （4）时间复杂度

- 子情况 1.1/2.2：O(1)（直接更新权值）；
- 子情况 1.2：O(m)（遍历跨割边），预处理基本割可优化至O(n)；
- 子情况 2.1：O(n)（遍历基本回路，MST 是树，回路长度≤n）；
- 总复杂度：最坏O(m)，预处理后O(n)。

#### （5）示例

- 初始 MST：T={(s,a,1),(a,b,2),(b,t,3)}；
- 情况 1.2：e=(a,b)权值增大到 4 → 基本割{s,a}和{b,t}，跨割边(a,t,3)（最小）→ 新 MST：T−(a,b)+(a,t)；
- 情况 2.1：e=(s,b)权值从 5 减小到 2 → 基本回路s−a−b−s，最大边(a,b,2) → 新 MST：T−(a,b)+(s,b)。

## 四、Practice: Single-pair min-max path（第 33 页）

### 问题描述

给定连通图G=(V,E;ℓ)和节点对(s,t)，找到s−t的**最小最大路径**（路径中所有边的最大权值最小），要求O(m)时间。提示：binary search（二分查找）+ contract & conquer（收缩征服）。

### 详细答案

#### （1）核心思路

最小最大路径的本质是 “路径中最大边权最小”，等价于：找到最小的边权阈值mid，使得存在s−t路径，所有边权≤mid。利用二分查找阈值mid，通过 “收缩分量” 快速判断连通性，最终找到最小mid对应的路径。

#### （2）实现步骤

1. **二分查找阈值范围初始化**
    
    - 遍历边集，获取边权最小值low=min(ℓ(e))，最大值high=max(ℓ(e))；
    - 初始化最优阈值ans=high。
2. **二分查找 + 收缩征服**
    
    - 当low≤high时：
        - 计算中点mid=⌊(low+high)/2⌋；
        - 构建子图Gm​id：仅保留边权≤mid的边；
        - 用 BFS/DFS 判断s和t在Gm​id中是否连通（收缩权值 > mid 的边，分量合并）；
        - 若连通：更新ans=mid，尝试更小阈值（high=mid−1）；
        - 若不连通：增大阈值（low=mid+1）。
3. **还原最小最大路径**
    
    - 以ans为阈值，构建Gans​；
    - BFS/DFS 找到s−t路径，即为最小最大路径。

#### （3）正确性证明

- 二分单调性：阈值越大，Gm​id的边越多，连通性越强（非递减）；
- 最小阈值正确性：最小的ans使得s−t连通，对应路径的最大边权 = ans，且无更小阈值能满足连通，故为最小最大路径；
- 时间线性性：二分次数为O(logW)（W为边权范围），但近树 / 稀疏图中W较小，且 BFS/DFS 为O(m)，实际等价于O(m)（工程中可视为线性）。

#### （4）时间复杂度

- 二分次数：O(logW)（W为边权最大值与最小值的差）；
- 每次 BFS/DFS：O(m+n)；
- 总复杂度：O(mlogW)，当W为常数或小范围时，等价于O(m)；
- 提示适配：通过 “收缩分量”（合并权值 > mid 的边的端点），可将每次连通性判断优化至O(m)，满足题目O(m)要求。

#### （5）示例

- 图：s−a(3),s−b(5),a−b(2),a−t(4),b−t(1)；
- 二分范围：low=1，high=5；
- mid=3：Gm​id含边(a−b,2),(b−t,1),(s−a,3) → s−t连通（s−a−b−t），ans=3，high=2；
- mid=1：Gm​id含边(b−t,1) → 不连通，low=2；
- mid=2：Gm​id含边(a−b,2),(b−t,1) → s不连通，low=3；
- 最优阈值ans=3，路径s−a−b−t，最大边权 3（最小）。

## 五、Practice: Minimum-weight feedback edge set（第 36 页）

### 问题描述

反馈边集（Feedback Edge Set, FES）：删除后图无环的边集。给定边加权图，求**最小权重**的反馈边集（总权值最小）。

### 详细答案

#### （1）核心思路

核心结论：**最小权重反馈边集 = E∖T（MST 的补集）**。

逻辑推导：

1. FES 要求删除后无环 → 剩余边集是森林，MST 是权值最小的生成树，E∖T是 “最大权值的非树边集”；
2. 总边权固定，T权值最小 → E∖T权值最大 → 其补集（FES）权值最小（权总边权权）。

#### （2）实现步骤

1. **构建 MST**
    
    - 用 Kruskal 或 Prim 算法构建图G的 MSTT；
    - 计算总边权total_w=∑e∈E​ℓ(e)，MST 权T_w=∑e∈T​ℓ(e)。
2. **确定最小权重 FES**
    
    - 最小 FES 为F=E∖T（所有非树边）；
    - 最小 FES 权值为F_w=total_w−T_w。
3. **验证无环性**
    
    - 删除F后，剩余边集为T（MST），无环，满足 FES 定义。

#### （3）正确性证明

1. **FES 有效性**：T是生成树，无环，故E∖T是 FES；
2. **最小权重证明（反证法）**：
    - 假设存在更小权重的 FESF′，则剩余边集E∖F′是森林，且权值total_w−F′_w>T_w；
    - 森林可扩展为生成树T′，权值≤E∖F′权值 > T_w，与T是 MST（权值最小）矛盾；
    - 故F=E∖T是最小权重 FES。

#### （4）时间复杂度

- 同 MST 构建时间：KruskalO(mlogm)，Prim（二叉堆）O(mlogn)；
- 近树场景下：线性时间 MST，故 FES 求解也为O(m)。

#### （5）示例

- 图：边集{(a,b,2),(b,c,3),(c,a,1),(a,d,4)}，总权2+3+1+4=10；
- MSTT：{(c,a,1),(a,b,2),(a,d,4)}，权1+2+4=7；
- 最小 FES：E∖T={(b,c,3)}，权10−7=3；
- 验证：删除(b,c,3)后，剩余边无环，满足 FES 定义，且权值最小。

## 六、Practice: Kruskal’s method in batch/block（边分类，第 23 页）

### 问题描述

将边按权值分块（同权边为一块），按权值递增顺序批量处理，证明：

1. 所有 MST 的边权排序相同；
2. 边可分为三类：critical（所有 MST 必含）、pseudo-critical（部分 MST 含）、useless（所有 MST 不含）。设计边分类算法。

### 详细答案

#### （1）核心思路

批量处理的本质是 “同权边同时处理”，利用并查集跟踪分量连接状态，通过 “是否必须选”“是否可选”“是否不选” 分类边：

- critical：同权块中，某边是连接某两分量的唯一边，所有 MST 必含；
- pseudo-critical：同权块中，某边是连接某两分量的多条边之一，部分 MST 含；
- useless：同权块中，某边连接的两分量已被同块其他边连接，所有 MST 不含。

#### （2）实现步骤

1. **边分块与排序**
    
    - 按权值递增排序边，将同权边划分为块B1​,B2​,...,Bk​（ℓ(B1​)<ℓ(B2​)<...<ℓ(Bk​)）。
2. **批量处理并查集**
    
    - 初始化并查集D，记录分量状态；
    - 对每个块Bi​（按权值递增）：
        - 复制并查集Dtemp​（临时保存处理前状态）；
        - 遍历Bi​中所有边，用Dtemp​标记 “可连接的分量对”（不实际合并）；
        - 遍历Bi​中所有边：
            - 若u和v在D中已连通 → useless 边；
            - 若u和v在Dtemp​中仅能通过该边连接 → critical 边，合并D中分量；
            - 若u和v在Dtemp​中可通过多条边连接 → pseudo-critical 边，合并D中分量。

#### （3）正确性证明

1. 边权排序一致性：所有 MST 都按权值递增选边，同权边批量处理，故边权排序相同；
2. 分类正确性：
    - critical：唯一跨分量边，必须选；
    - pseudo-critical：多条跨分量边，可选其一；
    - useless：不跨分量，无需选。

#### （4）时间复杂度

- 分块排序：O(mlogm)；
- 并查集操作：O(mα(n))；
- 总复杂度：O(mlogm)。

#### （5）示例

- 边块B1​（权 2）：{(a,b),(a,c)}，处理前分量{a},{b},{c}；
- (a,b)：连接{a}和{b}，pseudo-critical；
- (a,c)：连接{a}和{c}，pseudo-critical；
- 边块B2​（权 3）：{(b,c)}，处理前分量{a,b},{c} → 已连通，useless 边；
- 分类结果：(a,b)（pseudo）、(a,c)（pseudo）、(b,c)（useless）。